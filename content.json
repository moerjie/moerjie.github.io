{"meta":{"title":"Sawen_Blog","subtitle":"记录学习生活的点点滴滴","description":"","author":"Sawen Moerjie","url":"https://www.moerjielovecookie.icu","root":"/"},"pages":[{"title":"about","date":"2025-01-20T03:03:39.000Z","updated":"2025-01-20T03:29:12.489Z","comments":true,"path":"about/index.html","permalink":"https://www.moerjielovecookie.icu/about/index.html","excerpt":"","text":"我是一个普通的传媒工科牲"},{"title":"tag","date":"2025-01-19T13:53:49.000Z","updated":"2025-01-19T13:54:16.343Z","comments":true,"path":"tag/index.html","permalink":"https://www.moerjielovecookie.icu/tag/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-01-19T13:51:05.000Z","updated":"2025-01-19T13:51:58.136Z","comments":true,"path":"categories/index.html","permalink":"https://www.moerjielovecookie.icu/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"FIFO","date":"2025-02-05T12:58:31.119Z","updated":"2025-02-06T03:17:29.219Z","comments":true,"path":"2025/02/05/FIFO/","permalink":"https://www.moerjielovecookie.icu/2025/02/05/FIFO/","excerpt":"","text":"1","categories":[],"tags":[]},{"title":"FPGA开发时序图绘制","slug":"FPGA开发时序图绘制","date":"2025-01-31T16:00:00.000Z","updated":"2025-02-05T06:44:40.924Z","comments":true,"path":"2025/02/01/FPGA开发时序图绘制/","permalink":"https://www.moerjielovecookie.icu/2025/02/01/FPGA%E5%BC%80%E5%8F%91%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%BB%98%E5%88%B6/","excerpt":"","text":"开始的时候画时序图都是拿 visio 硬连，但是那个线宽太难统一了，丑不拉几的，遂学习 waveform 语法使用代码来画时序图。 开始Vscode 中安装 waveform render 或者在 GitHub 搜索 wavedrom 安装即可。由于 vscode 是我常用的编辑器，所以选择在 vscode 安装插件的方式来学习使用 waveform。在 vscode 中创建一个 json 文件，内容 1234567891011{ \"signal\":[ {\"name\":\"clk\",\"wave\":\"p.....\"}, {\"name\":\"data\",\"wave\":\"010101\"} ]} 在命令面板中选择如下命令后即可查看渲染结果： 语法时钟信号 p 表示上升沿开始的方波 n 表示下降沿开始的方波 l 表示低电平 h 表示高电平 大写会在方波边沿绘制箭头代码渲染出的时序图为： 数据信号 0 和 1 x 表示未知状态 =表示有效数据，也可写成 2~9，会用不同的颜色显示，并且可用 data 变量加上文本标签 可以用 | 表示省略一段信号period 和 phase 变量用于调整时序 period 的值应该是一个数字 n ，表示横向等比例放大或缩小 phase 的值应该是一个数字 n ，表示横向的位置调整，单位是一个时钟周期： 如果是正数，表示向左移动 n 个时钟周期 如果是负数，表示向右移动 n 个时钟周期多个信号可以用 ['group name', {...}, {...}, ...] 语法编成一组，而且支持嵌套时序绘制完毕后，还可以对图片进行修饰。 \"config\": { \"hscale\": n } 表示将图片横向等比例放大 n 倍。\"head\":{ } 和 \"foot\":{ } 分别表示在时序图的上方和下方添加一些内容： text 变量应该设置一个字符串，表示添加一行文本 tick 变量应该设置一个整数，表示在时钟周期的起点显示序号，从 n 开始 tock 变量应该设置一个整数，表示在时钟周期的中点显示序号，从 n 开始","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"ZYNQ-PS GPIO中断过程","slug":"ZYNQ-PS GPIO中断过程","date":"2025-01-26T16:00:00.000Z","updated":"2025-01-28T16:53:39.661Z","comments":true,"path":"2025/01/27/ZYNQ-PS GPIO中断过程/","permalink":"https://www.moerjielovecookie.icu/2025/01/27/ZYNQ-PS%20GPIO%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B/","excerpt":"中断初始化设置过程 查找中断控制器配置信息并初始化中断控制器驱动（XScuGic_LookupConfig、XScuGic_CfgInitialize） 设置中断类型（XScuGic_SetPriorityTriggerType） 为中断设置中断处理函数（XScuGic_Connect） 使能中断 (XScuGic_Enable) 设置并使能中断异常（Xil_ExceptionInit、Xil_ExceptionRegisterHandler、Xil_ExceptionEnable） 打开 GPIO 中断（XGpioPs_IntrEnablePin）","text":"中断初始化设置过程 查找中断控制器配置信息并初始化中断控制器驱动（XScuGic_LookupConfig、XScuGic_CfgInitialize） 设置中断类型（XScuGic_SetPriorityTriggerType） 为中断设置中断处理函数（XScuGic_Connect） 使能中断 (XScuGic_Enable) 设置并使能中断异常（Xil_ExceptionInit、Xil_ExceptionRegisterHandler、Xil_ExceptionEnable） 打开 GPIO 中断（XGpioPs_IntrEnablePin） 代码示例该代码包含部分 AXI GPIO 初始化的代码，其余都为 PS 端 GPIO 的初始化和中断初始化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275/****************************************************************************** * Copyright (C) 2002 - 2021 Xilinx, Inc. All rights reserved. * SPDX-License-Identifier: MIT ******************************************************************************//*****************************************************************************//** * @file xgpio_example.c * * This file contains a design example using the AXI GPIO driver (XGpio) and * hardware device. It only uses channel 1 of a GPIO device and assumes that * the bit 0 of the GPIO is connected to the LED on the HW board. * * * &lt;pre&gt; * MODIFICATION HISTORY: * * Ver Who Date Changes * ----- ---- -------- ----------------------------------------------- * 1.00a rmm 03/13/02 First release * 1.00a rpm 08/04/03 Removed second example and invalid macro calls * 2.00a jhl 12/15/03 Added support for dual channels * 2.00a sv 04/20/05 Minor changes to comply to Doxygen and coding guidelines * 3.00a ktn 11/20/09 Minor changes as per coding guidelines. * 4.1 lks 11/18/15 Updated to use canonical xparameters and * clean up of the comments and code for CR 900381 * 4.3 sk 09/29/16 Modified the example to make it work when LED_bits are * configured as an output. CR# 958644 * ms 01/23/17 Added xil_printf statement in main function to * ensure that \"Successfully ran\" and \"Failed\" strings * are available in all examples. This is a fix for * CR-965028. * 4.5 sne 06/12/19 Fixed IAR compiler warning. * * &lt;/pre&gt; ******************************************************************************//***************************** Include Files *********************************/#include \"xparameters.h\"#include \"xgpio.h\"#include \"xil_printf.h\"#include \"sleep.h\"#include \"xscugic.h\"#include \"xil_exception.h\"#include &lt;xgpiops.h&gt;/************************** Constant Definitions *****************************/#define MODE_SINGLE_TONE 0x00#define MODE_PRINTER 0x01/* * The following constants map to the XPAR parameters created in the * xparameters.h file. They are defined here such that a user can easily * change all the needed parameters in one place. *///PS端GPIO器件ID#define GPIO_EXAMPLE_DEVICE_ID XPAR_GPIO_0_DEVICE_ID/* * The following constant is used to wait after an LED is turned on to make * sure that it is visible to the human eye. This constant might need to be * tuned for faster or slower processor speeds. */#define LED_DELAY 10000000/* * The following constant is used to determine which channel of the GPIO is * used for the LED if there are 2 channels supported. */#define MODE_CHANGE_CHANNEL 1/*GPIO define *///PS端GPIO器件ID#define MIO_ID XPAR_PS7_GPIO_0_DEVICE_ID//通用中断控制器ID#define INTC_DEVICE_ID XPAR_SCUGIC_SINGLE_DEVICE_ID//PS端GPIO中断ID#define KEY_INTR_ID XPAR_XGPIOPS_0_INTR#define PS_KEY_MIO 50 //key连接到MIO50#define PS_LED_MIO_1 0#define PS_LED_MIO_2 13#define GPIO_INPUT 1#define GPIO_OUTPUT 0/**************************** Type Definitions *******************************//***************** Macros (Inline Functions) Definitions *********************/typedef struct XGpio XGpio;/************************** Function Prototypes ******************************/int IntrInitFunction(XScuGic *InstancePtr, u16 DeviceId, XGpioPs *GpioInstancePtr);void GpioHandler(void *CallBackRef);/************************** Variable Definitions *****************************//* * The following are declared globally so they are zeroed and so they are * easily accessible from a debugger */XGpio Gpio; /* PL端AXI GPIO外设驱动实例 */XGpioPs GpioPs; /* PS端GPIO外设驱动实例 */XScuGic INTCInst; /* 通用中断控制器驱动实例 */int key_flag; // ps key 0 flag/*****************************************************************************//** * * The purpose of this function is to illustrate how to use the GPIO * driver to turn on and off an LED. * * * @return XST_FAILURE to indicate that the GPIO Initialization had * failed. * * @note This function will not return if the test is running. * ******************************************************************************/int main(void){ XGpioPs_Config *GpioConfig; /*PS端GPIO配置信息*/ int Status; int mode_flag = 0; key_flag = 0; /* Initialize the GPIOps driver*/ /*根据器件ID查找配置信息*/ GpioConfig = XGpioPs_LookupConfig(MIO_ID); /*初始化GPIO Driver*/ Status = XGpioPs_CfgInitialize(&amp;GpioPs, GpioConfig, GpioConfig-&gt;BaseAddr); if (Status != XST_SUCCESS) { xil_printf(\"GpioPs Initialization Failed\\r\\n\"); return XST_FAILURE; } else { xil_printf(\"GpioPs Initialization Success\\r\\n\"); } /* Initialize the GPIO driver */ /*初始化PL端AXI GPIO驱动*/ Status = XGpio_Initialize(&amp;Gpio, GPIO_EXAMPLE_DEVICE_ID); if (Status != XST_SUCCESS) { xil_printf(\"Gpio Initialization Failed\\r\\n\"); return XST_FAILURE; } else { xil_printf(\"Gpio Initialization Success\\r\\n\"); } /*GPIO_PS Intr init*/ /*设置KEY连接的MIO引脚的方向为输入*/ XGpioPs_SetDirectionPin(&amp;GpioPs, PS_KEY_MIO, GPIO_INPUT); /*使能按键中断*/ XGpioPs_SetIntrTypePin(&amp;GpioPs, PS_KEY_MIO, XGPIOPS_IRQ_TYPE_EDGE_RISING); XGpioPs_IntrEnablePin(&amp;GpioPs, PS_KEY_MIO); Status = IntrInitFunction(&amp;INTCInst, MIO_ID, &amp;GpioPs); if (Status != XST_SUCCESS) { xil_printf(\"IntrInitFunction Failed\\r\\n\"); return XST_FAILURE; } else { xil_printf(\"IntrInitFunction Success\\r\\n\"); } /* Set the direction for GPIO OUT */ XGpio_SetDataDirection(&amp;Gpio, MODE_CHANGE_CHANNEL, GPIO_OUTPUT); /*Set the direction for PS GPIO 1 for output &amp; 0 for input*/ XGpioPs_SetDirectionPin(&amp;GpioPs, PS_LED_MIO_1, 1); XGpioPs_SetDirectionPin(&amp;GpioPs, PS_LED_MIO_2, 1); XGpioPs_SetOutputEnablePin(&amp;GpioPs, PS_LED_MIO_1, 1); XGpioPs_SetOutputEnablePin(&amp;GpioPs, PS_LED_MIO_2, 1); /* Loop forever blinking the LED */ while (1) { if (key_flag) { if (mode_flag == 0) { XGpio_DiscreteWrite(&amp;Gpio, MODE_CHANGE_CHANNEL, MODE_SINGLE_TONE); xil_printf(\"MODE_SINGLE_TONE, mode flag:%d\\r\\n\", mode_flag); XGpioPs_WritePin(&amp;GpioPs, PS_LED_MIO_1, 0); // LED1 ON XGpioPs_WritePin(&amp;GpioPs, PS_LED_MIO_2, 1); // LED2 OFF mode_flag++; } else if (mode_flag == 1) { XGpio_DiscreteWrite(&amp;Gpio, MODE_CHANGE_CHANNEL, MODE_PRINTER); xil_printf(\"Painter, mode flag:%d\\r\\n\", mode_flag); XGpioPs_WritePin(&amp;GpioPs, PS_LED_MIO_1, 1); // LED1 OFF XGpioPs_WritePin(&amp;GpioPs, PS_LED_MIO_2, 0); // LED2 ON mode_flag = 0; } key_flag = 0; } } return 0;}int IntrInitFunction(XScuGic *InstancePtr, u16 DeviceId, XGpioPs *GpioInstancePtr){ XScuGic_Config *IntcConfig; /*中断控制器配置信息*/ int Status; /* * Initialize the interrupt controller driver so that it is ready to * use. */ /*查找中断控制器配置信息并初始化中断控制器驱动*/ IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); Status = XScuGic_CfgInitialize(InstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); if (Status != XST_SUCCESS) return XST_FAILURE; /* * set priority and trigger type * 设置中断类型为上升沿中断 */ XScuGic_SetPriorityTriggerType(InstancePtr, KEY_INTR_ID, 0xA0, 0x3); /* * Connect the device driver handler that will be called when an * interrupt for the device occurs, the handler defined above performs * the specific interrupt processing for the device. */ /*为中断设置中断处理函数*/ Status = XScuGic_Connect(InstancePtr, KEY_INTR_ID, (Xil_ExceptionHandler)GpioHandler, (void *)GpioInstancePtr); if (Status != XST_SUCCESS) return XST_FAILURE; /* * Enable the interrupt for the device. * 使能来自GPIO的中断 */ XScuGic_Enable(InstancePtr, KEY_INTR_ID); /*设置并使能中断异常*/ Xil_ExceptionInit(); Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, InstancePtr); Xil_ExceptionEnable(); return XST_SUCCESS;}void GpioHandler(void *CallBackRef){ XGpioPs *GpioInstancePtr = (XGpioPs *)CallBackRef; int intr_val; intr_val = XGpioPs_IntrGetStatusPin(GpioInstancePtr, PS_KEY_MIO); /* Clear the interrupt */ XGpioPs_IntrClearPin(GpioInstancePtr, PS_KEY_MIO); if (intr_val) { xil_printf(\"Button Pressed\\r\\n\"); key_flag = 1; }}","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"}]},{"title":"AXI DMA+AXI-S FIFO回环学习","slug":"ZYNQ-AXI DMA+AXI-S FIFO回环学习","date":"2025-01-24T16:00:00.000Z","updated":"2025-01-26T12:01:33.458Z","comments":true,"path":"2025/01/25/ZYNQ-AXI DMA+AXI-S FIFO回环学习/","permalink":"https://www.moerjielovecookie.icu/2025/01/25/ZYNQ-AXI%20DMA+AXI-S%20FIFO%E5%9B%9E%E7%8E%AF%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"DMA 简介DMA 是现代计算机的特色之一，是硬件实现存储器与存储器、存储器与 I/O 设备之间直接进行高速数据传输的内存技术，它允许不同速率的设备进行沟通，而不需要依靠 CPU 的中断负载。如果不使用 DMA，那么 CPU 需要从数据源把每一个片段的数据复制到寄存器中，这个过程会一直占用 CPU 的资源。当使用 DMA 时，CPU 向 DMA 发送一个存储传输请求，当 DMA 控制器收到请求时就会将数据从源地址搬运到目的地址，搬运过程中不消化 CPU 的资源，当传输完成后 DMA 控制器以中断的方式通知 CPU。为了发起传输事务，DMA 控制器必须有： 源地址 目的地址 传输长度DMA 存储传输的过程如下： 处理器向 DMA 控制器发送一条 DMA 命令 DMA 控制器把数据从外设传输到存储器或从存储器搬运到存储器，而让 CPU 腾出手来做其它操作 数据传输完成后，DMA 控制器向 CPU 发出一个中断，来通知处理器 DMA 传输完成 ZYNQ 提供两种 DMA，一种是集成在 PS 中的硬核 DMA，一种是 PL 中的软核 AXI DMA IP。各种接口方式的比较如下：PL 的 DMA 和 AXI_HP 接口的传输适用于大量数据的高性能传输，带宽高，传输方式的拓扑图如下： AXI DMA IPAXI Direct Memory Access（AXI DMA）IP 核在 AXI 4 内存映射和 AXI 4-Stream IP 接口之间提供高带宽直接储存访问。 AXI DMA 用到了三种总线。AXI 4-Lite 用于对寄存器进行配置，AXI 4 Memory Map 总线用于读写 DDR 中的数据，AXI 4 Stream 总线用于 AXI DMA 对外设数据的读写，其中 AXI 4 Stream Master（MM 2 S，Memory Map to Stream）接口用于向 PL写入数据，AXI 4-Stream Slave (S 2 MM，Stream to Memory Map) 接口用于从 PL读取数据。AXI DMA 提供 3 种模式，分别是 Direct Register 模式、Scatter/Gather 模式和 Cyclic DMA（循环 DMA）模式，常用的是 Direct Register 模式。Direct Register DMA 模式即 Simple DMA 模式。Direct Register 模式提供了一种配置，用于在 MM 2 S 和 S 2 MM 通道上执行简单的 DMA 传输。Simple DMA（简单 DMA）允许应用程序在 DMA 和 Device 之间定义单个事务。它有两个通道：一个从 DMA 到 Device，另一个从 Device 到 DMA。这里有个地方需要大家注意下，在编写 Simple DMA（简单 DMA）代码时必须设置缓冲区地址和长度字段以启动相应通道中的传输。（其中 PL 对应 Device） Vivado 中的 IP 配置 Enable Scatter Gather Engine选中此选项可启用 Scatter Gather 模式操作，并在 AXI DMA 中包含 Scatter Gather Engine。取消选中此选项可启用 Direct Register 模式操作，但不包括 AXI DMA 中的 Scatter Gather Engine。禁用 Scatter Gather Engine 会使 Scatter/Gather Engine 的所有输出端口都绑定为零，并且所有输入端口都将保持打开状态。此处我们取消勾选 Enable Scatter Gather EngineEnable Micro DMA使能后会生成高度优化的 DMA，资源消耗较少，用于极少量数据的传输Width of Buffer Length Register该选项配置了 AXI DMA 单次最大能搬运多少个字节，字节数 Address Width (32 - 64)指定地址空间的宽度，可以是 32 到 64 之间的任意值Enable Read Channel开启 AXI DMA 的读通道 MM 2 S，相关配置如下： Number of Channels：指定通道数。保持默认值 1 Memory Map Data Width：AXI MM 2 S 存储映射读取数据总线的数据位宽。有效值为 32、64、128、256、512 和 1024。此处保持默认值 32 Stream Data Width：AXI MM 2 S AXI 4-Stream 数据总线的数据位宽。该值必须小于或等于 Memory Map Data Width。有效值为 8、16、32、64、128、512 和 1024。此处保持默认值 32 Max Burst Size：突发分区粒度设置。此设置指定 MM 2 S 的 AXI 4-Memory Map 侧的突发周期的最大值。有效值为 2、4、8、16、32、64、128 和 256 Allow Unaligned Transfers：启用或禁用 MM 2 S 数据重新排列引擎（Data Realignment Engine，DRE）。选中时，DRE 被使能并允许在 MM 2 S 存储映射数据路径上数据重新对齐到 8 位的字节水平。对于 MM 2 S通道，则从内存中读取数据。如果 DRE 被使能，则数据读取可以从任何缓冲区地址字节偏移开始，并且读取数据被对齐，使得第一个字节读取是 AXI 4-Stream 上的第一个有效字节输出Enable Write Channel开启 AXI DMA 的写通道 S 2 MM，相关配置同上 Vitis 工程解析头文件引用和宏定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/***************************** Include Files *********************************/#include \"xaxidma.h\"#include \"xparameters.h\"#include \"xil_exception.h\"#include \"xdebug.h\"#include \"xil_util.h\"#ifdef XPAR_UARTNS550_0_BASEADDR#include \"xuartns550_l.h\" /* to use uartns550 */#endif#ifdef XPAR_INTC_0_DEVICE_ID#include \"xintc.h\"#else#include \"xscugic.h\"#endif/************************** Constant Definitions *****************************//* * Device hardware build related constants. */#define DMA_DEV_ID XPAR_AXIDMA_0_DEVICE_ID#ifdef XPAR_AXI_7SDDR_0_S_AXI_BASEADDR#define DDR_BASE_ADDR XPAR_AXI_7SDDR_0_S_AXI_BASEADDR#elif defined(XPAR_MIG7SERIES_0_BASEADDR)#define DDR_BASE_ADDR XPAR_MIG7SERIES_0_BASEADDR#elif defined(XPAR_MIG_0_C0_DDR4_MEMORY_MAP_BASEADDR)#define DDR_BASE_ADDR XPAR_MIG_0_C0_DDR4_MEMORY_MAP_BASEADDR#elif defined(XPAR_PSU_DDR_0_S_AXI_BASEADDR)#define DDR_BASE_ADDR XPAR_PSU_DDR_0_S_AXI_BASEADDR#endif#define DDR_BASE_ADDR XPAR_PS7_DDR_0_S_AXI_BASEADDR // 0x00100000#ifndef DDR_BASE_ADDR#warning CHECK FOR THE VALID DDR ADDRESS IN XPARAMETERS.H, \\ DEFAULT SET TO 0x01000000#define MEM_BASE_ADDR 0x01000000#else#define MEM_BASE_ADDR (DDR_BASE_ADDR + 0x01000000) // 0x01100000#endif#ifdef XPAR_INTC_0_DEVICE_ID#define RX_INTR_ID XPAR_INTC_0_AXIDMA_0_S2MM_INTROUT_VEC_ID#define TX_INTR_ID XPAR_INTC_0_AXIDMA_0_MM2S_INTROUT_VEC_ID#else#define RX_INTR_ID XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID#define TX_INTR_ID XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID#endif#define TX_BUFFER_BASE (MEM_BASE_ADDR + 0x00100000) // 0x01200000#define RX_BUFFER_BASE (MEM_BASE_ADDR + 0x00300000) // 0x01400000#define RX_BUFFER_HIGH (MEM_BASE_ADDR + 0x004FFFFF) // 0x015FFFFF#ifdef XPAR_INTC_0_DEVICE_ID#define INTC_DEVICE_ID XPAR_INTC_0_DEVICE_ID#else#define INTC_DEVICE_ID XPAR_SCUGIC_SINGLE_DEVICE_ID#endif#ifdef XPAR_INTC_0_DEVICE_ID#define INTC XIntc#define INTC_HANDLER XIntc_InterruptHandler#else#define INTC XScuGic#define INTC_HANDLER XScuGic_InterruptHandler#endif/* Timeout loop counter for reset */#define RESET_TIMEOUT_COUNTER 10000#define TEST_START_VALUE 0x1/* * Buffer and Buffer Descriptor related constant definition */#define MAX_PKT_LEN 0x200#define NUMBER_OF_TRANSFERS 10#define POLL_TIMEOUT_COUNTER 1000000U#define NUMBER_OF_EVENTS 1 #define DDR_BASE_ADDR XPAR_AXI_7SDDR_0_S_AXI_BASEADDR 重新定义了 DDR 3 的基址.。数据读写的基址为 #define MEM_BASE_ADDR (DDR_BASE_ADDR + 0x01000000) // 0x01100000 AXI DMA 读取数据的起始地址为 #define TX_BUFFER_BASE (MEM_BASE_ADDR + 0x00100000) // 0x01200000，写入地址为 0x01400000 定义函数和声明相关的 instance 和 flag 变量1234567891011121314151617181920212223242526272829303132333435363738/**************************** Type Definitions *******************************//***************** Macros (Inline Functions) Definitions *********************//************************** Function Prototypes ******************************/#ifndef DEBUGextern void xil_printf(const char *format, ...);#endif#ifdef XPAR_UARTNS550_0_BASEADDRstatic void Uart550_Setup(void);#endifstatic int CheckData(int Length, u8 StartValue);static void TxIntrHandler(void *Callback);static void RxIntrHandler(void *Callback);static int SetupIntrSystem(INTC *IntcInstancePtr, XAxiDma *AxiDmaPtr, u16 TxIntrId, u16 RxIntrId);static void DisableIntrSystem(INTC *IntcInstancePtr, u16 TxIntrId, u16 RxIntrId);/************************** Variable Definitions *****************************//* * Device instance definitions */static XAxiDma AxiDma; /* Instance of the XAxiDma */static INTC Intc; /* Instance of the Interrupt Controller *//* * Flags interrupt handlers use to notify the application context the events. */volatile u32 TxDone;volatile u32 RxDone;volatile u32 Error; Main 函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206/*****************************************************************************//** * * Main function * * This function is the main entry of the interrupt test. It does the following: * Set up the output terminal if UART16550 is in the hardware build * Initialize the DMA engine * Set up Tx and Rx channels * Set up the interrupt system for the Tx and Rx interrupts * Submit a transfer * Wait for the transfer to finish * Check transfer status * Disable Tx and Rx interrupts * Print test status and exit * * @param None * * @return * - XST_SUCCESS if example finishes successfully * - XST_FAILURE if example fails. * * @note None. * ******************************************************************************/int main(void){ int Status; XAxiDma_Config *Config; int Tries = NUMBER_OF_TRANSFERS; int Index; u8 *TxBufferPtr; u8 *RxBufferPtr; u8 Value; TxBufferPtr = (u8 *)TX_BUFFER_BASE; RxBufferPtr = (u8 *)RX_BUFFER_BASE; /* Initial setup for Uart16550 */#ifdef XPAR_UARTNS550_0_BASEADDR Uart550_Setup();#endif xil_printf(\"\\r\\n--- Entering main() --- \\r\\n\"); Config = XAxiDma_LookupConfig(DMA_DEV_ID); if (!Config) { xil_printf(\"No config found for %d\\r\\n\", DMA_DEV_ID); return XST_FAILURE; } else { xil_printf(\"Config found for %d\\r\\n\", DMA_DEV_ID); } /* Initialize DMA engine */ Status = XAxiDma_CfgInitialize(&amp;AxiDma, Config); if (Status != XST_SUCCESS) { xil_printf(\"Initialization failed %d\\r\\n\", Status); return XST_FAILURE; } else { xil_printf(\"DMA Initialization success %d\\r\\n\", Status); } if (XAxiDma_HasSg(&amp;AxiDma)) { xil_printf(\"Device configured as SG mode \\r\\n\"); return XST_FAILURE; } else { xil_printf(\"Device configured as simple mode \\r\\n\"); } /* Set up Interrupt system */ Status = SetupIntrSystem(&amp;Intc, &amp;AxiDma, TX_INTR_ID, RX_INTR_ID); if (Status != XST_SUCCESS) { xil_printf(\"Failed intr setup\\r\\n\"); return XST_FAILURE; } /* Disable all interrupts before setup */ XAxiDma_IntrDisable(&amp;AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE); XAxiDma_IntrDisable(&amp;AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA); /* Enable all interrupts */ XAxiDma_IntrEnable(&amp;AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE); XAxiDma_IntrEnable(&amp;AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA); /* Initialize flags before start transfer test */ TxDone = 0; RxDone = 0; Error = 0; Value = TEST_START_VALUE; for (Index = 0; Index &lt; MAX_PKT_LEN; Index++) { TxBufferPtr[Index] = Value; Value = (Value + 1) &amp; 0xFF; } /* Flush the buffers before the DMA transfer, in case the Data Cache * is enabled */ Xil_DCacheFlushRange((UINTPTR)TxBufferPtr, MAX_PKT_LEN); Xil_DCacheFlushRange((UINTPTR)RxBufferPtr, MAX_PKT_LEN); /* Send a packet */ for (int i = 0; i &lt; Tries; i++) { Status = XAxiDma_SimpleTransfer(&amp;AxiDma, (UINTPTR)RxBufferPtr, MAX_PKT_LEN, XAXIDMA_DEVICE_TO_DMA); if (Status != XST_SUCCESS) { return XST_FAILURE; } Status = XAxiDma_SimpleTransfer(&amp;AxiDma, (UINTPTR)TxBufferPtr, MAX_PKT_LEN, XAXIDMA_DMA_TO_DEVICE); if (Status != XST_SUCCESS) { return XST_FAILURE; } Status = Xil_WaitForEventSet(POLL_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &amp;Error); if (Status == XST_SUCCESS) { if (!TxDone) { xil_printf(\"Transmit error %d\\r\\n\", Status); goto Done; } else if (Status == XST_SUCCESS &amp;&amp; !RxDone) { xil_printf(\"Receive error %d\\r\\n\", Status); goto Done; } } /* * Wait for TX done or timeout */ Status = Xil_WaitForEventSet(POLL_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &amp;TxDone); if (Status != XST_SUCCESS) { xil_printf(\"Transmit failed %d\\r\\n\", Status); goto Done; } /* * Wait for RX done or timeout */ Status = Xil_WaitForEventSet(POLL_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &amp;RxDone); if (Status != XST_SUCCESS) { xil_printf(\"Receive failed %d\\r\\n\", Status); goto Done; } /* * Test finished, check data */ Status = CheckData(MAX_PKT_LEN, 0x1); if (Status != XST_SUCCESS) { xil_printf(\"Data check failed\\r\\n\"); goto Done; } xil_printf(\"Transfer %d done\\r\\n\", i + 1); } xil_printf(\"Successfully ran AXI DMA interrupt Example\\r\\n\"); /* Disable TX and RX Ring interrupts and return success */ DisableIntrSystem(&amp;Intc, TX_INTR_ID, RX_INTR_ID);Done: xil_printf(\"--- Exiting main() --- \\r\\n\"); if (Status != XST_SUCCESS) { return XST_FAILURE; } return XST_SUCCESS;} Tries 为测试回环的次数 函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355*****************************************************************************//* * * This function checks data buffer after the DMA transfer is finished. * * We use the static tx/rx buffers. * * @param Length is the length to check * @param StartValue is the starting value of the first byte * * @return * - XST_SUCCESS if validation is successful * - XST_FAILURE if validation is failure. * * @note None. * ******************************************************************************/static int CheckData(int Length, u8 StartValue){ u8 *RxPacket; int Index = 0; u8 Value; RxPacket = (u8 *)RX_BUFFER_BASE; Value = StartValue; /* Invalidate the DestBuffer before receiving the data, in case the * Data Cache is enabled */ Xil_DCacheInvalidateRange((UINTPTR)RxPacket, Length); for (Index = 0; Index &lt; Length; Index++) { if (RxPacket[Index] != Value) { xil_printf(\"Data error %d: %x/%x\\r\\n\", Index, RxPacket[Index], Value); return XST_FAILURE; } Value = (Value + 1) &amp; 0xFF; } return XST_SUCCESS;}/*****************************************************************************//* * * This is the DMA TX Interrupt handler function. * * It gets the interrupt status from the hardware, acknowledges it, and if any * error happens, it resets the hardware. Otherwise, if a completion interrupt * is present, then sets the TxDone.flag * * @param Callback is a pointer to TX channel of the DMA engine. * * @return None. * * @note None. * ******************************************************************************/static void TxIntrHandler(void *Callback){ u32 IrqStatus; int TimeOut; XAxiDma *AxiDmaInst = (XAxiDma *)Callback; /* Read pending interrupts */ IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DMA_TO_DEVICE); /* Acknowledge pending interrupts */ XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DMA_TO_DEVICE); /* * If no interrupt is asserted, we do not do anything */ if (!(IrqStatus &amp; XAXIDMA_IRQ_ALL_MASK)) { return; } /* * If error interrupt is asserted, raise error flag, reset the * hardware to recover from the error, and return with no further * processing. */ if ((IrqStatus &amp; XAXIDMA_IRQ_ERROR_MASK)) { Error = 1; /* * Reset should never fail for transmit channel */ XAxiDma_Reset(AxiDmaInst); TimeOut = RESET_TIMEOUT_COUNTER; while (TimeOut) { if (XAxiDma_ResetIsDone(AxiDmaInst)) { break; } TimeOut -= 1; } return; } /* * If Completion interrupt is asserted, then set the TxDone flag */ if ((IrqStatus &amp; XAXIDMA_IRQ_IOC_MASK)) { TxDone = 1; }}/*****************************************************************************//* * * This is the DMA RX interrupt handler function * * It gets the interrupt status from the hardware, acknowledges it, and if any * error happens, it resets the hardware. Otherwise, if a completion interrupt * is present, then it sets the RxDone flag. * * @param Callback is a pointer to RX channel of the DMA engine. * * @return None. * * @note None. * ******************************************************************************/static void RxIntrHandler(void *Callback){ u32 IrqStatus; int TimeOut; XAxiDma *AxiDmaInst = (XAxiDma *)Callback; /* Read pending interrupts */ IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DEVICE_TO_DMA); /* Acknowledge pending interrupts */ XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DEVICE_TO_DMA); /* * If no interrupt is asserted, we do not do anything */ if (!(IrqStatus &amp; XAXIDMA_IRQ_ALL_MASK)) { return; } /* * If error interrupt is asserted, raise error flag, reset the * hardware to recover from the error, and return with no further * processing. */ if ((IrqStatus &amp; XAXIDMA_IRQ_ERROR_MASK)) { Error = 1; /* Reset could fail and hang * NEED a way to handle this or do not call it?? */ XAxiDma_Reset(AxiDmaInst); TimeOut = RESET_TIMEOUT_COUNTER; while (TimeOut) { if (XAxiDma_ResetIsDone(AxiDmaInst)) { break; } TimeOut -= 1; } return; } /* * If completion interrupt is asserted, then set RxDone flag */ if ((IrqStatus &amp; XAXIDMA_IRQ_IOC_MASK)) { RxDone = 1; }}/*****************************************************************************//* * * This function setups the interrupt system so interrupts can occur for the * DMA, it assumes INTC component exists in the hardware system. * * @param IntcInstancePtr is a pointer to the instance of the INTC. * @param AxiDmaPtr is a pointer to the instance of the DMA engine * @param TxIntrId is the TX channel Interrupt ID. * @param RxIntrId is the RX channel Interrupt ID. * * @return * - XST_SUCCESS if successful, * - XST_FAILURE.if not successful * * @note None. * ******************************************************************************/static int SetupIntrSystem(INTC *IntcInstancePtr, XAxiDma *AxiDmaPtr, u16 TxIntrId, u16 RxIntrId){ int Status;#ifdef XPAR_INTC_0_DEVICE_ID /* Initialize the interrupt controller and connect the ISRs */ Status = XIntc_Initialize(IntcInstancePtr, INTC_DEVICE_ID); if (Status != XST_SUCCESS) { xil_printf(\"Failed init intc\\r\\n\"); return XST_FAILURE; } Status = XIntc_Connect(IntcInstancePtr, TxIntrId, (XInterruptHandler)TxIntrHandler, AxiDmaPtr); if (Status != XST_SUCCESS) { xil_printf(\"Failed tx connect intc\\r\\n\"); return XST_FAILURE; } Status = XIntc_Connect(IntcInstancePtr, RxIntrId, (XInterruptHandler)RxIntrHandler, AxiDmaPtr); if (Status != XST_SUCCESS) { xil_printf(\"Failed rx connect intc\\r\\n\"); return XST_FAILURE; } /* Start the interrupt controller */ Status = XIntc_Start(IntcInstancePtr, XIN_REAL_MODE); if (Status != XST_SUCCESS) { xil_printf(\"Failed to start intc\\r\\n\"); return XST_FAILURE; } XIntc_Enable(IntcInstancePtr, TxIntrId); XIntc_Enable(IntcInstancePtr, RxIntrId);#else XScuGic_Config *IntcConfig; /* * Initialize the interrupt controller driver so that it is ready to * use. */ IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); if (NULL == IntcConfig) { return XST_FAILURE; } Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); if (Status != XST_SUCCESS) { return XST_FAILURE; } //设置中断优先级和触发类型 XScuGic_SetPriorityTriggerType(IntcInstancePtr, TxIntrId, 0xA0, 0x3); XScuGic_SetPriorityTriggerType(IntcInstancePtr, RxIntrId, 0xA0, 0x3); /* * Connect the device driver handler that will be called when an * interrupt for the device occurs, the handler defined above performs * the specific interrupt processing for the device. */ //设置中断处理函数 Status = XScuGic_Connect(IntcInstancePtr, TxIntrId, (Xil_InterruptHandler)TxIntrHandler, AxiDmaPtr); if (Status != XST_SUCCESS) { return Status; } Status = XScuGic_Connect(IntcInstancePtr, RxIntrId, (Xil_InterruptHandler)RxIntrHandler, AxiDmaPtr); if (Status != XST_SUCCESS) { return Status; } XScuGic_Enable(IntcInstancePtr, TxIntrId); XScuGic_Enable(IntcInstancePtr, RxIntrId);#endif /* Enable interrupts from the hardware */ Xil_ExceptionInit(); Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)INTC_HANDLER, (void *)IntcInstancePtr); Xil_ExceptionEnable(); return XST_SUCCESS;}/*****************************************************************************//** * * This function disables the interrupts for DMA engine. * * @param IntcInstancePtr is the pointer to the INTC component instance * @param TxIntrId is interrupt ID associated w/ DMA TX channel * @param RxIntrId is interrupt ID associated w/ DMA RX channel * * @return None. * * @note None. * ******************************************************************************/static void DisableIntrSystem(INTC *IntcInstancePtr, u16 TxIntrId, u16 RxIntrId){#ifdef XPAR_INTC_0_DEVICE_ID /* Disconnect the interrupts for the DMA TX and RX channels */ XIntc_Disconnect(IntcInstancePtr, TxIntrId); XIntc_Disconnect(IntcInstancePtr, RxIntrId);#else XScuGic_Disconnect(IntcInstancePtr, TxIntrId); XScuGic_Disconnect(IntcInstancePtr, RxIntrId);#endif}","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"}]},{"title":"hexo部署到github page时，hexo d后page里面绑定的个人域名消失的问题","slug":"hexo部署到github page时，hexo d后page里面绑定的个人域名消失的问题","date":"2025-01-23T16:00:00.000Z","updated":"2025-01-25T02:29:08.081Z","comments":true,"path":"2025/01/24/hexo部署到github page时，hexo d后page里面绑定的个人域名消失的问题/","permalink":"https://www.moerjielovecookie.icu/2025/01/24/hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%20page%E6%97%B6%EF%BC%8Chexo%20d%E5%90%8Epage%E9%87%8C%E9%9D%A2%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B6%88%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"Hexo 部署博客到 GitHub page 后，可以在 setting 中的 page 中绑定自己的域名，但是我发现更新博客后绑定的域名消失，恢复原始的 githubio 的域名。后面搜索发现需要在 repo 里面添加 CNAME 文件，内容为 page 里面绑定的域名：但是这样的话每次 deploy 后 CNAME 文件会消失。然后我将这个文件放到本地 hexo 文件夹内的 public 文件夹中，这样的话 deploy 后 CNAME 文件就会和别的 html 文件一起推送到 GitHub 仓库里面。看似解决了，可是在调试主题的时候，运行了 hexo clean 后导致 public 文件夹被删除，CNAME 文件又没了。最后的最后，了解到执行 hexo g 的时候，会 source 文件夹内的文件进行编译，因此将 CNAME 放到 source 文件夹中即可完美解决。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"}]},{"title":"Verilog中if语句和case语句综合出的电路区别","slug":"Verilog中if语句和case语句综合出的电路区别","date":"2025-01-20T16:00:00.000Z","updated":"2025-01-21T12:31:15.896Z","comments":true,"path":"2025/01/21/Verilog中if语句和case语句综合出的电路区别/","permalink":"https://www.moerjielovecookie.icu/2025/01/21/Verilog%E4%B8%ADif%E8%AF%AD%E5%8F%A5%E5%92%8Ccase%E8%AF%AD%E5%8F%A5%E7%BB%BC%E5%90%88%E5%87%BA%E7%9A%84%E7%94%B5%E8%B7%AF%E5%8C%BA%E5%88%AB/","excerpt":"","text":"区别是 if else 的逻辑判断有优先级，最内层的 if 的优先级最高，case 的逻辑判断是并列的。每个 if else 综合出来的电路是一个 2 选 1 选通器。当信号有明显优先级时使用该语句，但是 if 嵌套太多的话会导致路径延时过大，降低运行速度。所以在判定条件较少的时候使用。if else 综合出的电路面积较小。case语句适用于无明显优先级的逻辑判断，这些逻辑条件都处于同一个优先级且互斥，比如实现对速度要求较高的编解码；case结构电路速度较快，但占用面积较大，综合为 n 选 1 mux电路。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"ZYNQ-IP-AXI-GPIO","slug":"ZYNQ-IP-AXI-GPIO","date":"2025-01-19T16:00:00.000Z","updated":"2025-01-23T12:45:24.334Z","comments":true,"path":"2025/01/20/ZYNQ-IP-AXI-GPIO/","permalink":"https://www.moerjielovecookie.icu/2025/01/20/ZYNQ-IP-AXI-GPIO/","excerpt":"","text":"AXI GPIO 可以将 PS 端的一个 AXI 4-Lite 接口转化为 GPIO 接口，并且可以被配置为单端口或双端口，每个通道的位宽可以独立配置。通过使能三态门可以将端口动态地配置为输入或输出。AXIGPIO 是 ZYNQ PL 端的一个 IP 核，可以将 AXI-Lite Master 转为 GPIO，并且一个 AXI-Lite 接口可以通过 AXI interconnect 模块控制多个 AXI-GPIO。 AXI-GPIO IP 设置最大时钟频率 的最大频率和 的速率相同，为 。 AXI GPIO 设置默认为单通道。GPIO 的方向在这里设置了以后就不能在 vitis 中设置 GPIO 的方向。中断属于 PL 对 PS 的中断，需要在 ZYNQ 7 Processing System 中勾选 生成的 vitis 的代码中，xparameters.h 中的 id 默认从 ID 0 开始，不管 vivado 这边的 AXI-GPIO 的序号是从 0 开始还是从 1 开始。 [!note] GPIO 只能使能整个通道中断，无法单独使能通道中的某个引脚中断 中断类型只能设置为上升沿或高电平 AXI-GPIO 相关代码初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/****************************************************************************//*** Initialize the XGpio instance provided by the caller based on the* given configuration data.** Nothing is done except to initialize the InstancePtr.** @param InstancePtr is a pointer to an XGpio instance. The memory the* pointer references must be pre-allocated by the caller. Further* calls to manipulate the driver through the XGpio API must be* made with this pointer.* @param Config is a reference to a structure containing information* about a specific GPIO device. This function initializes an* InstancePtr object for a specific device specified by the* contents of Config. This function can initialize multiple* instance objects with the use of multiple calls giving different* Config information on each call.* @param EffectiveAddr is the device base address in the virtual memory* address space. The caller is responsible for keeping the address* mapping from EffectiveAddr to the device physical base address* unchanged once this function is invoked. Unexpected errors may* occur if the address mapping changes after this function is* called. If address translation is not used, use* Config-&gt;BaseAddress for this parameters, passing the physical* address instead.** @return* - XST_SUCCESS if the initialization is successful.** @note None.******************************************************************************/int XGpio_CfgInitialize(XGpio * InstancePtr, XGpio_Config * Config, UINTPTR EffectiveAddr) 设置输入输出方向1234567891011121314151617181920212223242526272829303132/****************************************************************************//*** Set the input/output direction of all discrete signals for the specified* GPIO channel.** @param InstancePtr is a pointer to an XGpio instance to be worked on.* @param Channel contains the channel of the GPIO (1 or 2) to operate on.* @param DirectionMask is a bitmask specifying which discretes are input* and which are output. Bits set to 0 are output and bits set to 1* are input.** @return None.** @note The hardware must be built for dual channels if this function* is used with any channel other than 1. If it is not, this* function will assert.******************************************************************************/void XGpio_SetDataDirection(XGpio *InstancePtr, unsigned Channel, u32 DirectionMask) GPIO 读写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/****************************************************************************//*** Read state of discretes for the specified GPIO channel.* @param InstancePtr is a pointer to an XGpio instance to be worked on.* @param Channel contains the channel of the GPIO (1 or 2) to operate on.* @return Current copy of the discretes register.* @note The hardware must be built for dual channels if this function* is used with any channel other than 1. If it is not, this* function will assert.*****************************************************************************/u32 XGpio_DiscreteRead(XGpio * InstancePtr, unsigned Channel)/****************************************************************************//*** Write to discretes register for the specified GPIO channel.** @param InstancePtr is a pointer to an XGpio instance to be worked on.* @param Channel contains the channel of the GPIO (1 or 2) to operate on.* @param Mask is the value to be written to the discretes register.** @return None.** @note The hardware must be built for dual channels if this function* is used with any channel other than 1. If it is not, this* function will assert. See also XGpio_DiscreteSet() and* XGpio_DiscreteClear().******************************************************************************/void XGpio_DiscreteWrite(XGpio * InstancePtr, unsigned Channel, u32 Mask)","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"}]},{"title":"ZYNQ中的GPIO","slug":"ZYNQ中的IO","date":"2025-01-19T16:00:00.000Z","updated":"2025-01-20T12:47:21.312Z","comments":true,"path":"2025/01/20/ZYNQ中的IO/","permalink":"https://www.moerjielovecookie.icu/2025/01/20/ZYNQ%E4%B8%AD%E7%9A%84IO/","excerpt":"","text":"GPIO 原理GPIO 通过 MIO 提供 54 路接口，其中 16 路位于 bank 500，剩余位于 bank 501。还通过 EMIO 接口提供从 PL 来的 64 路输入和 128 路输出。GPIO 控制和状态寄存器内存映射在基址 。ZYNQ 的 GPIO 引脚分为 4 个 bank，共有 118 个 GPIO。个个（）个（）个（）个（） GPIO 内部结构从图中可以看到 GPIO 有三个功能：输入、输出、中断。其中 MIO 7 和 9 只能做输出。一组寄存器只能控制一个 GPIO bank 的所有引脚。 器件引脚的 GPIO 控制输入/输出寄存器 寄存器名称 说明 DATA_RO GPIO引脚的值存储在此寄存器中，无论GPIO被配置为输入或输出，都可以通过读此寄存器得到GPIO引脚的值。 因为是只读寄存器（对软件来说），软件向此寄存器的写入操作将被忽略。 DATA 输出数据寄存器，当GPIO被配置为输出才起作用，此寄存器中的值就是输出到引脚的值。 向此寄存器写入就是在设置GPIO的输出值， 读此寄存器将返回GPIO前一时刻的输出值，而不是现在的值。 MASK_DATA_LSW Mask Data Least Significant Words，输出数据低16位掩码寄存器，此寄存器只有低16位有效， 对应位为1表示DATA寄存器低16位中对应位的值可以更改， 若不为1，则表示DATA寄存器低16位中对应位保持原值 MASK_DATA_MSW Mask Data Most Significant Words，输出数据高16位掩码寄存器， 功能同MASK_DATA_LSW，只是它对应DATA寄存器高16位 DIRM Direction Memory，方向寄存器，默认为0表示输入，设为1表示输出 注意，即使DIRM为1，软件也可以像输入一样去读此引脚的电平 OEN Output Enable，输出使能寄存器， 仅当DIRM为0时有效，为1表示输出使能， 为0表示输出不使能，此时对应引脚上的值为三态值 中断控制寄存器 寄存器名称 说明 INT_TYPE Interrupt Type 中断类型寄存器， 控制GPIO中断是电平触发还是边缘触发 INT_POLARITY Interrupt Polarity 中断极性寄存器 控制GPIO中断是低电平/下降沿有效，还是高电平/上升沿有效 INT_ANY Interrupt Any，双边沿寄存器， 仅当INT_TYPE为边沿触发时，此寄存器才有效，控制是否双沿均可触发中断 INT_STAT Interrupt State，中断状态寄存器， 此寄存器的值会被与之相连的INT State D触发器读取 D触发器存储中断状态，软件通过读此D触发器输出来判断中断是否发生， 清除此D触发器来清除中断状态 INT_MASK Interrupt Mask，中断掩码寄存器， 显示当前哪些位被屏蔽，哪些位启用 INT_DIS Interrupt Disable，中断失效寄存器， 向该寄存器的任何位写入 1 都会屏蔽该中断信号。 从该寄存器读取会返回不可预测的值 INT_EN Interrupt Enable，中断使能寄存器 向该寄存器的任何位写入 1，可以启用/解除中断信号的掩码。 从该寄存器读取将返回一个不不可预测的值 GPIO 的中断号为 ==52==，中断优先级是固定的，无需配置 GPIO 的中断优先级。GPIO 所有引脚共享同一个中断，即使能两个引脚的中断的话，软件无法判断中断来自哪个引脚。 EMIO 和 MIOMIO，Multiuse I/O，复用输入/输出，对应 PS 端的可配置的多功能引脚。EMIO，Extent MIO，对应 PL 端的可配置多功能引脚。MIO 是外设的基本引脚，由于 MIO 的引脚数量较少，ZYNQ 也提供 EMIO 接口作为 MIO 的扩展，外设通过 EMIO 接口连接到 PL 端的引脚，来实现和 MIO 几乎相同的功能。MIO 和 EMIO 的不同点如下： MIO 对于 PL 端是透明的，PL 无法读取 MIO 引脚上的电平；PS 端可以通过 EMIO 与 PL 端通信。 外设与 MIO 是固定搭配的，初始化时要根据开发板原理图来选择引脚约束。EMIO 相对灵活，引脚可以任意指定，通过 xdc 文件约束指定到 PL 端的某个引脚。 因为 MIO 引脚更靠近外围电路，相较于 EMIO，一些外设使用 MIO 的性能更好，还有一些外设只能使用 MIO。 MIO bank 和封装的 bank 的区别与联系MIO 分为 Bank 0 和 Bank 1，Bank 0 是封装 Bank 500 中的部分引脚，Bank 1 是封装的 bank 501 的部分引脚。Bank 0 包含 MIO 015 共 16 个 MIO，bank 1 包括 MIO 1653 共 38 个 MIO，总共有 54 个 MIO。EMIO 一共有 64 个。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"}]},{"title":"","slug":"template/blog_template","date":"2025-01-19T13:52:42.408Z","updated":"2025-01-20T03:53:16.541Z","comments":true,"path":"2025/01/19/template/blog_template/","permalink":"https://www.moerjielovecookie.icu/2025/01/19/template/blog_template/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"ZYNQ","date":"2025-01-19T13:49:54.376Z","updated":"2025-01-20T09:41:11.584Z","comments":true,"path":"2025/01/19/ZYNQ/","permalink":"https://www.moerjielovecookie.icu/2025/01/19/ZYNQ/","excerpt":"","text":"ZYNQ 体系结构Zynq 的总体架构包含两个部分：PS（处理器系统）和 PL（可编程逻辑）。这两部分的供电电路上相互独立的，因此 PS 和 PL 可以单独使用，不被使用的部分可以断电以降低功耗。不过 Zynq 最有价值的模式上两个组成部分结合起来使用。 PS（处理器系统）作为处理器系统的基础，所有芯片都包含一颗双核的 ARM Cortex- A 9 芯片。这是一颗硬处理器，是芯片上专门且优化过的硅片元件。 除了“硬”处理器，还有另外一种方案，像是 MicroBlaze 这样的“软”处理器，这是由 PL 端端单元组合成的，即和 PL 端的 IP 是等价的。相比之下，“硬”处理器可以获得相对较高的性能，“软”处理器的数量和精确实现是灵活的。 值得一提的是，可以在 zynq 的 PL 端分配一个或多个 MicroBlaze 软处理器，用于和硬核协同工作。比如可以让软核负责协调特定的底层功能和系统之间的配合，将要求不高的任务从硬核上脱离出来，提高整体性能。 Zynq 的 PS 端里面并非只有 ARM 处理器，还有一组相关的处理资源，构成一个应用处理器单元（Application Processing Uint，APU），另外还有扩展外设接口、cache 存储器、存储器接口、互联接口和时钟发生电路。 PL（可编程逻辑）Zynq 中的逻辑部分是基于 Artix 7 和 Kintex 7 的 fpga 组件。 逻辑部分 可配置逻辑块（CLB）—— CLB 是逻辑单元的小规模、普通编组，在 PL 中排列为一个二维阵列，通过可编程互联连接到其他类似的资源。每个 CLB 内都含有两个逻辑片，并紧邻一个开关矩阵。 片（Slice）—— CLB 里的子单元，里面有实现组合和时序逻辑电路的资源。 查找表（Lookup Table，LUT）—— 一个灵活的资源，可以实现 至多 6 个输入的逻辑函数 一小片只读存储器（ROM） 一小片随机访问存储器（RAM） 一个移位寄存器 LUT 可以按需组合形成一个更大的逻辑函数、存储器或移位寄存器。 触发器（Flip-flop，FF）—— 一个实现一位寄存的时序电路，带有复位功能。其中一个用处是实现锁存。 开关矩阵（Switch Matrix）—— 每个 CLB 旁边都有一个开关矩阵，实现灵活的布线功能来连接 CLB 内的单元，或把 CLB 与 PL 内的其他资源连接起来。 进位逻辑（Carry Logic）—— 算术电路需要在相邻的片之间传递信号，这就是通过进位逻辑来实现的。 输入&#x2F;输出块（IOB）—— IOB 实现了 PL 逻辑资源之间的对接，并提供物理设备“焊盘”来连接外部电路。每个 IOB 可以处理一位的输入或输出信号，IOB 一般位于芯片的周边。 特殊资源：DSP 48 E 1 和 BRAM这两个资源都按列排列集成在逻辑阵列中，嵌入在逻辑部分中，而且彼此靠近，原因是密集计算和给内存中存储数据往往是紧密联系的运算。 BRAMZynq-7000 的 BRAM 和其他 Xilinx 7 系列 FPGA 里的 BRAM 是相同的，都可以实现 RAM、ROM、FIFO，同时还支持纠错编码。 每个 BRAM 里最多可以存储 36 KB 的信息，可以被配置为一个 36 KB 的 RAM 或者两个独立的 18 KB 的 RAM。还可以被“重塑”来包含更多的更小的单元，或者组合起来组成更大容量大 RAM。 使用 BRAM 意味着能在芯片内部优化的专用存储单元内，用很小的物理空间存储大量的数据。另一种方法是分布式 RAM（Distributed RAM），DRAM 是用逻辑部分里的 LUT 来搭建的，想要构成和 BRAM 大小相当的的存储器，需要用到大量的 LUT，而且实现的结果还受到剧增的逻辑和布线延迟所造成的时序性能受限的影响。另一方面，用 DRAM 实现小存储器是有优势的，这样资源利用率高，并且布局更灵活。BRAM 往往能工作在芯片支持的最高时钟频率下。 DSP 48 E 1逻辑部分的 LUT 可以用来实现任意长度的算术运算，但由于长字长的算术电路会在逻辑片内占据较大的空间，这样的布局和布线会导致时钟频率是次优的，因此最好拿 LUT 做短字长的运算。 DSP 48 E 1 是专门用于实现对长字长信号的高速算术运算的逻辑片，是专用的硅片资源，并且在逻辑单元内部包含了预加法器&#x2F;减法器、乘法器和后加法器&#x2F;减法器。 后加法器还可以用作逻辑单元，此时它可以做逻辑运算，支持所有的基础布尔运算。 如果需要更大字长的运算，可以将多个 DSP 组合起来做扩展。 通用输入&#x2F;输出Zynq 上的通用输入&#x2F;输出功能合起来被成为 SelectIO 资源，它们被组成 50 个 IOB 一组，每个 IOB 都有一个焊盘，与外部世界连接。 I&#x2F;O 组分为高性能（High Preformance，HP）或高范围（High Range，HR）。HP 接口的电压最高为 1.8 V，通常用作连接存储器和其他芯片的高速接口；HR 接口允许 3.3 V 的电压，适合做各种 IO 标准的连接。两种接口都支持单端和差分信号。 每个 IOB 还包含一个 IOSERDES 资源，可以做并行和串行的可编程转换，数据位宽是 2～8 位。 通信接口Zynq 内部含有嵌入在逻辑部分里的 GTX 收发器和高速通信接口块。 其他可编程逻辑扩展接口 ADC—— XADC，具有两个独立的 12 位 ADC，每个采样率为 1 Msps。 时钟—— PL 接收来自 PS 的四个独立的时钟输入，另外还能产生和分发它自己的与 PS 无关的时钟。 JTAG 调试接口 PS 与 PL 之间的接口如前所述，Zynq 的表现不仅仅依赖于它的两个组成部分 PS 和 PL 的特性，还在于能把两者协同起来形成完整、集成的系统的能力。这其中起关键作用的，是一组高度定制的 AXI 互联和接口用来在两个部分之间形成桥梁。另外，在 PS 和 PL 之间还有一些其他类型的连接，特别是 EMIO。 AXI高级可扩展接口（Advanced eXtensible Interface）。当前版本为第四代 AXI 4 。 AXI 4用于存储映射连接，支持最高的性能，通过一簇高达 256 个数据字的传输来给定一个地址。 AXI 4-Lite简化的连接，只支持每次传输一个数据。AXI 4 Lite 也是存储映射的，每次传输一个地址和单个数据。 AXI 4-Stream用于高速流式数据，支持批量传输无线大小的数据。没有地址机制，适合源与目的之间的直接数据流。 EMIO 接口EMIO 涉及两个域之间的传输，是由一组简单的导线连接实现的。 EBAZ 4205 矿板资料汇总扩展版ebaz4205拓展板 - 立创开源硬件平台 (oshwhub.com) 开发板补全从零开始的ZYNQ学习（基于矿卡EBAZ4205）（一）-CSDN博客 原理图相关矿板原理图 Elrori&#x2F;EBAZ4205: EBAZ4205 BOARD (github.com) PCB EBAZ4205-master.zip bookmark","categories":[],"tags":[]},{"title":"多速率信号处理-CIC滤波器","slug":"多速率信号处理-CIC滤波器","date":"2025-01-19T13:49:54.303Z","updated":"2025-01-20T03:51:30.826Z","comments":true,"path":"2025/01/19/多速率信号处理-CIC滤波器/","permalink":"https://www.moerjielovecookie.icu/2025/01/19/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-CIC%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"","text":"基本原理级联积分梳状滤波器（Cascade Intergrator Comb）是多速率信号处理中一种十分高效的数字滤波器。CIC滤波器具有低通滤波器的特性，同时具有以下优势： 滤波器系数全为1，设计时不需要存储滤波器系数，节省存储单元，同时使得滤波时只需要加法器和累加器，不需要乘法器 结构规则，可灵活设置插值因子而不影响整体结构 积分器积分器结构为 时域上可表示为 频域上可表示为 可得积分器的幅度谱为 从公式可以得出积分器只有极点，为整数而无零点，且对直流信号具有无限大的增益。 梳状滤波器时域上可表示为 其中 R 是插值因子或抽取因子 M 是微分时延 频域上可表示为 幅度谱为 可知梳状滤波器只有零点，没有极点 若R=8、M=1，则结构为 由此可知单级CIC滤波器的幅度谱为 当时，即时可以确定零点 当，即时，可得此时的幅频响应为 从而实现了零极点相消 单级CIC滤波器在时，所以主瓣区间为，其余都为旁瓣，第一旁瓣电平为 因此旁瓣抑制为 当时，旁瓣抑制为 单级CIC滤波器的阻带衰减为 带内容差（通带波纹）为 其中b为带宽比例因子 单级CIC滤波器的旁瓣电平较高，可通过多级CIC级联改善。 对于N级CIC级联滤波器，旁瓣抑制、阻带衰减、带内容差可表示为 增大CIC滤波器阶数的话，可以增加旁瓣抑制和阻带衰减，但是会导致带内容差变大。因此考虑到通带性能，通常选择。在N不变的情况下，带宽比例因子b越小，CIC滤波器的通带和阻带特性也越好，因此CIC一般位于插值系统的最后一级（输入速率最高） 位增长问题由多级滤波器的幅频响应可知，当时 由此可知多级CIC滤波器可以引起的幅度增益的最大值为 假设输入的数据为有符号数，位宽为，取值范围为，则输出的最大值为 因此输出的最大位宽为 在FPGA设计时，要合理地设置输出信号的位宽，防止数据的溢出，为了节省资源，也可以在每一级适当的进行截位 Matlab设计CIC补偿滤波器由于CIC滤波器通带内不平坦，因此需要在前级加入CIC补偿滤波器。Matlab中的对应函数为**fdesign.ciccomp，**语法如下 1234d = fdesign.ciccompd = fdesign.ciccomp(d,nsections,rcic)d = fdesign.ciccomp(...,spec)h = fdesign.ciccomp(...,spec,specvalue1,specvalue2,...) 其中梳状滤波器的延时长度为d，滤波器阶数为nsections，CIC速率转化因子为rcic。 example1234h = fdesign.ciccomp;set(h,NumberOfSections=5,DifferentialDelay=1);cicComp = design(h,'equiripple',SystemObject=true);filterAnalyzer(cicComp)","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"运放选型","slug":"运放选型","date":"2025-01-19T13:49:54.280Z","updated":"2025-01-20T02:51:27.287Z","comments":true,"path":"2025/01/19/运放选型/","permalink":"https://www.moerjielovecookie.icu/2025/01/19/%E8%BF%90%E6%94%BE%E9%80%89%E5%9E%8B/","excerpt":"","text":"在使用OP07设计单路运放时，设计目标为将100K到1M的1V峰峰值的正弦波放大2倍，但是测试过程中发现100K频率下输出的波形类似三角波，数据手册说OP07的增益带宽积为0.5MHz，正常来说100K的频率下2倍增益是没问题的。 但是数据手册又说OP07的压摆率Slew Rate为0.3V&#x2F;us，那么根据设计目标可以计算得出运放的压摆率至少要到6.28V&#x2F;us，可以看到OP07的压摆率完全不够，因此波形会失真。 当使用正负5V供电时，AD8051的压摆率最小值在105V&#x2F;us，，因此可以满足设计要求。","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"阻塞赋值和非阻塞赋值","slug":"阻塞赋值和非阻塞赋值","date":"2025-01-19T13:11:17.810Z","updated":"2025-01-21T07:12:57.886Z","comments":true,"path":"2025/01/19/阻塞赋值和非阻塞赋值/","permalink":"https://www.moerjielovecookie.icu/2025/01/19/%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC/","excerpt":"","text":"阻塞和非阻塞的区别阻塞赋值“&#x3D;”必须是阻塞赋值完成后，才进行下一条语句的执行；赋值一旦完成，等号左边的变量值立即变化。在同一个块中，阻塞赋值表达式的书写顺序会影响赋值的结果。硬件没有对应的电路。 即串行赋值，语句从上到下顺序执行，立即生效 非阻塞赋值“&lt;&#x3D;”在赋值开始时计算表达式右边的值，在本次仿真周期时钟的下降沿时才更新被赋值变量，即赋值不是立即生效的；非阻塞赋值允许块中其他语句同时执行。在同一个块中，非阻塞赋值表达式的书写顺序不影响赋值的结果。硬件有对应的电路。 并行执行，不是立即生效，语句同时执行 总结阻塞赋值对应的硬件电路与时钟触发沿没有关系，只和输入的电平变化有关；阻塞赋值对应触发器，只有触发沿才会发生赋值。 时序电路建模时，用非阻塞赋值 锁存器建模时，用非阻塞赋值 在 always 块中建立组合逻辑时，用阻塞赋值 在同一个 always 块中建立时序和组合逻辑时，用非阻塞 在同一个 always 块中不能既用阻塞又用非阻塞 不要在一个以上的always块中为同一个变量赋值 赋值时不能延时","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"Testbench仿真脚本编写指北","slug":"Testbench仿真脚本编写指北","date":"2025-01-19T13:11:17.795Z","updated":"2025-01-20T02:38:40.272Z","comments":true,"path":"2025/01/19/Testbench仿真脚本编写指北/","permalink":"https://www.moerjielovecookie.icu/2025/01/19/Testbench%E4%BB%BF%E7%9C%9F%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%8C%87%E5%8C%97/","excerpt":"","text":"[!note]由于 Quartus 的 VWF 仿真只能仿真很短的时间，而且 Vivado 仿真的时候也需要添加激励信号，因此需要编写 testbench 文件进行激励仿真。 Testbench 文件结构编写 testbench 的目的是为了测试 module 的功能、性能是否符合设计的预期。验证设计的功能包括以下步骤： 产生合适的激励波形：该激励通常要覆盖被测 HDL 模块所有可能产生的输入状态； 将产生的激励信号加入到 DUT 中并观察其响应：即将 DUT 模块例化的 Testbench 中，运行仿真测试； 将输出的响应与期望值比较。Testbench 的结构一般模块如下：&#96;&#96; 12345678module Test_bench_name();// 01:信号或变量声明定义// --逻辑设计中输入对应 reg 型// --逻辑设计中输出对应 wire 型// 02:使用 ini[ti](https://bbs.elecfans.com/group_715)al 或 always 语句产生激励// 03:例化待测试DUT模块// 04:监控和比较输出响应endmodule 代码示例时钟激励输入示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*----------------------------------------------------------------时钟激励产生方法一：50%占空比时钟----------------------------------------------------------------*/parameter ClockPeriod=10; //参数化时钟周期initial begin clk_i=0; forever#(ClockPeriod/2) clk_i = ~clk_i;end/*----------------------------------------------------------------时钟激励产生方法二：50%占空比时钟----------------------------------------------------------------*/initialbegin clk_i=0;endalways #(ClockPeriod/2) clk_i=~clk_i;/*----------------------------------------------------------------时钟激励产生方法三：产生固定数量的时钟脉冲----------------------------------------------------------------*/parameter ClockPeriod=10; //参数化时钟周期initialbegin clk_i=0; repeat(6) #(ClockPeriod/2) clk_i=~clk_i;end/*----------------------------------------------------------------时钟激励产生方法四：产生非占空比为 50%的时钟----------------------------------------------------------------*/parameter ClockPeriod=10; //参数化时钟周期initialbeginclk_i=0;forever begin #((ClockPeriod/2)-2) clk_i=0; #((ClockPeriod/2)+2) clk_i=1; endend 复位激励输入示例12345678910111213141516171819202122232425262728293031323334353637/*---------------------------------------------------------------- 复位信号产生方法一：异步复位----------------------------------------------------------------*/initialbegin [rs](https://www.elecfans.com/tags/rs/)t_n_i=1; #100; rst_n_i=0; #100; rst_n_i=1; end/*---------------------------------------------------------------- 复位信号产生方法二：同步复位----------------------------------------------------------------*/initialbegin rst_n_i=1; clk_i = 0; @（negedge clk_i) rst_n_i=0; #100; //固定时间复位 repeat(10) @（negedge clk_i); //固定周期数复位 @（negedge clk_i) rst_n_i=1; endalways #5 clk_i=~clk_i;/*---------------------------------------------------------------- 复位信号产生方法三：复位任务封装----------------------------------------------------------------*/task reset;input [31:0] reset_time; //复位时间可调，输入复位时间 RST_ING=0; //复位方式可调，低电平或高电平 begin rst_n=RST_ING; //复位中 #reset_time; //复位时间 rst_n_i=~RST_ING; //撤销复位，复位结束 endendtask 仿真控制语句和系统任务描述&#96;&#96; 1234567891011121314/*---------------------------------------------------------------- 仿真控制语句及系统任务描述----------------------------------------------------------------*/$stop // 停止运行仿真，modelsim 中可继续仿真$stop(n) //带参数系统任务，根据参数 0,1或2不同，输出仿真信息$finish //结束运行仿真，不可继续仿真$finish(n) //带参数系统任务，根据参数 0,1或2不同，输出仿真信息//0:不输出任何信息//1:输出当前仿真时刻和位置//2:输出当前仿真时刻、位置和仿真过程中用到的 memory 以及 CPU 时间的统计$random //产生随机数$random % n //产生范围-n 到 n 之间的随机数&#123;$random&#125; % n //产生范围 0 到 n 之间的随机数/*---------------------------------------------------------------- 文本读取12345678910/*---------------------------------------------------------------- 文本输入方式：$readmemb/$readmemh----------------------------------------------------------------*/$readmemb/$readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;);$readmemb/$readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;,&lt;起始地址&gt;);$readmemb/$readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;,&lt;起始地址&gt;,&lt;结束地址&gt;);$readmemb:/*读取二进制数据，读取文件内容只能包含：空白位置，注释行，二进制数数据中不能包含位宽说明和格式说明，每个数字必须是二进制数字。*/$readmemh:/*读取十六进制数据，读取文件内容只能包含：空白位置，注释行，十六进制数数据中不能包含位宽说明和格式说明，每个数字必须是十六进制数字。*/","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"Vitis开发过程中遇到的错误","slug":"Vitis开发过程中遇到的错误","date":"2025-01-14T16:00:00.000Z","updated":"2025-01-20T02:38:28.110Z","comments":true,"path":"2025/01/15/Vitis开发过程中遇到的错误/","permalink":"https://www.moerjielovecookie.icu/2025/01/15/Vitis%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"","text":"Error while launching program: Memory write error at 0 x 105000. MMU section translation fault没找到具体原因。先生成 boot. Bin 文件烧录到内存卡后再启动 zynq 就不会出现这个报错。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"}]},{"title":"FIR滤波器的架构","slug":"FIR滤波器的架构","date":"2024-12-28T16:00:00.000Z","updated":"2025-02-05T06:45:04.606Z","comments":true,"path":"2024/12/29/FIR滤波器的架构/","permalink":"https://www.moerjielovecookie.icu/2024/12/29/FIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E6%9E%B6%E6%9E%84/","excerpt":"","text":"数学基础有限脉冲响应滤波器，其突出特点为单位取样响应 是一个 N 点长的有限序列，滤波器的输出 表示为输入序列 和 的线性卷积系统函数为由此可见 FIR 只在原点上存在极点，具有全局稳定性不同阶数的 FIR 滤波器特性 单位取样响应特征 滤波器种类 系数偶对称，阶数为偶数 适合各种滤波器 系数偶对称，阶数为奇数 不适合高通和带阻滤波器 系数奇对称，阶数为偶数 只适合带通滤波器 系数奇对称，阶数为奇数 适合高通和带通滤波器 系数量化将一组数据先进行归一化处理，再乘上一个整数因子，最后进行四舍五入截尾处理即可 1h = round(h/max(abs(h))*(2^N-1)) //N为量化位数 Fully Parallel Systolic Architecture（全并行脉动结构）全并行脉动滤波器对对称系数、反对称系数和零值系数进行了优化。滤波器的时延受到滤波器系数的对称性影响。当对称系数绝对相等时，它们共享同一个 DSP block。这种配对共享允许在实现的过程中使用 Xilinx 和 Altera 的 dsp block 中的 pre-adder。对称的滤波器如果不适用对称系数优化架构的话，结构如下图的上半部分，优化后为下半部分： Fully Parallel Transposed Architecture（全并行转置结构）Fully Parallel Transposed Architecture 通过为任意的绝对相等的系数共享乘法器，同时移除零值系数所需的乘法器。此结构的滤波器时延为固定的 6 个 clk。下图的上半部分是没有优化的部分对称滤波器，下半部分为优化后的结构： Partly Serial Systolic Architecture (1 &lt; N &lt; L)其中 N 为延时长度，L 为滤波器阶数。部分串行滤波器需要 M=ceil(L/N) 个脉动单元，结构如下：滤波器的时延为 M+ceil(L/M)+5。如果一个乘法器对应的查找表里面的系数为 0 或者 2 的幂次，则实现过程不包含乘法器，通过移位来实现幂次的变化。 Fully Serial Systolic Architecture (N ≥ L)如果延时的长度大于滤波器的阶数，此时滤波器为全串行结构。滤波器延时为 。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"Quartus报错记录","slug":"Quartus报错记录","date":"2024-12-27T16:00:00.000Z","updated":"2025-01-20T02:39:01.050Z","comments":true,"path":"2024/12/28/Quartus报错记录/","permalink":"https://www.moerjielovecookie.icu/2024/12/28/Quartus%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Error (176310): Can’t place multiple pins assigned to pin location Pin_F 16 (IOPAD_X 34_Y 18_N 21)报错如下可以看到 Pin_F 16 既被用于 DAC_DATA，又被用于 nCEO 引脚，因此才会报错不能将多个引脚赋到 Pin_F 16 上。 Solution将nCEO 的 value 设置为 Use as regual I&#x2F;O 即可解决问题。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"git学习","slug":"git学习","date":"2024-12-10T16:00:00.000Z","updated":"2025-01-19T14:18:45.913Z","comments":true,"path":"2024/12/11/git学习/","permalink":"https://www.moerjielovecookie.icu/2024/12/11/git%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Git 基础概念Git 概念汇总 概念 描述 工作区（Workspace） 在本地的代码库，新增和修改的文件会提交到暂存区 暂存区（stage） 用于临时存放文件的修改，实际上是一个文件（. Git&#x2F;index），保存待提交的文件列表 仓库（repository） Git 的管理仓库，记录文件状态的地方，所有的代码版本都在里面 远程仓库（origin&#x2F;remote） 专用的 git 服务器，为多人提供共享服务。本地的仓库通过 &#x3D;&#x3D;push&#x3D;&#x3D;命令将代码推送到远程仓库里 本地仓库 本地电脑内直接使用的版本库 分支（Branch） 分支是从主线分离出的副本，可以独立操作而不干扰主线，仓库初始化后会有一个默认主分支“master”或“main” 头（HEAD） HEAD 类似指针，指向当前活动分支的最新版本 提交（Commit） 将 stage 中的所有变更提交到当前仓库的活动分支 推送（Push） 将本地仓库的版本推送到远程仓库 拉取（Pull） 从远程仓库获取更新到本地仓库 获取（Fetch） 从远程仓库更新，作用同 pull，但是不会自动合并 冲突（Conflict） 多人对同一个文件进行修改后在远程仓库合并时会面临冲突，需要人工合并处理 合并（Merge） 对有 conflict 的文件进行合并操作，git 可以自动合并变更内容，无法自动处理的文件需要人工处理 标签（Tag） 标签指的是某个分支某个特定时间点的状态，可以理解为提交记录的别名，常用来标记版本。 main&#x2F;master 仓库的默认主分支 origin&#x2F;main 表示远程仓库的 main 分支 工作区&#x2F;暂存区&#x2F;仓库 图中的 objects 标识的区域为 git 的对象库，实际的位置是“. Git&#x2F;objects”目录中，里面包含了创建的各种对象和内容 当对工作区的修改&#x2F;新增文件执行 git add命令后，暂存区的目录树被更新，同时工作区修改&#x2F;新增文件的内容被写入 objects 的一个新的对象中，而该对象的 ID 被记录在 stage 的文件索引中 当执行 git commit时，stage 的目录树写入 objects 中，main 分支做出更新 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 git rm –cached “file” 命令时，会直接从暂存区删除文件，工作区则不做出改变 工作区本地计算机内的项目文件 暂存区（stage）暂存区是一个临时存储区域，包含即将提交到版本库中的文件快照常用命令 123git add filename # 将单个文件添加到暂存区git add . # 将工作区中的所有修改添加到暂存区git status # 查看哪些文件在暂存区中 版本库（Repository）版本库包含项目的所有版本历史记录，每次提交都会在版本库中创建一个新的快照，这些快照不可变，确保了项目的完整历史记录常用命令 1234git commit -m &quot;Commit message&quot; # 将暂存区的更改提交到本地版本库git log # 查看提交历史git diff # 查看工作区和暂存区之间的差异git diff --cached # 查看暂存区和最后一次提交之间的差异 三者之间的关系 工作区-&gt;暂存区 1git add 暂存区-&gt;版本库 1git commit -m &quot;Commit message&quot; 版本库-&gt;远程仓库 1git push origin branch-name 远程仓库-&gt;本地版本库 1234git pull origin branch-name# 或者git fetch origin branch-namegit merge origin/branch-name Git 工作流程 1、克隆仓库如果你要参与一个已有的项目，首先需要将远程仓库克隆到本地： 12git clone https://github.com/username/repo.gitcd repo 2、创建新分支为了避免直接在 main 或 master 分支上进行开发，通常会创建一个新的分支： 1git checkout -b new-feature 3、工作目录在工作目录中进行代码编辑、添加新文件或删除不需要的文件。 4、暂存文件将修改过的文件添加到暂存区，以便进行下一步的提交操作： 1git add filename 或者添加所有修改的文件 1git add . 5、提交更改将暂存区的更改提交到本地仓库，并添加提交信息： 1git commit -m &quot;Add new feature&quot; 连接远程仓库 1git remote add origin [git@github.com] 6、拉取最新更改在推送本地更改之前，最好从远程仓库拉取最新的更改，以避免冲突： 1git pull origin main 或者如果在新的分支上工作 1git pull origin new-feature 7、推送更改将本地的提交推送到远程仓库： 1git push origin new-feature 8、删除分支如果不再需要新功能分支，可以将其删除： 1git branch -d new-feature 或者从远程仓库删除分支： 1git push origin --delete new-feature Git 指令 Git 分支Git 仓库在 fork 中打开后界面如下：可以看到每一个分支相互平行，只有完成某些项目的开发时才会合并到主分支。那么分支有什么用呢？当计划开发一个新的功能时，第一天完成了百分之 50，如果直接提交到 master 分支，则可能导致别人无法开发，如果全部写完再提交的话又可能因为意外丢失之前的进度。此时就体现出来分支的优越性了。我们可能创建一个属于自己的别人不可见的分支，在这个分支上开发提交代码不会影响他人，可以随意操作，等到开发结束了再一次性合并到 master 分支。 Git 分支常用命令12345678910111213141516171819git branch # 列出所有本地分支git branch -r #列出所有远程分支git branch -a #列出所有本地和远程的分支git branch [new-branch-name] #创建一个新的分支，但停留在当前分支git checkout -b [new-branch-name] #创建一个新的分支，并切换到该分支git branch --track [branch] [remote-branch] #创建一个新分支，并与指定的远程分支建立追踪关系git checkout [new-branch-name] #切换到指定分支，并更新工作区git merge [branch] #合并指定分支到当前分支git branch -d [branch] #删除分支git push origin --delete [branch] #删除远程分支","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"}]},{"title":"脉冲成形滤波器","slug":"脉冲成形滤波器","date":"2024-11-20T16:00:00.000Z","updated":"2025-01-20T02:51:56.956Z","comments":true,"path":"2024/11/21/脉冲成形滤波器/","permalink":"https://www.moerjielovecookie.icu/2024/11/21/%E8%84%89%E5%86%B2%E6%88%90%E5%BD%A2%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"","text":"数字信号要想在信道中传输，必须在发射机的基带部分进行脉冲成型，将数字信号转化为脉冲信号；脉冲信号到达接收机后，在基带部分进行采样判决后恢复出数字信号。 脉冲成形矩形脉冲最容易实现的脉冲波形就是矩形脉冲，以数字信号“00010110”为例，在发射端可以将“0”映射为正脉冲，“1”映射为负脉冲。在接受端采样时刻的信号电平为正电平则为“0”，信号电平为负电平则为“1”。但是矩形脉冲信号的频谱为无限宽，所以在带宽有限的信道传输时会发生失真，甚至可能导致采样判决失真，无法恢复出数字信号。 Sinc 脉冲Sinc 脉冲信号有两个优点： Sinc 信号的频谱带宽是有限的，经过带宽有限的信道进行传输时不会出现失真。 一个码元达到最大幅值时其他码元的幅值刚好为 0，码元之间不会相互影响，实现无码间串扰。以数字信号 00010110 为例，0 映射为正脉冲，1 映射为负脉冲。发射端经过脉冲成形后的波形如下：接收端的采样判决如下： 基带滤波器理想低通滤波器如果要脉冲成形为 sinc 波形，只要将单位冲激信号输入理想 LPF 即可得到 sinc 脉冲信号。如果 LPF 的带宽为 B，则输出的 sinc 脉冲信号波形如下：只要 sinc 脉冲信号发送间隔设为 $\\frac{1}{B}$，也就是码元传输速率 $R_B&#x3D;2B$，就可以实现无码间串扰。 升余弦滚降滤波器采用理想低通滤波器对单位冲激信号进行滤波得到的 sinc 脉冲信号，拖尾振荡幅度比较大、衰减速度比较慢，当定时出现偏差时，码间串扰会比较大。考虑到实际的系统总是存在一定的定时误差，所以脉冲成形一般不采用理想低通滤波器，而是采用升余弦滚降滤波器，这种滤波器拖尾振幅小、衰减快，对于减小码间串扰和降低对定时的要求都有利。升余弦滚降滤波器的频率响应为：$$\\begin{aligned}&amp;\\mathrm{H}(f)&#x3D;\\begin{cases}\\frac{1}{2B},&amp;0\\leqslant\\left|f\\right|&lt;\\left(1-\\alpha\\right)B\\\\frac{1}{4B}\\left{1+\\cos\\frac{\\pi}{2B\\alpha}\\Big[\\left|f\\right|-B\\left(1-\\alpha\\right)\\right]\\Big},&amp;(1-\\alpha)B\\leqslant|f|&lt;(1+\\alpha)B\\0,&amp;\\left|f\\right|\\geqslant\\left(1+\\alpha\\right)B \\\\end{cases}\\end{aligned}$$其中，$B&#x3D;\\frac{R_B}{2}$升余弦滚降滤波器的频率响应曲线如下：升余弦滚降滤波器的单位冲激响应为：$$\\mathrm h(t)&#x3D;\\mathscr{F}^{-1}\\big[\\mathrm H(f)\\big]&#x3D;\\mathrm sinc\\big(2Bt\\big)\\frac{\\cos\\big(2\\pi\\alpha Bt\\big)}{1-\\big(4\\alpha Bt\\big)^2}$$其中 $\\alpha$ 是升余弦滚降滤波器的一个很重要的参数，称为滚降系数。当 $\\alpha&#x3D;0$ 时，升余弦滚降滤波器就是一个带宽为 B 的理想低通滤波器。当 $\\alpha&#x3D;0.5$ 时，升余弦滚降滤波器的频率响应和单位冲激响应如下：此时滤波器的带宽为 $（1+\\alpha）B&#x3D;1.5B$。当 $\\alpha&#x3D;1$ 时，升余弦滚降滤波器的频率响应和单位冲激响应如下：此时滤波器带宽为 $（1+\\alpha）B&#x3D;2B$。在使用升余弦滚降滤波器进行脉冲成形时，要想实现无码间串扰，则脉冲信号之间的时间间隔必须为 $\\frac{1}{2B}$，即码元速率为 $R_B&#x3D;2B$。由于升余弦滚降滤波器会展宽带宽，因此在给定码元速率 $R_B$ 的情况下，基带信号的频谱带宽为 $(1+\\alpha)\\times \\frac{R_B}{2}$。 眼图眼图可以用来评估一个系统的码间串扰情况。","categories":[],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"FPGA中的电平标准","slug":"FPGA中的电平标准","date":"2024-11-15T16:00:00.000Z","updated":"2025-01-20T02:45:22.510Z","comments":true,"path":"2024/11/16/FPGA中的电平标准/","permalink":"https://www.moerjielovecookie.icu/2024/11/16/FPGA%E4%B8%AD%E7%9A%84%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/","excerpt":"","text":"FPGA 在与外界进行信息交换时，为了确保信息的正确性，发送和接收信息都要对信息有认定的标准。在数字电路中，我们常用电压高低来表示“0”和“1”，那么多高的电压才会被当作“1”呢，这个时候就需要一个标准，这个标准就是电平标准。 常见电平标准 TTLTTL (Transistor - Transistor Logic，三极管 - 三极管逻辑电平) 是电平标准中的元老级成员。在早期的数字电路中有广泛的应用，但是它有一些缺点，比如高电平的判决门限和供电电压之间的电压空间较大，容易造成信号的不稳定性；而且 5 V 的电压过于耗电。 LVTTLLVTTL（Low Voltage Transistor - Transistor Logic，低压 TTL 电平标准）改进了 TTL 的缺点，将供电电压改为了 $3.3V$，功耗也相应降低了，而且提升了信号稳定性。 CMOSCMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体电平）的特点是功耗较低，可以根据电路的工作状态自动调整功耗。 LVCMOSLVCMOS（Low Voltage Complementary Metal Oxide Semiconductor，低压 CMOS 电平标准）在 CMOS 的基础上进一步降低供电电压，降低功耗。LVCMOS 在低功耗、中低速数字电路中非常受欢迎。 LVDSLVDS，全称是Low Voltage Differential Signaling，是一种利用低压差分信号传输高速信号的电平标准，有低压，低功耗，噪声抑制能力强的特点。LVDS 的输出电压摆幅极小，只有 $\\pm 350mV$，电流只有 $3.5mA$ 左右。由于其超低功耗和超快数据传输速率，常用于高速数据传输。","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"电路中的电平标准","slug":"电路中的电平标准","date":"2024-11-15T16:00:00.000Z","updated":"2025-01-19T14:14:22.371Z","comments":true,"path":"2024/11/16/电路中的电平标准/","permalink":"https://www.moerjielovecookie.icu/2024/11/16/%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/","excerpt":"","text":"FPGA 在与外界进行信息交换时，为了确保信息的正确性，发送和接收信息都要对信息有认定的标准。在数字电路中，我们常用电压高低来表示“0”和“1”，那么多高的电压才会被当作“1”呢，这个时候就需要一个标准，这个标准就是电平标准。 常见电平标准 TTLTTL (Transistor - Transistor Logic，三极管 - 三极管逻辑电平) 是电平标准中的元老级成员。在早期的数字电路中有广泛的应用，但是它有一些缺点，比如高电平的判决门限和供电电压之间的电压空间较大，容易造成信号的不稳定性；而且 5 V 的电压过于耗电。 LVTTLLVTTL（Low Voltage Transistor - Transistor Logic，低压 TTL 电平标准）改进了 TTL 的缺点，将供电电压改为了 $3.3V$，功耗也相应降低了，而且提升了信号稳定性。 CMOSCMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体电平）的特点是功耗较低，可以根据电路的工作状态自动调整功耗。 LVCMOSLVCMOS（Low Voltage Complementary Metal Oxide Semiconductor，低压 CMOS 电平标准）在 CMOS 的基础上进一步降低供电电压，降低功耗。LVCMOS 在低功耗、中低速数字电路中非常受欢迎。 LVDSLVDS，全称是Low Voltage Differential Signaling，是一种利用低压差分信号传输高速信号的电平标准，有低压，低功耗，噪声抑制能力强的特点。LVDS 的输出电压摆幅极小，只有 $\\pm 350mV$，电流只有 $3.5mA$ 左右。由于其超低功耗和超快数据传输速率，常用于高速数据传输。","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"Matlab R2024b安装本地文档","slug":"Matlab R2024b安装本地文档","date":"2024-10-27T16:00:00.000Z","updated":"2025-01-20T02:44:42.787Z","comments":true,"path":"2024/10/28/Matlab R2024b安装本地文档/","permalink":"https://www.moerjielovecookie.icu/2024/10/28/Matlab%20R2024b%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0%E6%96%87%E6%A1%A3/","excerpt":"","text":"安装包 通过网盘分享的文件：MATLAB R2024b链接: https://pan.baidu.com/s/1T8-V_guBJhSD-Yze0wEVmQ?pwd&#x3D;9h5c 提取码: 9h5c–来自百度网盘超级会员v2的分享 挂载后导航到镜像中的安装包文件夹1cd &lt;mountedDocImage&gt;/bin/&lt;arch&gt; &lt;mountedDocImage&gt; 是装载的文档 ISO 或 DMG 镜像的根目录。 &lt;arch&gt; 是 ISO 或 DMG 镜像的操作系统架构文件夹，例如 win64、glnxa64、maci64 或 maca64 使用mpm install-doc命令运行文档安装程序为了将文档安装到指定的位置，要使用**—destination命令，用—source**命令指定安装程序文件路径 12.\\mpm install-doc --matlabroot=&lt;matlabrootfolder&gt; --source=&lt;docinstallfolder&gt; --destination=&lt;destinationfolder&gt; 配置MATLAB 预设项中，将帮助中的文档位置选为本地 在userpath中创建startup.m文件，使用docroot命令 指定帮助文档的路径 验证本地安装验证文档是否在本地打开。在 MATLAB 命令提示符下，输入：doc 在打开的浏览器页面中，检查 URL 的地址。 如果 URL 指向本地 IP 地址和端口号（例如 http://127.0.0.1:12345），则 MATLAB 访问的是本地安装的文档。 如果 URL 指向 Web 地址（例如 https://www.mathworks.com/help/...），则 MATLAB 访问的仍然是 Web 文档。更新 MATLAB 以指向本地安装的文档，如配置 MATLAB 以使用安装的文档中所述。 $$ $$","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"DVB-S系统设计报告","slug":"DVB-S系统设计报告","date":"2024-10-19T16:00:00.000Z","updated":"2025-01-26T12:01:43.158Z","comments":true,"path":"2024/10/20/DVB-S系统设计报告/","permalink":"https://www.moerjielovecookie.icu/2024/10/20/DVB-S%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/","excerpt":"","text":"DVB标准Digital Video Broadcasting（数字视频广播）是一个完整的数字电视解决方案，其中包括DVB-C（数字电视有线传输标准），DVB-T（数字电视地面传输标准），DVB-S（数字电视卫星传输标准），下面主要介绍DVB-S系统。 DVB-S为数字卫星广播标准，卫星传输具有覆盖面广、节目容量大等优点。信号采用RS(188，204)和卷积码的级联编码，调制方式为QPSK。 DVB-S信道编码及调制的基本原理原理框图根据ETSI的DVB-S标准，原理框图如下所示 由于卫星提供的DTH服务特别受功率限制的影响，因此主要的设计目的应该为抗噪声和干扰，而不是频谱效率。为了在不过度损害频谱效率的前提下实现很高的能量效率，系统应使用QPSK调制和卷积码和RS码的级联。 接口 信道编码TS流适配单元（adaptation）输入的TS流根据MPEG-2格式按照固定的长度打包，数据包的长度为188，帧头为同步字 。DVB-S标准中要求每8个TS数据包组成一个超帧，将超帧中的8个同步头进行反转，变为，其余的同步头不变。同时还要自动插入空包，在数据包后插入16个0，将长度为188的数据包包补充成长度为204的数据包，与后续的信道编码模块建立时钟匹配和接口连接。 扰码单元（energy dispersal）基带信号中含有很多连“1”或者连“0”的现象，会导致基带信号的频谱中含有较多的低频成分，既不利于信号在信道的传输，也不利于在接收端提取时钟信号。因此采用扰码，将TS流转化成伪随机序列。DVB-S标准中的随机化的原理图如下： 伪随机二进制序列的生成多项式如下： 扰码以8个数据包组成的超帧为单位进行处理，在每一个单元开始处理时，将序列”100101010000000“装入寄存器，对其进行扰码处理。数据包的同步字不进行扰码处理。 RS编码外码采用RS编码，其具有同时纠正随机错误和突发错误的能力，并且纠正突发错误更有效。DVB-S采用的编码格式为RS(239,255)截断而得到的RS(188,204)编码，最大可纠错长度为8个字节，编码从同步字或开始。 编码原理简述假设信息多项式为 码生成多项式为 其中的_a_ = 02_hex_，则生成多项式的展开式为 将除以后，余式为关于x的15次多项式，其16个系数即为生成的16个校验字节，将其添加到188长度的数据包后即可完成RS(188,204)的编码。 卷积交织在数字信号传输过程中，由于一些突发性干扰，会导致一连串的数据错误，很有可能超出RS码的纠错范围。而卷积交织可以将错误的字符分散开，使得信道变成近似无记忆信道。DVB-S中采用的是交织深度为12的卷积交织。交织和解交织的框图如下： 卷积编码内码采用的是(2,1,7)型的卷积码，编码效率为，由6个移位寄存器和2个模二加加法器构成，1个bit信号生成2个bit的编码信号，约束长度为7。 当信道质量较好时可以对编码信号进行删余，提高信道利用率。 Matlab仿真TS流适配及扰码模块 CLKdivide一路高清电视信号的码率为，因此二进制信号的速率为，输入的数据为类型，所以输入的信号速率为。所以CLKdivide模块将的时钟分频到和。 sigSource此模块产生输入的TS流信号，并且生成RS编码的开始、结束和使能信号。由于每输出一个188字节长度的数据包后要暂停输出TS流插入空包，所以采用使能系统，每计数188次后拉低使能插入空包。 HeaderProcess此模块对输入的TS流进行速率转换和组超帧，每八个数据包组合为一个超帧，并反转第一个同步字，由转为，并生成使能sigSource的信号。同时生成扰码模块的控制信号。 第一个Multiport Switch用来进行插入空包，第二个Multiport Switch用来反转超帧的第一个同步字。 myScrambler根据扰码的生成多项式进行设计。HeaderProcess生成的扰码使能信号正好在输入同步字时拉低，不进行扰码处理，扰码复位信号在输入了一个超帧后重新装入初始序列”100101010000000“。 仿真数据 RS编码模块 使用HDL Coder中的模块，由于时钟速率为200 ，因此需要加入一个触发模块，保证RS编码是按照码元速率进行编码 卷积交织 同样加入触发模块，保证交织的速度为码元速率。 uint8转binary模块 首先对输入的数据按位相与，取出每一位的数据后使用Multiport Switch逐位输出，计数器的使能速率为码元速率的8倍。 卷积编码 不进行删余的话，编码效率为。也可以进行删余，可以得到、、、的编码效率。在一定带宽内，编码效率越大传输效率越大，同时纠错能力越差。 Vivado实现Vivado的代码大部分都由HDL Coder生成，或者由Matlab生成系数文件，再导入到Vivado的IP核中。 DataSource_Scrambler直接生成hdl代码的话，DataSource_Scrambler模块中的sigSource模块在200 的频率下建立时间的裕量不满足时序，因此在生成HDL之前进行如下配置： 在输出端加入一级流水线后，综合布线后时序即可通过。同时在这个模块的输出信号处全部加上一个delay模块组成流水线。 扰码模块 可以看到每输入8个数据包后，扰码内部的D触发器的初值得到重置，同时反转后的同步字没有被扰码处理。 数据对齐在仿真过程中，发现同步字和RS编码的使能信号没有对齐，因此添加如下模块： 在将输出的使能信号延后一个数据周期，即可保证信号的同步。 RS编码将modelsim的数据导入到matlab进行解码，可以看到将188个数据包完整的解了出来。 升余弦滚降滤波器Matlab滤波器设计根据DVB-S标准的要求，升余弦滚降系数为，使用Matlab的filterDesigner工具设计滤波器系数。 在FPGA中要对滤波器系数进行定点化处理。 对系数进行32位量化后幅值响应如下： 对系数进行16位量化后幅值响应如下： 可以看出16位量化的幅值响应和32位量化的响应几乎一样，为了节省空间，因此使用16位量化。 量化结束后点击目标→Xilinx系数文件 生成coe文件。 Vivado Fir滤波器设计选择 Source为COE FIle 输入的采样频率要和时钟频率相等，不进行过采样。 在Implementation中将系数类型选择为有符号数，位宽设置为16。 输入的信号为正负1，所以输入的位宽为2，第一位为符号位。输出模式设置为全精度。 波形 使用XDMA进行数据的输入和输出采集 结构框图如上。 工程的总体结构如上所示，数据通过XDMA的M_AXIS_H2C接口写入数据。由于写入数据的位宽为128bit，工程中信号处理部分的输入位宽为8bit，因此加入AXISDataWidthConverter模块将位宽从16BYTE转为1BYTE，并写入FIFO，使用AXIGPIO模块读取FIFO的almost full信号，如果FIFO被写满，almost full被拉高，就停止写入数据。读取DVB-S生成的QPSK信号时，由于经过了升余弦滚降滤波和调制，信号的位宽已经较大，为了降低复杂度选择将调制信号高位补零至128bit后经M_AXIS_C2H接口输出到Host主机。 调试过程见 link_to_page","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"Report","slug":"Report","permalink":"https://www.moerjielovecookie.icu/tags/Report/"},{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"HDL coder使用手册","slug":"HDL coder使用手册","date":"2024-09-20T16:00:00.000Z","updated":"2025-01-19T14:18:34.611Z","comments":true,"path":"2024/09/21/HDL coder使用手册/","permalink":"https://www.moerjielovecookie.icu/2024/09/21/HDL%20coder%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"","text":"💡 由于本科毕设女朋友准备使用FPGA完成，因此写这篇文章帮助她快速上手HDL coder的使用，降低前期入门的难度。 支持生成HDL代码的simulink库 名字中含有HDL的库中的模块一般都可以用来生成HDL代码。直接搜索模块名称，比如搜索fir， 可以看到旁边会显示位于哪个库中，模块有可能位于多个库，只要有一个库的名字里面有HDL，就代表这个模块可以用来生成HDL代码。 一些常用操作创建子系统将库中的模块拖到主界面组合好后，可能会占据很大的空间，如果工程较大，模块越连越多就特别臃肿，因此当我们完成某个功能以后，就可以将这部分的模块全部选中，此时右下角会出现三个点，将鼠标移到上面后会展开，出现很多不同的功能。下图是一个AM调制的过程，可以看到选中所有相关的模块后点击创建子系统，即可得到右图的子系统。刚生成的子系统的命名为subsystem，可以将命名改为更清晰易懂的名字。 观察节点的信号波形当选中某根连线时，同样会出现三个点，鼠标移动到上面后会展开，选择WiFi形状的选项即可记录该连线上的信号。运行仿真后再次点击WiFi图标即可打开逻辑分析仪，即可查看该连线上的信号。 逻辑分析仪内部选中某个信号后即可在波形中调节数制、高度等设置。 也可以使用scope模板看节点信号。 频谱分析使用Spectrum Analyzer模块进行频谱分析。 当样点比较少的时候可以将估计方法改为welch。 信号数据格式显示 可以显示模块输入输出信号的数据类型和小数位数。 采样时间一栏中的时间图例选中以后，会用不同的颜色显示不同采样速率的模块，在多速率系统设计中有很大的用处。 生成HDL代码前期准备设置诊断类型 模型设置中选择诊断&#x2F;采样时间 单任务和多任务数据传输必须设置成错误。 兼容性检测 选择代码生成的目标文件夹，运行兼容性检查器，如果工程没有问题的话会出现如下界面 目标平台选择 根据使用的FPGA选择综合工具和FPGA的系列。 模块设置在要生成代码的子系统上右键，选择HDL模块属性： 可以对流水线、乘法器等参数进行设置 如果生成的代码在EDA工具中编译以后无法满足时序约束，可以加输入和输出的流水线 💡 如果模块的输出对前面的模块有反馈信号的话不能添加流水线，详细见bookmark [bookmark](https://blog.sawenmoerjie.top/article/ec96aebc-b5a5-4059-bbef-02f0003e7a45) 代码生成 点击为子系统生成HDL代码后会自动进行一次编译，命令行窗口会出现如下信息 同时会生成一个report 没有报错的话即可在上面选择的文件夹里面看到生成的Verilog代码文件 将这些文件导入到EDA工具中即可直接例化使用。 💡 所有文件都要导入，不能只导入需要的某个名字的模块！ 💡 一定要看EDA软件编译后的报告，尤其是大型设计，很容易不满足时序要求，这个时候就要回去simulink里面优化设计，如果时序报告里面是A模块的某个地方时序满足不了要求，那么就要在simulink中在A模块中添加流水线。（注：Quartus中我没有遇见过时序报错的，可能是没有在Quartus中开发大工程）","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"多速率信号处理-插值和插值滤波器","slug":"多速率信号处理-插值和插值滤波器","date":"2024-09-09T16:00:00.000Z","updated":"2025-01-24T14:10:03.686Z","comments":true,"path":"2024/09/10/多速率信号处理-插值和插值滤波器/","permalink":"https://www.moerjielovecookie.icu/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E6%8F%92%E5%80%BC%E5%92%8C%E6%8F%92%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"","text":"插值意味着提高采样率，故而被称为上采样（Up Sample）。设原始序列为，采样率为，插值因子为，则插值的过程为原始序列每相邻两个样点之间插入个构成一个新序列，数学表达式为其他以表示的采样率，则采样率之间的关系为 图示如下： 从频域角度看， 原始序列的频谱以为周期做周期延拓。 插值后的新序列以新的采样率做周期延拓。 可以看到插值前后频谱成分不变，但是在的整数倍频点处的频谱称为镜像成分。所以插值后要加入一个低通滤波器滤除镜频。典型的插值器就是由上采样器和抗镜像滤波器共同完成的。 由于插值是在原始序列中插入零值，即某些采样点处的信号幅度为0，会改变信号的幅度，因此插值会造成信号幅度的损失。要保证插值前后信号幅度的统一，可在插值滤波器后设置一个增益因子L。","categories":[],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"多速率信号处理-Nobel恒等式","slug":"多速率信号处理-Nobel恒等式","date":"2024-09-09T16:00:00.000Z","updated":"2025-01-24T14:06:48.634Z","comments":true,"path":"2024/09/10/多速率信号处理-Nobel恒等式/","permalink":"https://www.moerjielovecookie.icu/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-Nobel%E6%81%92%E7%AD%89%E5%BC%8F/","excerpt":"","text":"典型的插值器的结构，滤波器位于插值操作后，意味着滤波器工作在较高的采样率下，对滤波器的设计带来压力。可以通过恒等变换将插值操作后置，滤波器前置，简化系统的设计。 第一恒等式表明抽取操作位于乘加操作之后和抽取操作位于乘加之前是等效的。 第二恒等式M个延迟之后再进行M抽取和M抽取之后再进行1个延迟是等效的。 第三恒等式信号通过滤波器H（zM ）并经M抽取后与信号通过M抽取并经滤波器H（z）是等效的 第四恒等式插值操作位于乘加之前与插值操作位于乘加之后是等效的 第五恒等式信号先经1个延迟再做L插值与先经L插值再做L个延迟是等效的 第六恒等式信号先经滤波器$H(z)$再做L插值与信号先做L插值再经滤波器$H(z^L)$是等效的","categories":[],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"多速率信号处理-半带滤波器","slug":"多速率信号处理-半带滤波器","date":"2024-09-09T16:00:00.000Z","updated":"2025-01-24T14:06:36.150Z","comments":true,"path":"2024/09/10/多速率信号处理-半带滤波器/","permalink":"https://www.moerjielovecookie.icu/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8D%8A%E5%B8%A6%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"","text":"半带滤波器本质上是FIR滤波器，但是有近一半的系数为0，因此运算量降至普通FIR滤波器运算量的一半。 半带滤波器具有如下特性： 半带滤波器的通带宽度（通带截止频率）与阻带宽度（为阻带起始频率）相等，通带纹波和阻带纹波页相等 半带滤波器的频率响应满足 单位冲激响应满足 当为偶数时当时 N为滤波器长度，必须为奇数","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"多速率信号处理","slug":"多速率信号处理","date":"2024-09-09T16:00:00.000Z","updated":"2025-01-24T14:05:54.276Z","comments":true,"path":"2024/09/10/多速率信号处理/","permalink":"https://www.moerjielovecookie.icu/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/","excerpt":"","text":"随着芯片技术的发展，ADC的采样率越来越高，导致数字化越来越靠近系统前端。目前，工程上采用较多的是中频采样技术，即在中频时就对模拟信号数字化，此时ADC的采样率低于奈奎斯特采样定律的最低采样率（2倍的信号带宽），为过采样。过采样可以将采样过程的固有的量化噪声均匀地分散在更大的带宽上，降低目标信号带宽上的噪声功率，随后通过滤波器滤除带外噪声，即可产生比临界采样信号更优的信噪比。 当信号被ADC采样并传输到FPGA时，信号就进入了数字域。然而过高的采样率会对后续的信号处理带来较大压力，为了缓解压力，就需要降低信号的采样率，即为抽取。抽取后的信号数据率相对较低，因而有效地降低了对FPGA资源的占用，同时有助于简化系统的时序收敛。 当驱动高速率DAC时，需要提高信号的采样率，即为内插。因为DAC的采样率越高，输出端的频谱的频域分离度就越高，可以简化DAC后的模拟滤波器的工作，从而提高信噪比。 多速率信号处理的典型应用即为数字上变频DUC（Digital Up Conversion）和数字下变频DDC（Digital Down Conversion）。 link_to_page link_to_page link_to_page link_to_page link_to_page","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"Matlab的4个取整函数","slug":"Matlab的4个取整函数","date":"2024-09-02T16:00:00.000Z","updated":"2025-01-20T02:44:10.695Z","comments":true,"path":"2024/09/03/Matlab的4个取整函数/","permalink":"https://www.moerjielovecookie.icu/2024/09/03/Matlab%E7%9A%844%E4%B8%AA%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"Round舍入至最近的小数或整数 Y = round(X) 将 X 的每个元素四舍五入为最近的整数。在舍入机会均等的情况下，即有元素的十进制小数部分为 0.5（在舍入误差内）时，round 函数会偏离零四舍五入到最接近的具有更大幅值的整数。 示例 Y = round(X,N) 四舍五入到 N 位数： N &gt; 0：舍入到小数点_右侧_的第 N 位数。 N = 0：四舍五入到最接近的整数。 N &lt; 0：舍入到小数点_左侧_的第 N 位数。 示例 Y = round(X,N,type) 指定四舍五入的类型。指定 &quot;significant&quot; 以四舍五入为 N 位有效数（从最左位数开始计数）。在此情况下，N 必须为正整数。 示例 Y = round(___,TieBreaker=direction) 按照 direction 指定的方向对结值进行舍入。在上述语法中的任何输入参数组合后使用此参数。 示例 Y = round(t) 将 duration 数组 t 的每个元素四舍五入到最接近的秒数。 示例 Y = round(t,unit) 将 t 的每个元素四舍五入到指定单位时间的最接近的数。 Ceil向正无穷舍入 Y = ceil(X) 将 X 的每个元素四舍五入到大于或等于该元素的最接近整数。 示例 Y = ceil(t) 将 duration 数组 t 的每个元素四舍五入到大于或等于此元素的最接近的秒数。 示例 Y = ceil(t,unit) 将 t 的每个元素四舍五入到大于或等于此元素的最接近的数（使用指定的时间单位）。 Floor向负无穷舍入 Y = floor(X) 将 X 的每个元素四舍五入到小于或等于该元素的最接近整数。 示例 Y = floor(t) 将 duration 数组 t 的每个元素四舍五入到小于或等于此元素的最接近的秒数。 示例 Y = floor(t,unit) 将 t 的每个元素四舍五入到小于或等于该元素的最接近数（使用指定的时间单位）。 Fix向零舍入 Y = fix(X) 将 X 的每个元素朝零方向四舍五入为最近的整数。此操作实际上是通过删除 X 中每个数的小数部分，将它们截断为整数： 对于正数，fix 的行为与 floor 相同。 对于负数，fix 的行为与 ceil 相同。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"2023年全国赛C题《 电容电感测量装置》设计报告","slug":"2023年全国赛C题《 电容电感测量装置》设计报告","date":"2024-08-18T16:00:00.000Z","updated":"2025-01-19T14:13:22.156Z","comments":true,"path":"2024/08/19/2023年全国赛C题《 电容电感测量装置》设计报告/","permalink":"https://www.moerjielovecookie.icu/2024/08/19/2023%E5%B9%B4%E5%85%A8%E5%9B%BD%E8%B5%9BC%E9%A2%98%E3%80%8A%20%E7%94%B5%E5%AE%B9%E7%94%B5%E6%84%9F%E6%B5%8B%E9%87%8F%E8%A3%85%E7%BD%AE%E3%80%8B%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/","excerpt":"","text":"测量原理参考下面网站的方案 bookmark 参考LCR测试仪，基本工作原理为给DUT加上正弦激励信号，然后测得该DUT两端的电压和流过DUT的电流，即可通过计算得到DUT的性质和参数。 对于一个理想电容，电流相位应该超前电容两端电压90°。然而实际的电容存在损耗，可以等效为一个理想电容$C_p$和一个理想电阻$R_p$的并联，因此电流超前电压的相位将小于90°，这个角度差即为损耗角。 假设DUT两端电压$\\dot{V}&#x3D;V\\cos(\\omega t)$，流过DUT的电流为$\\dot{I}&#x3D;I sin(\\omega t - \\varphi)$，电流在虚轴上的投影为流过理想电容的电流，在实轴上的投影为流过损耗电阻的电流。 因此可以计算出并联电容的容抗为$X_{Cp}&#x3D;\\frac{V}{I cos\\varphi}$，容值$C_P&#x3D;\\frac{1}{\\omega X_{Cp}}&#x3D;\\frac{I cos \\varphi}{\\omega V}$。 损耗电阻的值为$R_p&#x3D;\\frac{V}{Isin\\varphi}$。 定义元件消耗的无功功率和有功功率之比为元件的Q值，Q值的倒数为D值（损耗角正切） $$Q&#x3D;\\frac{R_P}{X_{Cp}}&#x3D;cot \\varphi, D&#x3D;\\frac{1}{Q}&#x3D;tan \\varphi$$ 上述需要的参数可以借助正交算法求得： $$\\begin{align}I\\sin(\\omega t-\\varphi)\\cdot V\\cos(\\omega t) &amp; &#x3D; \\frac12VI\\sin(2\\omega t-\\varphi)-\\frac12VI\\sin\\varphi\\I\\sin(\\omega t-\\varphi)\\cdot V\\sin(\\omega t) &amp; &#x3D; -\\frac12VI\\cos(2\\omega t-\\varphi)+\\frac12VI\\cos\\varphi \\end{align}$$ 相乘以后经过低通滤波器后即可得到直流成分$-\\frac{1}{2} VI sin\\varphi 和\\frac{1}{2} VI cos\\varphi$，即可求得题目要求的损耗角正切 $$tan\\varphi &#x3D; \\frac{VI sin \\varphi}{VI cos \\varphi}$$ 同时可求得以下参数 $$\\text{并联形式的理想电容的容抗 }X_{cp}&#x3D;\\frac V{I\\cos\\varphi}&#x3D;\\frac{V^2}{VI\\cos\\varphi} \\text{,电容为 }C_p&#x3D;\\frac1{\\omega X_{cp}},\\text{并联形式的损耗电阻}\\R_{p}&#x3D;\\frac V{I\\sin\\varphi}&#x3D;\\frac{V^2}{VI\\sin\\varphi}\\text{。其中 }V^2\\text{可以通过电压自乘后滤除高频成分后得到。}$$ 参数仿真现有的ADC的输入电压范围为0~2V，输入偏置为1V；DAC的输出电压范围为1V峰峰值，同时可以加偏置， 电容容值为1nF-100nF，检流电阻为0.33Ω时，输出电压峰峰值为4-200mv。测量电感时频率为1MHz，电感感值为10uF-100uF时，输出电压峰峰值为15-150mv。由于ADC模块的输入范围为0~2V，因此对信号进行9倍放大，峰峰值放大到1.8V左右。 调试记录DAC输出的信号和LC滤波器阻抗不匹配，导致LC滤波器的输入端信号幅值较低 待测元件检测电路上电后输入端有-500mv的偏置 LC滤波器设计如下，DAC输出1MHz的信号时高次谐波较为严重，因此设计一个通带为1.2MHz的LC低通滤波器滤除高次杂波。 PCB设计初代其中R8是用来连接测试夹具的，激励信号从P1输入，经过R8上的待测电容或电感后电流经过C5流入后级电流检测电路， 这样设计的话，电路的输入阻抗为测量夹具上的待测元件的在特定频率下的阻抗值，而前级放大器的输出阻抗为50Ω，会导致输入信号的幅值不是期望的幅值。 改进将前级放大器的输出端用于阻抗匹配的50Ω电阻拆掉，利用运放输出阻抗很低的特性，使得输出的信号的电压全都加在上面电路的输入端。 这样改进的原因是运放后级不带容性负载、LC滤波器、长同轴电缆的话输出端不需要接匹配电阻。 FPGA程序设计根据上面的原理，需要两个ADC采集电流和电压信号，1个DAC生成激励信号。因此选择DE0nano，有两个扩展的40pin排针，可以接入两个ADDA模块。 FPGA的晶振频率为50MHz，通过PLL分频出20MHz和80MHz，其中ADC的时钟为20M，DAC的时钟为80M。然后分别连接到ADC_Interface和DAC_Interface。 ADC部分采集到的信号位宽为10，舍弃低两位以便于后续对信号的处理，同时每采1024个样点后暂停0.5秒，然后再进行下次采集。 DAC部分采用一个NCO生成正弦波信号，通过拨码开关切换频率字，输出到DAC_interface后左移1位后输出，再通过一个同相放大器放大2倍，增强信号的驱动能力。 ADC采集到的电流和电压的数据存放到RAM中，通过改变起始的取地址来实现移相。使用的ADC的采样率为20M，采集100K的信号时，每个周期采集200个点，因此想要移相$\\frac{\\pi}{2}$时，只需要从50开始读取RAM里的数据，读出的信号即为从0开始读取的RAM的读出的信号进行$\\frac{\\pi}{2}$移相后的信号。 经ADC采集的数据为无符号数，做乘法滤波会和计算结果不匹配，因此再加入一级无符号转有符号数的module，转成有符号数后做乘法，再送入低通滤波器后即可获得需要的数值。对低通滤波器的输出进行截断，只保留高16位的数据，降低抖动的直流信号对结果的影响。 测量结果 第一个Lowpass的输出为$VIcos\\phi$，第二个Lowpass的输出为$\\frac{1}{2}VIcos \\varphi$，第三个Lowpass的输出为$V^2$，容抗的计算过程如下: 根据仿真的输入电流和输出电压的拟合关系可得，在输出采集的电压的幅值等于电流÷0.305，因此容抗为 第三个输出÷2÷第一个输出÷0.305 电路展示 后续计划加入spi通信，将采样计算出的数据传输到TI的开发板上进行进一步计算和显示。","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"},{"name":"Report","slug":"Report","permalink":"https://www.moerjielovecookie.icu/tags/Report/"}]},{"title":"黑金Alinx xc7z020 原理图","slug":"黑金Alinx xc7z020 原理图","date":"2024-07-22T16:00:00.000Z","updated":"2025-01-20T09:16:01.546Z","comments":true,"path":"2024/07/23/黑金Alinx xc7z020 原理图/","permalink":"https://www.moerjielovecookie.icu/2024/07/23/%E9%BB%91%E9%87%91Alinx%20xc7z020%20%E5%8E%9F%E7%90%86%E5%9B%BE/","excerpt":"","text":"时钟引脚CLK：U18复位RST：N15扩展接口J10 J11 PL LED PL KEY","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"},{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"C标准库读写文件","slug":"C标准库读写文件","date":"2024-06-19T16:00:00.000Z","updated":"2025-01-20T02:49:59.392Z","comments":true,"path":"2024/06/20/C标准库读写文件/","permalink":"https://www.moerjielovecookie.icu/2024/06/20/C%E6%A0%87%E5%87%86%E5%BA%93%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/","excerpt":"","text":"函数介绍库变量 变量 描述 size_t 无符号整数类型，是sizeof关键字的结果，表示对象大小 FILE 文件流类型，适合存储文件流信息的对象类型 库宏 宏 描述 NULL 空指针常量 EOF 表示已经到达文件结束的负整数 stderr、stdin、stdout 指向FILE类型的指针，分别对应标准错误、标准输入和标准输出流 库函数fopen12FILE *fopen(const char *filename, const char *mode) //以给定的模式mode打开filename指向的文件 mode 描述 “r“ 打开一个用于读取的文件，文件必须存在 ”w“ 创建一个用于写入的空文件。若存在同名文件，则删除旧文件的内容 ”a“ 追加到一个文件，写操作向文件末尾追加数据，文件不存在就创建文件 ”r+“ 打开一个用于更新的文件，可读取也可写入。该文件必须存在 ”w+“ 创建一个用于读写的空文件 “a+” 打开一个用于读取和追加的文件 函数返回一个FILE指针，否则返回NULL fread声明： 12345size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)//ptr：指向带有最小尺寸 size*nmemb 字节的内存块的指针//size：读取的每个元素的大小，以字节为单位//nmemb：元素的个数//stream：指向FILE对象的指针，指定了一个输入流 成功读取的元素会以size_t对象返回 fwrite12345size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)//ptr：指向被写入元素数组的指针//size：读取的每个元素的大小，以字节为单位//nmemb：元素的个数//stream：指向FILE对象的指针，指定了一个输出流 fseek1234int fseek(FILE *stream, long int offset, int whence)//stream：指向FILE对象的指针//offset：相对whence的偏移量，以字节为单位//whence：表示开始添加偏移的位置 whence一般为下面三个常量 常量 描述 SEEK_SET 文件开头 SEEK_CUR 文件指针的当前位置 SEEK_END 文件的末尾 返回从whence位置开始查找的字节数 ftell1long int ftell(FILE *stream) 返回位置标识符的当前值 使用C标准库读取TS文件并写入txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; FILE *fileInput, *fileOutput; unsigned char buffer[188]; // TS流的标准包大小为188字节 size_t bytesRead; // 打开TS文件 fileInput = fopen(&quot;/home/sawen/my_test_pcie/test.ts&quot;, &quot;rb&quot;); if (!fileInput) &#123; perror(&quot;Failed to open input file&quot;); return EXIT_FAILURE; &#125; else &#123; printf(&quot;Input file opened successfully.\\n&quot;); &#125; // 检查文件大小 fseek(fileInput, 0, SEEK_END); long fileSize = ftell(fileInput); rewind(fileInput); if (fileSize == 0) &#123; printf(&quot;Input file is empty.\\n&quot;); fclose(fileInput); return EXIT_FAILURE; &#125; else &#123; printf(&quot;Input file size: %ld bytes.\\n&quot;, fileSize); &#125; // 打开TXT文件 fileOutput = fopen(&quot;output.txt&quot;, &quot;w&quot;); if (!fileOutput) &#123; perror(&quot;Failed to open output file&quot;); fclose(fileInput); return EXIT_FAILURE; &#125; else &#123; printf(&quot;Output file opened successfully.\\n&quot;); &#125; // 读取数据并写入到TXT文件 int packetCount = 0; while ((bytesRead = fread(buffer, 1, sizeof(buffer), fileInput)) &gt; 0) &#123; for (size_t i = 0; i &lt; bytesRead; ++i) &#123; fprintf(fileOutput, &quot;%02x &quot;, buffer[i]); // 将字节以十六进制格式写入 &#125; fprintf(fileOutput, &quot;\\n&quot;); // 每个TS包后换行 packetCount++; &#125; // 检查是否有数据被读取 if (packetCount == 0) &#123; printf(&quot;No data read from file.\\n&quot;); &#125; else &#123; printf(&quot;Processed %d TS packets.\\n&quot;, packetCount); &#125; // 关闭文件 fclose(fileInput); fclose(fileOutput); printf(&quot;Data transfer complete.\\n&quot;); return EXIT_SUCCESS;&#125; 运行结果如下 可以看到以188个字节为一行写入txt","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"}]},{"title":"MATLAB中使用HDL Coder生成HDL代码时的报错集合","slug":"MATLAB中使用HDL Coder生成HDL代码时的报错集合","date":"2024-06-12T16:00:00.000Z","updated":"2025-01-20T02:42:51.295Z","comments":true,"path":"2024/06/13/MATLAB中使用HDL Coder生成HDL代码时的报错集合/","permalink":"https://www.moerjielovecookie.icu/2024/06/13/MATLAB%E4%B8%AD%E4%BD%BF%E7%94%A8HDL%20Coder%E7%94%9F%E6%88%90HDL%E4%BB%A3%E7%A0%81%E6%97%B6%E7%9A%84%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/","excerpt":"","text":"Delay balancing unsuccessful because an extra 4 cycles of latency introduced by optimizations in the feedback loop cannot be offset using design delays for the loop latency budget.产生原因 由于时序考虑，在每个模块的输出端添加了1到2级的输入输出流水线，但是在这种带反馈的结构上添加输入输出流水线后，会产生如下的报错 可以看出加入的输入输出流水线会导致额外的时钟延时，使得延时平衡失败。 解决方法在保证时序的前提下将带有反馈回路的模块输入输出流水线设置为0，也可以在同级输出端口加入delay手动添加流水线。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"Modelsim中使用tcl命令导出仿真数据到txt文件","slug":"Modelsim中使用tcl命令导出仿真数据到txt文件","date":"2024-06-08T16:00:00.000Z","updated":"2025-01-20T02:41:52.767Z","comments":true,"path":"2024/06/09/Modelsim中使用tcl命令导出仿真数据到txt文件/","permalink":"https://www.moerjielovecookie.icu/2024/06/09/Modelsim%E4%B8%AD%E4%BD%BF%E7%94%A8tcl%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BA%E4%BB%BF%E7%9C%9F%E6%95%B0%E6%8D%AE%E5%88%B0txt%E6%96%87%E4%BB%B6/","excerpt":"","text":"参考下面的CSDN博客 bookmark Tcl命令12345678910proc write_sim_data &#123;env name radix cycle file&#125; &#123; set fid [open $file w] for &#123;set i 0&#125; &#123;$i &lt;= $::now&#125; &#123;incr i [expr $cycle * 1000]&#125; &#123; set str [exa -env $env -radix $radix -time $&#123;i&#125;ps &#123;*&#125;$name] puts $fid $str &#125; close $fid &#125; Line1：定义一个名为write_sim_data的过程，参数列表为：{env name radix cycle file} env：指定查找对象名称的路径。如top_tb&#x2F;top_u name：需要导出的变量列表。如{I_reset_n R_data_cnt} radix：进制。可选：ascii,binary, decimal,hexadecimal,unsigned等 cycle：时钟周期，单位ns file：输出文件。如.&#x2F;1.txt Line2：打开一个文档，返回文件描述符 Line3：分别获得从0到仿真结尾时间，按时钟周期间隔对数据进行取样输出 Line4：获得具体数据 Line5：将数据写入文件 Line7：关闭文件 示例： 1write_sim_data sim:/top_tb/u_top_wrapper/top_i/RS_Enc_0 &#123;RS_Out Trigger&#125; unsigned 1000 data.txt","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"Xilinx FPGA中的BUFFER","slug":"Xilinx FPGA中的BUFFER","date":"2024-05-28T16:00:00.000Z","updated":"2025-01-20T02:37:22.046Z","comments":true,"path":"2024/05/29/Xilinx FPGA中的BUFFER/","permalink":"https://www.moerjielovecookie.icu/2024/05/29/Xilinx%20FPGA%E4%B8%AD%E7%9A%84BUFFER/","excerpt":"","text":"FPGA大型设计中推荐使用同步时序电路，同步时序电路基于时钟触发沿设计，对时钟的周期、占空比、延时和抖动有更高的要求。为满足时序的要求，一般采用全局时钟资源驱动设计的主时钟，FPGA的主时钟一般使用全铜层工艺实现，并设计了专用时钟缓冲与驱动结构。 缓冲和驱动缓冲输入输出缓冲，主要用于片外输入时钟或者片外差分输入的信号。 差分信号和差分时钟进入片内后如果不经过IBUFGDS、IBUFDS缓冲就无法直接处理 驱动当信号扇出过大时可以通过加BUFG增加信号稳定性 过一次BUFG有10ns左右的延时，但是通过BUFG后输出到片上所有单元的延时都可以忽略不记 Buffer的类别和作用BUFG BUFG是一个高扇出缓冲器，将信号连接到全局布线资源上，使得信号的延时和抖动最小 通常用于时钟网络以及其他高扇出网络，比如复位和使能信号 BUFGCE BUFGCE具有单门控输入的全局时钟缓冲器，CE高电平有效 当CE为低电平时 O 端口输出0 BUFH BUFH原语允许直接访问BUFG的时钟区域入口，允许访问全局时钟网络中未使用的部分，作为高速低偏移的本地路由资源（单时钟区域） IBUFDS 支持低压差分信号输入的缓冲器，有两个输入的端口，一个为主端口一个为从端口，输入的信号相位相反 IBUFDS_GTE27系列器件中的Gbit 收发器输入缓冲，REFCLK应连接到串行收发器的专用参考时钟输入引脚 OBUFDS差分信号输出缓冲器","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"NCO模块的各项参数","slug":"NCO模块的各项参数","date":"2024-05-18T16:00:00.000Z","updated":"2025-01-20T02:40:51.238Z","comments":true,"path":"2024/05/19/NCO模块的各项参数/","permalink":"https://www.moerjielovecookie.icu/2024/05/19/NCO%E6%A8%A1%E5%9D%97%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0/","excerpt":"","text":"NCO模块可以生成实数或者复数正弦信号，同时提供硬件友好的控制信号 Accumulator累加器位数正弦波的频率分辨率取决于累加器的位数的大小，根据频率分辨率可以计算出累加器的位数，根据此位数设置累加器的数据类型字长 计算公式为 $$N&#x3D;ceil(log_2(\\frac{F_s}{\\Delta f}))$$ 量化位数量化累加器的输出可以在不增加查找表的大小的情况下提高频率分辨率 要根据无杂散动态范围来计算量化位数，计算公式为 $$Q&#x3D;ceil(\\frac{SFDR-12}{6})$$ 相位增量$$phInc&#x3D;round(\\frac{f\\times 2^N}{F_s})$$","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"运放的同相与反相放大","slug":"运放的同相与反相放大","date":"2024-05-04T16:00:00.000Z","updated":"2025-01-20T02:52:41.009Z","comments":true,"path":"2024/05/05/运放的同相与反相放大/","permalink":"https://www.moerjielovecookie.icu/2024/05/05/%E8%BF%90%E6%94%BE%E7%9A%84%E5%90%8C%E7%9B%B8%E4%B8%8E%E5%8F%8D%E7%9B%B8%E6%94%BE%E5%A4%A7/","excerpt":"","text":"反相放大器同相端接地，电压为 0，反相端和同相端虚短，因此也是 0 V 的电压，同时由于虚断，几乎没有电流注入，所以R 1 和R 2 相当于串联，电阻上的电流相等 因此可以求出输入输出关系式为 $$V_{out}&#x3D;-\\frac{R_2}{R_1}\\times V_i$$ 同相放大器同样根据虚断和虚短可以求得输入输出关系式为 $$V_{out}&#x3D;\\frac{R_1+R_2}{R_2}\\times V_i $$ 同相放大器和反相放大器的优缺点反相放大器 优点：两个输入端电位始终近似为 0，只有差模信号，抗干扰能力强 缺点：输入阻抗小，等于信号到输入端的串联电阻阻值 同相放大器 优点：输入阻抗接近无穷大 缺点：放大电路没有虚地，有较大共模电压，抗干扰能力差，使用时要求运放有较高的共模抑制比 如果要求输入阻抗不高且相位无要求时，首选反相放大，因为反相放大只存在差模信号，抗干扰能力强，可以得到更大的输入信号范围 在设计中要求放大倍数相同的情况下尽量选择数值小的电阻配合，这样可以减小输入偏置电流的影响和分布电容的影响","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"Vivado报错集合","slug":"Vivado报错集合","date":"2024-04-30T16:00:00.000Z","updated":"2025-01-20T02:38:11.296Z","comments":true,"path":"2024/05/01/Vivado报错集合/","permalink":"https://www.moerjielovecookie.icu/2024/05/01/Vivado%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/","excerpt":"","text":"Synth 8-5535报错代码 12345[Synth 8-5535] port &lt;clk_0&gt; has illegal connections. It is illegal to have a port connected to an input buffer and other components. The following are the port connections :Input Buffer: Port I of instance clkin1_ibufg(IBUF) in module &lt;top_clk_wiz_0_1_clk_wiz&gt;Other Components: 原因普通IO输入的时钟信号必须要经过buffer才能驱动PLL 解决方法将clocking wizard中的输入信号配置为 No Buffer Warning：filegmt 56-199 解决方法在Sources栏右键选择refresh hierarchy即可 Warning：CRITICAL WARNING: [filemgmt 56-176] Module references are not supported in manual compile order mode and will be ignored.解决方法 将刷新层次结构的模式设置为自动更新和编译即可 [BD 41-237] Bus Interface property FREQ_HZ does not match between &#x2F;M_AXIS_DATA_0(100000000) and &#x2F;dds_compiler_0&#x2F;M_AXIS_DATA(200000000) 引发这个报错的原因是IP核的时钟频率为200M，但是AXI4s的端口的频率为100M，因此将端口的频率设置为和IP核匹配的频率即可 vivado的各种设置无法保存原因“C:\\Users\\31651\\AppData\\Roaming\\Xilinx\\Vivado\\2023.2\\vivado.xml”这个文件里面存放了vivado的设置，例如最近打开的文件等 如果这些路径中有中文字符或其他vivado无法识别的字符，那么每次启动时vivado无法正常读取这些配置，就会重置这个文件，表现为重启vivado后所有配置全部丢失 解决方法将含有中文字符的文件路径删除或者改成英语命名 [Common 17-180] Spawn failed: No error 导致原因在 Vivado 中，报错信息 “[Common 17-180] Spawn failed: No error” 表示 Vivado 无法成功启动或创建某个进程，尽管没有明确的错误信息。这个错误通常发生在 Vivado 尝试启动外部进程或执行某些操作时，比如编译、生成比特流或启动仿真工具等。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"Matlab生成txt文件导入到Vivado仿真","slug":"Matlab生成txt文件导入到Vivado仿真","date":"2024-04-24T16:00:00.000Z","updated":"2025-01-20T02:43:30.253Z","comments":true,"path":"2024/04/25/Matlab生成txt文件导入到Vivado仿真/","permalink":"https://www.moerjielovecookie.icu/2024/04/25/Matlab%E7%94%9F%E6%88%90txt%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E5%88%B0Vivado%E4%BB%BF%E7%9C%9F/","excerpt":"","text":"Matlab处理数据并将其写入txt文件1234567%% Txt Generatepre_RS_data=dec2bin(simDataIn,8); %将数据转化为8bit的二进制fid=fopen(&quot;F:\\FPGA\\Xilinx_vivado\\project\\dvbstestbench\\dbvs\\matlab\\pre_RS_data.txt&quot;,&quot;wt&quot;);for i=1:n*nMessages %数据长度 fprintf(fid,&quot;%s\\n&quot;,pre_RS_data(i,1:8)); %由于二进制数据为8位，因此是1:8endfclose(fid); 使用fopen函数获取文件id，fopen的语法如下 其中permisson为文件访问类型，有以下几种权限 &#39;r&#39; 打开要读取的文件。 &#39;w&#39; 打开或创建要写入的新文件。放弃现有内容（如果有）。 &#39;a&#39; 打开或创建要写入的新文件。追加数据到文件末尾。 &#39;r+&#39; 打开要读写的文件。 &#39;w+&#39; 打开或创建要读写的新文件。放弃现有内容（如果有）。 &#39;a+&#39; 打开或创建要读写的新文件。追加数据到文件末尾。 &#39;A&#39; 打开文件以追加（但不自动刷新）当前输出缓冲区。 &#39;W&#39; 打开文件以写入（但不自动刷新）当前输出缓冲区。 💡 要以文本模式打开的话，要附加’t’ Vivado中testbench写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354`timescale 1ns/1psmodule top_tb();reg clk;reg rst_n;reg [7:0]SEQ_IN_0;reg [7:0] data_mem[1:1020];reg [31:0] i;wire BIN_OUT;wire ce_out;wire locked;//clk &amp; rst_n geninitial begin clk=1&#x27;b0; rst_n=1&#x27;b0; #100 rst_n=1&#x27;b1; endalways #5 clk=~clk;//data readinitial begin $readmemb(&quot;F:/FPGA/Xilinx_vivado/project/dvbstestbench/dbvs/matlab/pre_RS_data.txt&quot;,data_mem); endinitial begin i=1; forever @(posedge clk) begin if(i&lt;1020) begin i=i+1; end else i=1; end $display(&quot;%s&quot;,data_mem[i]);endalways @(posedge clk) begin SEQ_IN_0&lt;=data_mem[i];endtop_wrapper top_wrapper_u0( .clk_0 (clk), .rst_n_0 (rst_n), .SEQ_IN_0(SEQ_IN_0), .BIN_OUT_0 (BIN_OUT), .ce_out_0 (ce_out), .locked_0 (locked));endmodule 💡 直接在文件夹内部复制的文件路径是\\，但是testbench中要将所有反斜杠改为&#x2F;，否则无法读取txt文件","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"DVB-S系统仿真学习","slug":"DVB-S系统仿真学习","date":"2024-03-26T16:00:00.000Z","updated":"2025-01-20T02:48:08.021Z","comments":true,"path":"2024/03/27/DVB-S系统仿真学习/","permalink":"https://www.moerjielovecookie.icu/2024/03/27/DVB-S%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"DVB-S系统用于卫星电视信号传输，发送端框图如下所示 扰码实际数字通信中，载荷数据的码元会出现长连0或长连1的情况，不利于接收端提取时钟信号，同时会使得数据流中含有大量的低频分量，使得QPSK调制器的相位长时间不变，使得信号易受干扰。因此要对载荷数据进行随机化扰码处理 DVB-S标准中规定扰码的生成多项式为 $$p(x)&#x3D;x^{15}+x^{14}+1$$ 同时移位寄存器的初始状态为”1001_0101_0000_000” Matlab代码仿真12345678n=500;% origin_data=randi([0 1],n,1);origin_cnt_1=nnz(origin_data==1)scrambling = comm.Scrambler(&quot;CalculationBase&quot;,2,&quot;InitialConditions&quot;,[1 0 0 1 0 1 0 1 0 0 0 0 0 0 0], ... &quot;Polynomial&quot;,[1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1]);scrambling_data=step(scrambling,origin_data);scrambling_data_cnt_1=nnz(scrambling_data==1) 运行结果如下图所示 可以看出初始的500点长度的数据包中有403个“1”，经过扰码处理后“1”的个数接近数据总量的一半 外码纠错编码（RS编码）RS码定义： $GF(q)上（q \\neq 2, 通常q&#x3D;2^m），码长n&#x3D;q-1的本原BCH码$ 能纠正 t 个错误的RS码的参数为 - 分组长度n=q-1 - 校验符号数n-k=2t - 码的最小距离dmin=2t+1 DVB-S系统中使用的RS(188，204)是由RS(239,255)截断而来的，可以纠正8个字节的错误 Matlab仿真12345678910111213141516171819m=8; %bit per symboln=204;k=188;data_test=randi([0,n],1,k);data_gf=gf(data_test,m);data_rs_enc=rsenc(data_gf,n,k);data_enc=data_rs_enc.x;data_rs_dec=rsdec(data_rs_enc,n,k);data_dec=data_rs_dec.x;subplot(3,1,1);stem(data_test);subplot(3,1,2);stem(data_enc);subplot(3,1,3);stem(data_dec); 首先生成一个长度为188的序列，将其转换到伽罗华域后，使用rsenc函数进行RS编码，再进行译码，根据对比可以看出译码后的比特和译码前的完全一样 卷积交织在实际的传输过程中，由于脉冲干扰、多径效应等因素会带来持续一定时间的突发错误，虽然RS码对突发错误有较好的纠错能力，但是当其持续时间较长时，就会超出RS码的纠错能力，因此在编码过程中引入了卷积交织，将数据的传输顺序按照一定的规律分散开，就可以使得错误的码元也被分散开 DVB-S中交织深度为12，总共17个FIFO，数据按行写入寄存器，按列读出 交织后最大可纠错长度为12*8&#x3D;96 可以看出前一段时间读取到了很多0，说明下面的移位寄存器中的数据还没有移动到末端 卷积编码卷积码是一种有效的前向纠错码记作$(n,k,m)$，将k个信息比特编为n个比特，m为编码存储长度，N&#x3D;m+1为约束长度，即卷积码的当前码元不仅与当前输入的k的信息码元有关，还与前面m个时刻输入的信息码元有关 12345678910111213141516171819clc;close all;n=500;tre1=[1 1 1 1 0 0 1]; %oct 171tre2=[1 0 1 1 0 1 1]; %oct 133trellis = poly2trellis(7,[171 133]);convData=convenc(scrambling_data,trellis);decData=vitdec(convData,trellis,499,&quot;trunc&quot;,&quot;hard&quot;);subplot(3,1,1);stem(scrambling_data);subplot(3,1,2);stem(convData);subplot(3,1,3);stem(decData);biterr(scrambling_data,decData) 使用poly2trellis将卷积编码多项式转换为网格描述 比对后可以看到解码出的数据和原数据完全相同","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"QPSK simulink实现","slug":"QPSK simulink实现","date":"2024-03-23T16:00:00.000Z","updated":"2025-01-20T02:39:54.913Z","comments":true,"path":"2024/03/24/QPSK simulink实现/","permalink":"https://www.moerjielovecookie.icu/2024/03/24/QPSK%20simulink%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"调制部分总体框架 各模块参数升余弦滚降滤波器滚降系数为 1 单双极性变换 各阶段波形Buffer Demux Raised Cosine TransmitFilter QPSK 信号功率谱密度 解调部分经过 AWGN 信道后，假设已经进行了载波同步 部分模块参数载波模块 Pulse Generator 由于经过了串并转换，因此数据率减半 部分波形 将初始信号经过一定时间的延时后，在示波器中和解调输出的信号基本对齐，可以发现基本实现QPSK 调制解调","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"8bit数据转1bit逐位输出电路仿真","slug":"8bit数据转1bit逐位输出电路仿真","date":"2024-03-22T16:00:00.000Z","updated":"2025-01-20T03:13:09.340Z","comments":true,"path":"2024/03/23/8bit数据转1bit逐位输出电路仿真/","permalink":"https://www.moerjielovecookie.icu/2024/03/23/8bit%E6%95%B0%E6%8D%AE%E8%BD%AC1bit%E9%80%90%E4%BD%8D%E8%BE%93%E5%87%BA%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9F/","excerpt":"","text":"在DVB-S系统中，TS流在经过RS编码后，会变成uint8类型的数据，在后续QPSK星座映射时又需要二进制码流，因此在进行了RS编码后要将8个bit的数据转化成1个bit逐位输出 实现思路首先使用BitwiseOperator模块按位与操作，分别将8位二进制数据提取出来，然后使用一个计数器产生0~7的计数信号作为mux模块的使能，在8个时钟周期内分别输出提取出来的8位数据 结构框图 仿真结果 输入的数据是133，二进制为10000101，可以看到输出的结果符合需求","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"AXI-STREAM简介","slug":"AXI-STREAM简介","date":"2024-03-19T16:00:00.000Z","updated":"2025-01-20T02:50:44.709Z","comments":true,"path":"2024/03/20/AXI-STREAM简介/","permalink":"https://www.moerjielovecookie.icu/2024/03/20/AXI-STREAM%E7%AE%80%E4%BB%8B/","excerpt":"","text":"AXI-STREAM简介概念AXI-Stream总线是一种高效、简单的数据传输协议，主要用于高吞吐量的数据流传输场景。相比于传统的AXI总线，AXI-Stream总线更加简单和轻量级，它通过无需地址的方式，将数据从一个模块传输到另一个模块，适用于需要高速数据传输的应用场景。 部分术语 Transfer：基于TVALID和TREADY握手协议的传输 Packet：一组通过axi-stream传输的数据 Frame：最大的Byte组合，包含整数个Packet 接口信号 信号 描述 ACLK 全局时钟信号，上升沿有效 ARSTn 全局复位信号，低电平有效 TVALID 主机驱动有效数据 TREADY 从机可以接收数据 TDATA[(8n-1):0] 位宽为整数倍byte TLAST 表示数据包的边界 TID 由主机发出，Identity标识符，在存在多个stream数据传输时起作用，用于识别不同的数据流 当clk上升沿检测到TVALID和TREADY均为高电平时开始传输数据 由于AXI-STREAM不需要传输地址，仅进行简单的发送和接收，因此减小了传播时延","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]}],"categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"},{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"},{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"},{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"},{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"},{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"},{"name":"Report","slug":"Report","permalink":"https://www.moerjielovecookie.icu/tags/Report/"}]}