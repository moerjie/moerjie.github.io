{"meta":{"title":"Sawen_Blog","subtitle":"记录学习生活的点点滴滴","description":"","author":"Sawen Moerjie","url":"https://www.moerjielovecookie.icu","root":"/"},"pages":[{"title":"categories","date":"2025-01-19T13:51:05.000Z","updated":"2025-01-19T13:51:58.136Z","comments":false,"path":"categories/index.html","permalink":"https://www.moerjielovecookie.icu/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2025-01-20T03:03:39.000Z","updated":"2025-01-20T03:29:12.489Z","comments":false,"path":"about/index.html","permalink":"https://www.moerjielovecookie.icu/about/index.html","excerpt":"","text":"我是一个普通的传媒工科牲"},{"title":"tag","date":"2025-01-19T13:53:49.000Z","updated":"2025-01-19T13:54:16.343Z","comments":false,"path":"tag/index.html","permalink":"https://www.moerjielovecookie.icu/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"无线信道衰落","slug":"无线信道衰落","date":"2025-09-15T16:00:00.000Z","updated":"2025-09-16T03:49:56.967Z","comments":true,"path":"2025/09/16/无线信道衰落/","permalink":"https://www.moerjielovecookie.icu/2025/09/16/%E6%97%A0%E7%BA%BF%E4%BF%A1%E9%81%93%E8%A1%B0%E8%90%BD/","excerpt":"","text":"无线信道的一个典型特征是衰落现象：信号幅度在时间和频率上的波动。加性噪声是信号恶化的最普遍来源，衰落是另一种来源，其在无线信道中引起的是非加性的信号扰动。衰落也可由多径传播或障碍物遮蔽引起。衰落大致分为两种：大尺度衰落和小尺度衰落。当移动设备长距离移动时（小区大小距离）会产生大尺度衰落。它由信号的路径损耗（关于距离的 func）和大型障碍物形成的阴影所引起的。小尺度衰落是当移动设备在较短距离内移动时，由多条路径的相消或相长干涉引起的信号电平快速波动。 1 大尺度衰落1.1 一般路径损耗模型自由空间传播模型用于预测视距环境中信号接收的强度。常用于卫星通信系统。其中： 为发射功率，单位：W 表示发射机与接收机的距离，单位：m 各向异性天线时，发射天线增益为 ，接收天线增益为 为与传播环境无关的系统损耗系统，表示实际硬件系统中的总体衰减假设系统硬件没有损耗，则自由空间路径损耗为：若没有天线增益，则公式可以简化为：对数距离路径损耗模型如下：其中， 是一个参考距离，不同的传播环境中参考距离不同。例如，大范围覆盖的蜂窝系统（半径大于 10km），通常设置 为 ；对于小区半径为 或具有极小半径的微蜂窝系统，可以分别设置为 或 。路径损耗指数 由传播环境决定。 环境 路径损耗指数 自由空间 2 市区蜂窝 2.7~3.5 市区蜂窝阴影 3-5","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"射频","slug":"射频","permalink":"https://www.moerjielovecookie.icu/tags/%E5%B0%84%E9%A2%91/"}]},{"title":"电磁兼容试验记录","slug":"电磁兼容试验记录","date":"2025-09-13T16:00:00.000Z","updated":"2025-09-14T13:33:55.588Z","comments":true,"path":"2025/09/14/电磁兼容试验记录/","permalink":"https://www.moerjielovecookie.icu/2025/09/14/%E7%94%B5%E7%A3%81%E5%85%BC%E5%AE%B9%E8%AF%95%E9%AA%8C%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1 2025-9-14 电磁兼容试验如果设备通过同轴线连接到示波器测试，示波器会引入 13MHz 左右的干扰辐射，同轴线质量较差的话会辐射出去影响 RE102。试验前至少要把暗室内的那部分线缆包上铜箔。","categories":[{"name":"电子测量","slug":"电子测量","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E5%AD%90%E6%B5%8B%E9%87%8F/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"},{"name":"射频","slug":"射频","permalink":"https://www.moerjielovecookie.icu/tags/%E5%B0%84%E9%A2%91/"}]},{"title":"Docker","slug":"Docker","date":"2025-09-09T16:00:00.000Z","updated":"2025-09-10T11:36:13.289Z","comments":true,"path":"2025/09/10/Docker/","permalink":"https://www.moerjielovecookie.icu/2025/09/10/Docker/","excerpt":"","text":"","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"}]},{"title":"惯导系统","slug":"惯导系统","date":"2025-08-26T16:00:00.000Z","updated":"2025-08-27T06:59:53.456Z","comments":true,"path":"2025/08/27/惯导系统/","permalink":"https://www.moerjielovecookie.icu/2025/08/27/%E6%83%AF%E5%AF%BC%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"1 惯导系统核心组成部分1.1 惯性测量单元（Inertial Measurement Unit）1.1.1 功能直接测量载体的运动参数 1.1.2 组成 加速度计：用于测量载体在三个正交方向上的线加速度 陀螺仪：用于测量载体绕三个轴的角速度（俯仰、横滚、偏航） 磁力计（非必须）：用于测量地球磁场，辅助确定载体的方位角 1.2 导航计算机1.2.1 功能接收 IMU 采集到的原始数据，解算出载体的导航参数 1.2.2 子功能 积分运算：对加速度计测得的加速度进行一次积分得到速度，二次积分得到位置变化量。对陀螺仪测得的角速度进行积分得到姿态角变化量 坐标系变换 有害加速度补偿：从加速度计信号中扣除重力加速度、哥氏加速度和向心加速度等，提取出载体真正的运动加速度 误差补偿 2 陀螺仪2.1 光纤陀螺仪2.1.1 原理在多匝光纤线圈中，两束沿相反方向传播的激光发生干涉，其干涉条纹的移动与光路旋转的角速度成正比 2.1.2 优点结构简单、动态范围宽、耐冲击、启动快、可靠性高、直接数字输出，并且不需要精密加工的光学谐振腔和反射镜 2.1.3 性能精度最高可到 0.01°/h 2.2 微机械陀螺仪2.2.1 原理基于科里奥利力 (Coriolis Force)。驱动质量块在一种模式（驱动模态）下振动，当有角速度输入时，会在另一种模式（检测模态）下产生与角速度成正比的振动，通过检测该振动来测量角速度 2.2.2 优点尺寸极小、重量极轻、成本极低、功耗低、可靠性高、抗冲击性强、易于批量生产 但是精度相对较低、误差随时间累积 2.2.3 性能目前工程化产品的零偏稳定性已达到 50°/h，在温控条件下可达 1°/h","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"IQ调制","slug":"IQ调制","date":"2025-08-13T16:00:00.000Z","updated":"2025-08-20T03:42:02.239Z","comments":true,"path":"2025/08/14/IQ调制/","permalink":"https://www.moerjielovecookie.icu/2025/08/14/IQ%E8%B0%83%E5%88%B6/","excerpt":"","text":"1 基本原理当一对周期信号的相位相差 90°时，被认为是正交信号。 同相分量（I）：作为参考信号，通常与载波的 cos 部分同步 正交分量（Q）：相对于 I 分量移相 90°，对应载波的 sin 部分 数学正交性：两个周期信号在积分内积下互不干扰 2 调制过程 基带处理：数据流分为 I、Q 两路 载波调制： I 路乘余弦载波 Q 路乘正弦载波 信号合成：","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"OK3568开发环境配置-Ubuntu-22.04","slug":"OK3568开发环境配置-Ubuntu-22.04","date":"2025-08-12T16:00:00.000Z","updated":"2025-08-13T02:12:11.470Z","comments":true,"path":"2025/08/13/OK3568开发环境配置-Ubuntu-22.04/","permalink":"https://www.moerjielovecookie.icu/2025/08/13/OK3568%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-Ubuntu-22.04/","excerpt":"","text":"OK3568 官方资料和 Ubuntu22.04 虚拟机镜像如下：通过网盘分享的文件：OK3568-资料-开发虚拟机 1 系统镜像编译下载网盘里的源码，解压后即可得到 OK3568_Linux_fs.tar。解压 OK3568_Linux_fs.tar和dl.tar.bz2，将 dl 移动到 OK3568_Linux_fs/buildroot 后可加速编译系统镜像。编译系统镜像的教程如下：04_相关代码编译 2 交叉编译安装软件交叉编译器路径为 OK3568_Linux_fs/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-，在 ~/.bashrc 中配置环境变量 export PATH=\"/home/forlinx/3568/OK3568_Linux_fs/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin:$PATH\"。 2.1 ffmpeg-2.4.14在源码文件夹里首先运行 configure 脚本。 123456789./configure \\--prefix=/usr/local \\--cross-prefix=aarch64-none-linux-gnu- \\--arch=aarch64 \\--target-os=linux \\--enable-cross-compile \\--disable-static \\--enable-shared \\--pkg-config-flags=\"--static\" --prefix=/usr/local: 指定 FFmpeg 在目标机上的安装路径。 --cross-prefix=aarch64-none-linux-gnu-: 最关键的参数，它告诉 configure 脚本使用 aarch64-none-linux-gnu- 作为所有编译器和工具的前缀。 --arch=aarch64: 指定目标 CPU 架构。 --target-os=linux: 指定目标操作系统为 Linux。 --enable-cross-compile: 明确启用交叉编译模式。 --disable-static: 只编译动态库（.so 文件），这通常能减小最终文件的大小。 --enable-shared: 编译动态链接库。 --pkg-config-flags=\"--static\": 避免在交叉编译时，pkg-config 尝试在宿主机上查找动态库。配置成功后执行 make 和 sudo make install，编译好的库文件、头文件和可执行文件安装到 /usr/local 目录下。 2.2 log4cplus-2.0.7configure 命令如下： 1./configure --host=aarch64-none-linux-gnu --prefix=/usr/local --host=aarch64-none-linux-gnu：这是最重要的参数，它确保 make 命令会调用正确的交叉编译器。 --prefix=/usr/local：这个参数指定了 log4cplus 在目标机上的安装路径。如果未指定，默认也是 /usr/local。 2.3 zeromq-4.0.8configure 命令如下： 1./configure --host=aarch64-none-linux-gnu --prefix=/usr/local --enable-shared --disable-static --host=aarch64-none-linux-gnu: 最关键的参数，它告诉 configure 脚本，您正在为 aarch64 架构进行交叉编译。 --prefix=/usr/local: 指定 ZeroMQ 在目标机上的安装路径。 --enable-shared: 编译动态链接库（.so 文件）。 --disable-static: 不编译静态库（.a 文件），以减小最终文件的大小。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://www.moerjielovecookie.icu/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"FM调频","slug":"FM调频","date":"2025-08-07T16:00:00.000Z","updated":"2025-08-24T09:24:02.413Z","comments":true,"path":"2025/08/08/FM调频/","permalink":"https://www.moerjielovecookie.icu/2025/08/08/FM%E8%B0%83%E9%A2%91/","excerpt":"","text":"1 调制算法1.1 FM 信号描述用基带调制信号去控制载波信号的瞬时频率，使其按照调制信号的规律变化，当调制信号是模拟信号时，这个过程即为调频。调频信号的时域表达式如下： 其中， 为载波振幅， 为调频灵敏度（单位为 ）， 是调制信号， 为载波， 为载波角频率。根据(1) 式，可算出 FM 信号相对于载波频率的瞬时频偏为：由（1）式可知，FM 信号相对于载波相位的瞬时相位偏移随 的积分呈线性变化，由（2）式可知，FM 信号相对于载频的瞬时频率频移随 呈线性变化，比例系数都为 。用 表示调频灵敏度（单位 Hz/V），关系为 。FM 的调频指数 为：其中 是基带信号 的带宽或最高频率。 1.1.1 窄带调频（NBFM）将由 引起的最大瞬时相位偏移远小于 30°的情况称为窄带调频。窄带调频的带宽较窄，传输数据量有限，主要应用于无线语言的传输。此时，式（1）可以近似为：对其做 FFT 变换，得到窄带调频信号的频谱为：其中 是调制信号 的频谱。与 AM 信号不同的是，NBFM 信号的两个边带分别乘了因式 和，由于因式是与频率有关的函数，所以其加权是频率加权，加权的结果引起了调制信号频谱失真，而且 NBFM 的一个边带与 AM 反相。 1.1.2 宽带调频（WBFM）当不满足式（4）的条件时，称为宽带调频。宽带调频占用的频带较宽，传输数据量大，主要用于调频立体声广播。WBFM 的时域表达式无法简化，当 时，带入式（1）可得：式中 为第一类 n 阶贝塞尔函数，是调频指数 的函数。频谱为： 1.2 FM 信号的带宽宽带调频信号的频谱包含无穷多个频率分量，因此理论上调频信号的频带宽度为无限宽。但是，实际上边频幅度 随着 n 的增大而减小，因此取适当的 n 值使边频分量小到可以忽略的程度即可近似认为 FM 信号具有有限带宽。通常原则为信号的频带宽度应包括幅度大于未调载波的 10%以上的边频分量。根据经验，当 时，选取边频数 即可，因为大于 的边频幅度均小于 0.1。根据这个经验，FM 信号的有效带宽为：这个公式即为卡森公式。 2 FM 调制方法2.1 直接调频法直接调频法是用调制信号 直接控制高频振荡器，让回路元件的参数发生改变，使其输出频率按调制信号的规律线性地变化，常用的元件是变容二极管。直接调频法的主要优点是在实现线性调频的要求下，可以获得较大的频偏，且实现电路简单；主要缺点是频率稳定度不高，往往需要采用自动频率控制系统来稳定中心频率。 2.2 间接调频法间接调频法又被称为倍频法。先将调制信号积分，然后对载波进行调相，产生一个 NBFM 信号，再经过 次倍频器得到 WBFM 信号。优点是频率稳定性高，缺点是需要多次倍频和混频，电路复杂。 2.3 正交调制法将式（1）进行三角展开，可得：流程如下： 对调制信号 进行积分，得到 对积分后的信号分别取余弦和正弦，得到 I 路数据 与 Q 路数据 分别乘上载波 与 后相加，即可得到 FM 信号 3 FM 信号格式我国的 FM 系统的调制频偏为 150kHz，分布在 87MHz-107.9MHz 频段。其中基带信号为 MPX 信号，包含了单声道（0-15kHz），导频（19kHz），立体声副载波（中心频率 38kHz），RDS 数据（中心频率 58kHz）。其频谱成分如下： 4 Matlab 仿真基带信号的频率为 10kHz，采样率 1MHz，载波频率 100MHz，采样率 400MHz，最大频偏为 75kHz。 4.1 基带信号生成123456fs_bb=1e6;f_bb=10e3;t_bb=0:1/fs_bb:0.001;signal_bb=1*cos(2*pi*f_bb*t_bb);plot(t_bb,signal_bb);xlabel('基带信号'); 4.2 FM正交调制12345678910fs_rf=400e6;fc=100e6;f_dev=75e3;kf=f_dev/1;phase_fm_bb=2*pi*kf*cumsum(signal_bb)/fs_bb;I=cos(phase_fm_bb);Q=sin(phase_fm_bb);plot(t_bb,I);title('I路信号'); plot(t_bb,Q); title(‘Q路信号’); 123456789101112% 对基带信号重采样L=fs_rf/fs_bb;I_up=resample(I,fs_rf,fs_bb);Q_up=resample(Q,fs_rf,fs_bb);t_rf=(0:length(I_up)-1)/fs_rf;fc_I=cos(2*pi*fc*t_rf);fc_Q=-sin(2*pi*fc*t_rf);s_I=I_up.*fc_I;plot(t_rf,s_I);title('I路信号'); 123s_Q=Q_up.*fc_Q;plot(t_rf,s_Q);title('Q路信号'); ​ s_fm=s_I+s_Q; plot(t_rf,s_fm); 4.3 FFT频谱分析123456789Nfft=2^20;s_shift=fftshift(fft(s_fm,Nfft));f=(-Nfft/2:Nfft/2-1)*(fs_rf/Nfft);plot(f/1e6,20*log10(abs(s_shift)/max(abs(s_shift))));xlabel('Frequency (MHz)');ylabel('Magnitude (dB)');title('FM 信号频谱');%xlim([99.8 100.2]); % 放大到载波附近grid on; 123456plot(f/1e6,20*log10(abs(s_shift)/max(abs(s_shift))));xlabel('Frequency (MHz)');ylabel('Magnitude (dB)');title('FM 信号频谱（部分展开）');xlim([99.8 100.2]); % 放大到载波附近grid on;","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"C++学习","slug":"C++学习","date":"2025-07-21T16:00:00.000Z","updated":"2025-08-07T02:41:38.661Z","comments":true,"path":"2025/07/22/C++学习/","permalink":"https://www.moerjielovecookie.icu/2025/07/22/C++%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1 命名空间命名空间可作为附加信息来区分不同库中相同名字的函数、类、变量等，本质上命名空间定义了一个范围。 1.1 定义命名空间使用关键字namespace，后跟命名空间的名称。 1234namespace ns_name{ //code} 调用该命名空间内的函数或变量等，如下： 1ns_name::code; 2 类定义类需要关键字class，然后指定类的名称，类的主体包含在一对花括号内，主体包含类的成员变量和成员函数。 2.1 访问数据成员使用 . 来访问类中的变量。 2.2 类访问修饰符数据封装是面向对象编程重要特点之一，防止函数直接访问类内部成员。类成员访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。成员和类的默认访问修饰符是 private。 2.2.1 public公有成员变量在程序中不需要使用任何成员函数即可设置和获取值。 2.2.2 private私有成员在类的外部是不可访问的，只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的。实际操作中，一般在私有区域定义数据，在公有区域定义相关函数，便于在类的外部也可以访问数据。 2.2.3 protectedprotected 成员与 private 成员类似，但 protected 成员在派生子类中是可访问的。 2.2.4 继承中的特点 private成员只能被本类成员和友元访问，不能被派生类访问 protected成员可以被派生类访问 3 函数3.1 sprintf3.1.1 描述int sprintf(char str, const char format, ...)发送格式化输出到 str 指向的字符串。 3.1.2 声明1int sprintf(char *str, const char *format, ...) 3.1.3 参数 str：指向一个字符数组的指针 format：字符串，包含了要被写入 str 的文本 3.2 .c_str () .c_str() 是 std::string 提供的函数 返回一个指向以 NULL 结尾的 const char C*风格的字符串 不复制字符串，只提供内部数据指针 12std::string s = \"hello\";const char* p = s.c_str(); // p 指向 \"hello\\0\" 4 关键字4.1 virtual 虚函数虚函数允许子类重写它，从而在运行时通过基类指针或引用调用子类的重写版本，实现动态绑定。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。特点 在基类中可以有实现。通常虚函数在基类中提供默认实现，但派生类可以选择重写","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"}]},{"title":"天线相关","slug":"天线相关","date":"2025-07-17T16:00:00.000Z","updated":"2025-08-03T03:04:31.225Z","comments":true,"path":"2025/07/18/天线相关/","permalink":"https://www.moerjielovecookie.icu/2025/07/18/%E5%A4%A9%E7%BA%BF%E7%9B%B8%E5%85%B3/","excerpt":"","text":"1 天线最佳辐射长度1.1 垂直单极天线对于理想直立天线，其最佳辐射效率在长度约为即天线长度为电磁波波长的 时，辐射效率最佳。 半波振子天线 全波天线 补充一个接地的垂直天线，在长度为 时，天线顶端电压最大，电流为 0，基座电流最大，是最理想的辐射点 2 天线加载通过在天线上加载，拉长天线的电长度，从而使用物理长度更短的天线。本质是调节天线的谐振条件。 2.1 感性加载 用于短于 的天线，补偿其电抗部分的容性特性 在天线适当位置串入电感，通常在接近底部或中部 短于 的天线呈现容性（电抗为负），加入电感（正电抗）补偿，使得天线达到谐振 2.2 容性加载 用于使天线等效长度增加 在天线顶端增加电容结构 提高天线顶端电压，增加辐射效率，降低天线对地的电抗，提高电流分布的拉伸效果 项目 感性加载 容性加载 原因 补偿短天线的容性 增强端电压，提高效率 位置 底部/中部串联 顶部并联/加载“电容帽” 作用 实现谐振 电气延长长度 常见应用 短波鞭状天线 移动台、车载天线等 加载位置的影响 底部加载：对电流影响小，所需电感值大，效率较低 中部加载：效率较好，结构复杂 顶部加载：辐射效率最佳，但结构复杂，风阻大","categories":[{"name":"射频","slug":"射频","permalink":"https://www.moerjielovecookie.icu/categories/%E5%B0%84%E9%A2%91/"}],"tags":[{"name":"射频","slug":"射频","permalink":"https://www.moerjielovecookie.icu/tags/%E5%B0%84%E9%A2%91/"}]},{"title":"阻塞赋值和非阻塞赋值","slug":"阻塞赋值和非阻塞赋值","date":"2025-07-08T08:15:45.000Z","updated":"2025-07-08T08:15:45.000Z","comments":true,"path":"2025/07/08/阻塞赋值和非阻塞赋值/","permalink":"https://www.moerjielovecookie.icu/2025/07/08/%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC/","excerpt":"","text":"1 阻塞和非阻塞的区别1.1 阻塞赋值“&#x3D;”必须是阻塞赋值完成后，才进行下一条语句的执行；赋值一旦完成，等号左边的变量值立即变化。在同一个块中，阻塞赋值表达式的书写顺序会影响赋值的结果。硬件没有对应的电路。 即串行赋值，语句从上到下顺序执行，立即生效 1.2 非阻塞赋值“&lt;&#x3D;”在赋值开始时计算表达式右边的值，在本次仿真周期时钟的下降沿时才更新被赋值变量，即赋值不是立即生效的；非阻塞赋值允许块中其他语句同时执行。在同一个块中，非阻塞赋值表达式的书写顺序不影响赋值的结果。硬件有对应的电路。 并行执行，不是立即生效，语句同时执行 2 总结阻塞赋值对应的硬件电路与时钟触发沿没有关系，只和输入的电平变化有关；阻塞赋值对应触发器，只有触发沿才会发生赋值。 时序电路建模时，用非阻塞赋值 锁存器建模时，用非阻塞赋值 在 always 块中建立组合逻辑时，用阻塞赋值 在同一个 always 块中建立时序和组合逻辑时，用非阻塞 在同一个 always 块中不能既用阻塞又用非阻塞 不要在一个以上的always块中为同一个变量赋值 赋值时不能延时","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"航插命名规范","slug":"航插命名规范","date":"2025-07-07T16:00:00.000Z","updated":"2025-07-15T01:12:50.298Z","comments":true,"path":"2025/07/08/航插命名规范/","permalink":"https://www.moerjielovecookie.icu/2025/07/08/%E8%88%AA%E6%8F%92%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/","excerpt":"","text":"1 599GJB599III系列高低频集成化连接器 2 Y11Y11系列圆形电连接器","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://www.moerjielovecookie.icu/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"有限字长效应","slug":"有限字长效应","date":"2025-07-05T16:00:00.000Z","updated":"2025-07-15T01:13:19.486Z","comments":true,"path":"2025/07/06/有限字长效应/","permalink":"https://www.moerjielovecookie.icu/2025/07/06/%E6%9C%89%E9%99%90%E5%AD%97%E9%95%BF%E6%95%88%E5%BA%94/","excerpt":"","text":"数字信号处理的实质为数值运算。运算过程中，系统中的系数、输入输出等都要以二进制的形式存储在有限长的存储单元中，此时有限长度的数的精度就是有限的。具体实现中可能会产生误差。在数字系统中因有限字长引起误差的因素主要为以下三种： AD 转换器把模拟输入信号转换成一组离散电平时产生的量化效应。 把系数用有限位的二进制数表示时产生的量化效应。 在运算过程中，为限制字长而进行的截断操作和防止溢出而压缩信号电平的有限字长效应。 1 AD 转换的有限字长效应AD 转换器可分为两部分：采样和量化。采样将连续的模拟信号转为离散信号，量化将每个采样值用有限字长表示。其统计意义上的等价结构如图所示：量化后的取值可以表示为精确取样值和量化误差的和，即这一模型基于以下假设： 是一个平稳随机取样序列 具有等概分布特性 具有白噪声过程 与 不相关由于 具有等概分布，舍入误差、补码截尾、原码截尾的概率分布如下所示： 舍入时，均值为 0，方差为 补码截尾时，均值为 ，方差为 原码截尾时，均值为 0，方差为 量化信噪比的表达式为可得舍入后，字长每增加 1 位，SNR 约增加 6dB。 2 系统运算中的有限字长效应对于二进制运算来讲，定点数的加法不会改变字长，但可能造成数据溢出。定点数的乘法存在字长效应，因为 2 个 B 位字长的定点数相乘，要保留所有有效位的话需要 2B 位字长的数据，数据截尾或舍入必然会引入字长效应。如果在计算过程中增加字长来保证运算结果不产生截尾和舍入的话，耗费资源变多，在没有反馈的系统中可以如此操作。如果在有反馈网络的系统中，如数字滤波器，每次闭环运算都会增加一部分字长，循环运算下来需要的资源越来越多。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"设备相关参数","slug":"设备相关参数","date":"2025-06-19T16:00:00.000Z","updated":"2025-07-15T01:14:06.274Z","comments":true,"path":"2025/06/20/设备相关参数/","permalink":"https://www.moerjielovecookie.icu/2025/06/20/%E8%AE%BE%E5%A4%87%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/","excerpt":"","text":"1 频谱仪 RBW（Resolution Bandwidth） 和 VBW（Video Bandwidth）1.1 RBW 和 VBW 的定义1.1.1 RBWRBW是频谱仪中频滤波器（IF滤波器）的3dB带宽，决定了区分两个相邻频率信号的最小间隔。 1.1.1.1 作用 频率分辨率：RBW 越小，分辨相邻信号的能力越强。 底噪影响：RBW 增加 10 倍，底噪抬高 10dB。计算公式为：，减小 RBW 可提升弱信号检测能力。 扫描时间：与 成反比。 1.1.2 VBWVBW 指频谱仪中的平滑滤波器带宽，用于平滑显示频谱图形，以消除噪声和杂散信号的干扰，使信号更易于观察和分析。VBW 通常比 RBW 大，以确保频谱图形的平滑显示。 1.1.2.1 作用 噪声平滑：VBW减小可降低显示噪声的波动（例如VBW缩小√10倍，噪声波动减少约1dB），使曲线更光滑。 相应速度：VBW 不影响 RBW，但是过小会掩盖快速变化的信号细节。 2 贴片 LED 压降贴片LED的压降和工作电流因颜色、封装尺寸及制造工艺而异，以下是常见颜色参数的综合整理： 2.1 不同颜色贴片LED的压降与工作电流 LED颜色 压降范围 (V) 工作电流范围 (mA) 典型应用场景 红色 1.82–1.88 5–8 指示灯、低功耗显示 绿色 1.75–1.82 3–5 低亮度指示、节能设备 橙色 1.7–1.8 3–5 警示灯、状态指示 蓝色 3.1–3.3 8–10 背光、高亮度显示 白色 3.0–3.2 10–15 照明、显示屏背光 2.2 关键参数说明 压降（正向电压） 指LED导通时两端的电压差，由半导体材料的能隙决定。 规律：红光/黄光压降最低（约1.8V），蓝光/白光最高（约3.2V）。 同颜色LED的压降可能存在±10%的偏差，因制造工艺差异。 工作电流 标准范围：小功率贴片LED（如0603、0805封装）通常为3–15mA。 电流与亮度：电流越大亮度越高，但超额定值会缩短寿命（如红光＞20mA可能烧毁）。 最小启动电流：0603封装LED可低至0.1mA，但需2–5mA才能达到可见亮度。 2.3 实际设计注意事项 限流电阻计算 公式：电源 示例：5V电源驱动红光LED（，），电阻值 （常用680Ω）。 封装与功率 小尺寸封装（如0402、0603）：电流宜≤5mA，避免过热。 大功率LED（如3030封装）：电流可达220mA，需散热设计。 2.4 四、总结贴片LED的参数选择需平衡亮度、功耗与寿命。低电流设计（如红光5mA）可延长寿命，高亮度场景（如白光15mA）需注意散热。实际应用中建议参考具体型号的数据手册，并以实测为准。","categories":[{"name":"电子测量","slug":"电子测量","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E5%AD%90%E6%B5%8B%E9%87%8F/"}],"tags":[{"name":"测量","slug":"测量","permalink":"https://www.moerjielovecookie.icu/tags/%E6%B5%8B%E9%87%8F/"}]},{"title":"dB相关参数","slug":"dB相关参数","date":"2025-06-18T16:00:00.000Z","updated":"2025-07-15T01:13:37.843Z","comments":true,"path":"2025/06/19/dB相关参数/","permalink":"https://www.moerjielovecookie.icu/2025/06/19/dB%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0/","excerpt":"","text":"1 dB：分贝dB 是一个功率增益的单位，是 Decibel 的缩写，表示两个相同单位数值之比的对数单位。计算公式为：其中 P1 和 P2 表示两个不同功率值或信号强度值。当 P2 大于 P1 时 dB 为正，表示信号增强了，反之 dB 为负，表示信号衰减。 2 dBm：分贝毫瓦dBm是分贝毫瓦（Decibels relative to one milliwatt）的缩写，是一个表示功率绝对值的单位。它的定义是相对于1毫瓦（mW）的分贝值，即0dBm等于1毫瓦。dBm的计算公式为：其中，P 表示待测功率值，dBm 越大，表示功率越大。dBm 常用于描述发射功率、接收功率、天线增益等参数。 3 dBc：相对于载波的分贝dBc是相对于载波的分贝（Decibels relative to carrier）的缩写，用于描述在特定频率范围内的信号功率与载波功率之比。其计算公式为：其中， 表示边带功率， 表示载波功率。dBc 反应了边带信号相对于载波信号的强度，有助于评估信号的纯度、干扰情况和频谱效率。 4 dBuV根据 ，可得：当阻抗为 50Ω时，转换关系为： 关系dB 是一个相对单位，dBm 和 dBc 是绝对单位。加 3 乘 2，加 10 乘 10，减 3 除 2，减 10 除 10。","categories":[{"name":"电子测量","slug":"电子测量","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E5%AD%90%E6%B5%8B%E9%87%8F/"}],"tags":[{"name":"测量","slug":"测量","permalink":"https://www.moerjielovecookie.icu/tags/%E6%B5%8B%E9%87%8F/"}]},{"title":"TypeC接口协议","slug":"TypeC","date":"2025-06-11T16:00:00.000Z","updated":"2025-07-15T01:13:07.386Z","comments":true,"path":"2025/06/12/TypeC/","permalink":"https://www.moerjielovecookie.icu/2025/06/12/TypeC/","excerpt":"","text":"Type-C插头常见的pin数有6P、12P、16P、24P，不同pin数在功能、应用场景和成本等方面存在区别，以下为你详细介绍： 1 引脚定义Type-C接口插头引脚功能定义如下： Pin 名称 功能描述 A1 GND 接地 A2 SSTXp1 SuperSpeed差分信号#1，TX，正 A3 SSTXn1 SuperSpeed差分信号#1，TX，负 A4 VBUS 总线电源 A5 CC1 Configuration channel，用于检测设备连接、正反插方向，以及进行USB Power Delivery通信 A6 Dp1 USB 2.0差分信号，position 1，正 A7 Dn1 USB 2.0差分信号，position 1，负 A8 SBU1 Sideband use (SBU)，用于传输非USB信号，如音频信号等 A9 VBUS 总线电源 A10 SSRXn2 SuperSpeed差分信号#2，RX，负 A11 SSRXp2 SuperSpeed差分信号#2，RX，正 A12 GND 接地 B1 GND 接地 B2 SSTXp2 SuperSpeed差分信号#2，TX，正 B3 SSTXn2 SuperSpeed差分信号#2，TX，负 B4 VBUS 总线电源 B5 CC2 Configuration channel B6 Dp2 USB 2.0差分信号，position 2，正 B7 Dn2 USB 2.0差分信号，position 2，负 B8 SBU2 Sideband use (SBU) B9 VBUS 总线电源 B10 SSRXn1 SuperSpeed差分信号#1，RX，负 B11 SSRXp1 SuperSpeed差分信号#1，RX，正 B12 GND 接地 2 不同pin数Type-C插头的区别 6P Type-C 功能：仅保留了Vbus、GND、CC1、CC2。Vbus用于供电，GND用于接地，CC1和CC2用于PD设备识别，承载USB - PD的通信，以向供电端请求电源供给。它没有USB 2.0的D+、D - 差分信号和USB 3.0的高速传输功能。 应用场景：适用于对USB通信无需求，仅需USB取电充电的设备，如玩具、电动牙刷、快充插头等。 成本：由于引脚数量少，生产工艺相对简单，成本较低。 12P Type-C 功能：在6P的基础上增加了数据DP1/2，DN1/2，SBU1/2。DP1/2和DN1/2用于USB 2.0通信，可实现数据传输；SBU1/2用于传输非USB信号，如音频信号等。它支持PD快充、音频设备、HDMI传输、调试模式等功能，但缺少USB 3.0/3.1的高速传输能力。 应用场景：常用于一些对数据传输速度要求不高，但需要支持多种功能的小家电设备，这类设备使用的MCU通常只有USB 2.0，USB 3.0功能对其而言并非必要。 成本：相比24P，省去了部分引脚和相关电路，成本有所降低，但高于6P。 16P Type-C 功能：在24Pin的基础上阉割了USB3.0的TX1/2、RX1/2，保留了SBU1/2、CC1/2、USB2.0的D+、D - 。除不具备USB 3.0/3.1高速传输外，其他功能与24P基本相同，同样支持PD快充、音频设备、HDMI传输、调试模式等。 应用场景：适用于对高速数据传输需求不高的设备，能在满足基本功能的同时，控制成本。 24P Type-C 功能：是全功能的Type-C接口，具有12P引脚所具有的全部功能，并且多了USB 3.0/3.1高速传输功能。其D+/D - 提供了对USB 2.0数据传输差分对的兼容，有两组D+/D - 差分对以支持正反插；GND和VBUS分别用于提供地信号和电源信号，默认VBUS电压是5V，可通过协商支持更高电压和电流；RX和TX分开，可实现上行和下行的全双工通信；CC引脚用于插拔检测、正反插方向检测、source端的电流支持能力播报，以及在PD快充和alternate mode中使用；VCONN为Type - C Cable里面所包含的EMarker芯片供电。 应用场景：广泛应用于各类需要高速数据传输和多种功能支持的电子设备，如智能手机、平板电脑、笔记本电脑、显示器等。 成本：由于引脚数量多，功能丰富，其接口的采购成本相对较高。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"","slug":"template/blog_template","date":"2025-05-18T12:32:10.702Z","updated":"2025-01-20T04:00:26.000Z","comments":true,"path":"2025/05/18/template/blog_template/","permalink":"https://www.moerjielovecookie.icu/2025/05/18/template/blog_template/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"STM32F407学习","slug":"STM32F407学习","date":"2025-05-07T16:00:00.000Z","updated":"2025-07-14T11:43:22.054Z","comments":true,"path":"2025/05/08/STM32F407学习/","permalink":"https://www.moerjielovecookie.icu/2025/05/08/STM32F407%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1 STM 32 相关外设接口学习1.1 GPIOSTM 32 F 4 每组通用 GPIO 口由 7 个 32 位的寄存器控制，包括： 4 个 32 位配置寄存器（MODER、OTYPER、OSPEEDR、PUPDR） 2 个 32 位数据寄存器（IDR、ODR） 1 个 32 位置位、复位寄存器（BSRR） 1 个 32 位锁定寄存器（LCKR） 2 个 32 位复用功能选择寄存器（AFRH、AFRL） 1.1.1 寄存器1.1.1.1 GPIO 端口模式寄存器（GPIOx_MODER）(x=A.. I)用于控制 GPIO 的工作模式每组 GPIO 下有 16 个 IO 口，两个寄存器位控制 1 个 IO。PortA 的复位值是 0 xA 800 0000，对应的二进制为 1010 1000 0000 0000 0000 0000 0000 0000，可知 PA 15/14/13 都为复用功能模式，其余端口为输入模式。 1.1.1.2 GPIO 端口输出类型控制器（GPIOx_OTYPER）用于控制 GPIO 的输出类型。在输入模式下不起作用。低 16 位有效。默认输出模式下 IO 口为推挽输出。 1.1.1.3 GPIO 端口输出速度寄存器（GPIOx_OSPEEDR）也只用于输出模式。 1.1.1.4 GPIO 端口上拉/下拉寄存器（GPIOx_PUPDR） 00：无上拉下拉 01：上拉 10：下拉 11：保留 1.1.1.5 GPIO 输入数据寄存器（GPIOx_IDR） 1.1.1.6 GPIO 输出数据寄存器（GPIOx_ODR） 1.1.1.7 GPIO 端口置位/复位寄存器（GPIOx_BSRR） 1.2 ADCSTM 32 F 4 拥有 3 个可独立使用的ADC，其中 ADC 1 和 ADC 2 可以组成双重模式以提高采样率。STM 32 的 ADC 是 12 位逐次逼近型的 ADC。包含 19 个通道，可测量 16 个外部和 2 个内部信号源以及 Vbat 通道的信号。这些通道的 A/D 转换可在单次、连续、扫描、不连续采样模式下进行。转换后的结果存储在一个 LSB 或 MSB 的 16 位数据寄存器中。 1.2.1 主要特性 可配置 12 位、10 位、8 位、6 位分辨率 在转换结束、注入转换结束、发生模拟看门狗或溢出时产生中断 单次和连续转换模式 数据对齐以保证内置数据的一致性 独立设置各通道采样时间 不连续采样模式 ADC 电源：全速运行时为 2.4 V 到 3.6 V，慢速运行时为 1.8 V ADC 输入范围： 规则通道转换期间可产生 DMA 请求 1.2.2 转换顺序当任意 ADCx 多通道以任意顺序进行一系列转换时就诞生了成组转换，有两种成组转换类型：规则组和注入组。规则组最多允许16个输入通道进行转换，注入组允许最多4个输入通道进行转换。 1.2.2.1 规则组按照一定的顺序成组转换，常用。 1.2.2.2 注入组“注入”即为打破原来的状态，相当于中断。如果在规则组转换的过程中，注入组启动，则注入组转换完成后规则组才继续转换。 1.2.2.3 转换速率ADC 转换时间计算公式为采样时间由 ADC_SMPR 寄存器进行控制。ADC_CLK 由 APB 2 分配产生，分频系数由 RCC_CFGR 寄存器中的 PPRE 2 进行设置，2/4/6/8/16 分频选项。 寄存器Timer定时器的基本特性表如下： SPISPI 全称为 Serial Peripheral interface，串行外围设备接口。SPI 的结构框图如下：SPI 的引脚信息为 MISO（Master In / Slave Out）：主设备数据输入，从设备数据输出。 MOSI（Master Out / Slave In）：主设备数据输出，从设备数据输入。 SCLK（Serial Clock）：时钟信号，主设备输出。 CS（Chip Select）：从设备片选信号，主设备输出。==工作原理==：在进行 SPI 通信的从机和主机中都有一个 Shift Register，主机通过向它本身的移位寄存器写入一个 Byte 的数据发起一次传输。移位寄存器通过 MOSI 将字节传输给从机，同时从机将字节的移位寄存器中的内容通过 MISO 传输到主机，这样即可实现两个移位寄存器中的数据交换。因此，如果只进行写操作，主机忽略接收到的数据即可，如果主机想要读取从机的数据，则发送一个空字节引发从机传输。SPI 支持全双工、半双工、单工传输方式。 SPI 工作模式SPI 的工作模式由 CPOL 和 CPHA 决定，它们都有 0、1 两种状态，因此 SPI 有四种工作模式。 工作模式 CPOL CPHA SCL 空闲状态 采样边沿 采样时刻 0 0 0 低电平 上升沿 奇数边沿 1 0 1 低电平 下降沿 偶数边沿 2 1 0 高电平 下降沿 奇数边沿 3 1 1 高电平 上升沿 偶数边沿 由表可知，CPOL 决定 SCL 空闲状态时为高电平还是低电平，CPHA 决定是在时钟的奇数边沿采样还是在偶数边沿采样。 SPI 寄存器SPI_CR 1（SPI 控制寄存器 1） Bit 11 DFF：数据帧格式，0：8 位数据帧，1：16 位 Bit 10 RXONLY：只接收。0：全双工，1：只接收 Bit 7：帧格式。0：先发送 MSB，1：先发送 LSB。通信时不应该修改此位 Bit 6：SPI 使能。0：关闭外设，1：使能外设。 Bit 5-3：BR[2:0]：控制波特率。 Bit 2：主模式选择。0：从模式，1：主模式 Bit 1：CPOL Bit 0：CPHA SPI_SR（SPI 状态寄存器） 15-9 位保留，强制为 0 Bit 8：帧格式错误。0：无帧格式错误，1：有帧格式错误 Bit 7：忙标志。0：未处于忙状态，1：SPI 处于通信状态或者 Tx buffer 不空 Bit 1：发送 buffer 空。0：非空，1：空 Bit 0：接收 buffer 非空。0：空，1：不空 SPI_DR（SPI 数据寄存器）当数据帧为 8 位时只使用低八位，16 位时使用整个寄存器","categories":[{"name":"MCU","slug":"MCU","permalink":"https://www.moerjielovecookie.icu/categories/MCU/"}],"tags":[{"name":"MCU","slug":"MCU","permalink":"https://www.moerjielovecookie.icu/tags/MCU/"}]},{"title":"Pluto SDR入门记录","slug":"Pluto SDR入门记录","date":"2025-04-30T16:00:00.000Z","updated":"2025-05-01T09:44:59.000Z","comments":true,"path":"2025/05/01/Pluto SDR入门记录/","permalink":"https://www.moerjielovecookie.icu/2025/05/01/Pluto%20SDR%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"运放选型","slug":"运放选型","date":"2025-04-27T12:28:32.000Z","updated":"2025-07-14T09:45:06.193Z","comments":true,"path":"2025/04/27/运放选型/","permalink":"https://www.moerjielovecookie.icu/2025/04/27/%E8%BF%90%E6%94%BE%E9%80%89%E5%9E%8B/","excerpt":"","text":"在使用OP07设计单路运放时，设计目标为将100K到1M的1V峰峰值的正弦波放大2倍，但是测试过程中发现100K频率下输出的波形类似三角波，数据手册说OP07的增益带宽积为0.5MHz，正常来说100K的频率下2倍增益是没问题的。 但是数据手册又说OP07的压摆率Slew Rate为0.3V&#x2F;us，那么根据设计目标可以计算得出运放的压摆率至少要到6.28V&#x2F;us，可以看到OP07的压摆率完全不够，因此波形会失真。 当使用正负5V供电时，AD8051的压摆率最小值在105V&#x2F;us，，因此可以满足设计要求。","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"Quartus报错记录","slug":"Testbench仿真脚本编写指北","date":"2025-04-27T12:28:31.000Z","updated":"2025-07-14T12:13:53.769Z","comments":true,"path":"2025/04/27/Testbench仿真脚本编写指北/","permalink":"https://www.moerjielovecookie.icu/2025/04/27/Testbench%E4%BB%BF%E7%9C%9F%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%8C%87%E5%8C%97/","excerpt":"","text":"[!note]由于 Quartus 的 VWF 仿真只能仿真很短的时间，而且 Vivado 仿真的时候也需要添加激励信号，因此需要编写 testbench 文件进行激励仿真。 Testbench 文件结构编写 testbench 的目的是为了测试 module 的功能、性能是否符合设计的预期。验证设计的功能包括以下步骤： 产生合适的激励波形：该激励通常要覆盖被测 HDL 模块所有可能产生的输入状态； 将产生的激励信号加入到 DUT 中并观察其响应：即将 DUT 模块例化的 Testbench 中，运行仿真测试； 将输出的响应与期望值比较。Testbench 的结构一般模块如下：&#96;&#96; 12345678module Test_bench_name();// 01:信号或变量声明定义// --逻辑设计中输入对应 reg 型// --逻辑设计中输出对应 wire 型// 02:使用 ini[ti](https://bbs.elecfans.com/group_715)al 或 always 语句产生激励// 03:例化待测试DUT模块// 04:监控和比较输出响应endmodule 代码示例时钟激励输入示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*----------------------------------------------------------------时钟激励产生方法一：50%占空比时钟----------------------------------------------------------------*/parameter ClockPeriod=10; //参数化时钟周期initial begin clk_i=0; forever#(ClockPeriod/2) clk_i = ~clk_i;end/*----------------------------------------------------------------时钟激励产生方法二：50%占空比时钟----------------------------------------------------------------*/initialbegin clk_i=0;endalways #(ClockPeriod/2) clk_i=~clk_i;/*----------------------------------------------------------------时钟激励产生方法三：产生固定数量的时钟脉冲----------------------------------------------------------------*/parameter ClockPeriod=10; //参数化时钟周期initialbegin clk_i=0; repeat(6) #(ClockPeriod/2) clk_i=~clk_i;end/*----------------------------------------------------------------时钟激励产生方法四：产生非占空比为 50%的时钟----------------------------------------------------------------*/parameter ClockPeriod=10; //参数化时钟周期initialbeginclk_i=0;forever begin #((ClockPeriod/2)-2) clk_i=0; #((ClockPeriod/2)+2) clk_i=1; endend 复位激励输入示例12345678910111213141516171819202122232425262728293031323334353637/*---------------------------------------------------------------- 复位信号产生方法一：异步复位----------------------------------------------------------------*/initialbegin [rs](https://www.elecfans.com/tags/rs/)t_n_i=1; #100; rst_n_i=0; #100; rst_n_i=1; end/*---------------------------------------------------------------- 复位信号产生方法二：同步复位----------------------------------------------------------------*/initialbegin rst_n_i=1; clk_i = 0; @（negedge clk_i) rst_n_i=0; #100; //固定时间复位 repeat(10) @（negedge clk_i); //固定周期数复位 @（negedge clk_i) rst_n_i=1; endalways #5 clk_i=~clk_i;/*---------------------------------------------------------------- 复位信号产生方法三：复位任务封装----------------------------------------------------------------*/task reset;input [31:0] reset_time; //复位时间可调，输入复位时间 RST_ING=0; //复位方式可调，低电平或高电平 begin rst_n=RST_ING; //复位中 #reset_time; //复位时间 rst_n_i=~RST_ING; //撤销复位，复位结束 endendtask 仿真控制语句和系统任务描述&#96;&#96; 1234567891011121314/*---------------------------------------------------------------- 仿真控制语句及系统任务描述----------------------------------------------------------------*/$stop // 停止运行仿真，modelsim 中可继续仿真$stop(n) //带参数系统任务，根据参数 0,1或2不同，输出仿真信息$finish //结束运行仿真，不可继续仿真$finish(n) //带参数系统任务，根据参数 0,1或2不同，输出仿真信息//0:不输出任何信息//1:输出当前仿真时刻和位置//2:输出当前仿真时刻、位置和仿真过程中用到的 memory 以及 CPU 时间的统计$random //产生随机数$random % n //产生范围-n 到 n 之间的随机数&#123;$random&#125; % n //产生范围 0 到 n 之间的随机数/*---------------------------------------------------------------- 文本读取12345678910/*---------------------------------------------------------------- 文本输入方式：$readmemb/$readmemh----------------------------------------------------------------*/$readmemb/$readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;);$readmemb/$readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;,&lt;起始地址&gt;);$readmemb/$readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;,&lt;起始地址&gt;,&lt;结束地址&gt;);$readmemb:/*读取二进制数据，读取文件内容只能包含：空白位置，注释行，二进制数数据中不能包含位宽说明和格式说明，每个数字必须是二进制数字。*/$readmemh:/*读取十六进制数据，读取文件内容只能包含：空白位置，注释行，十六进制数数据中不能包含位宽说明和格式说明，每个数字必须是十六进制数字。*/","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"多速率信号处理-CIC滤波器","slug":"多速率信号处理-CIC滤波器","date":"2025-04-27T12:28:31.000Z","updated":"2025-07-14T12:12:40.199Z","comments":true,"path":"2025/04/27/多速率信号处理-CIC滤波器/","permalink":"https://www.moerjielovecookie.icu/2025/04/27/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-CIC%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"","text":"1 基本原理级联积分梳状滤波器（Cascade Intergrator Comb）是多速率信号处理中一种十分高效的数字滤波器。CIC滤波器具有低通滤波器的特性，同时具有以下优势： 滤波器系数全为1，设计时不需要存储滤波器系数，节省存储单元，同时使得滤波时只需要加法器和累加器，不需要乘法器 结构规则，可灵活设置插值因子而不影响整体结构 1.1 积分器积分器结构为 时域上可表示为 频域上可表示为 可得积分器的幅度谱为 从公式可以得出积分器只有极点，为整数而无零点，且对直流信号具有无限大的增益。 1.2 梳状滤波器时域上可表示为 其中 R 是插值因子或抽取因子 M 是微分时延 频域上可表示为 幅度谱为 可知梳状滤波器只有零点，没有极点 若R=8、M=1，则结构为 由此可知单级CIC滤波器的幅度谱为 当时，即时可以确定零点 当，即时，可得此时的幅频响应为 从而实现了零极点相消 单级CIC滤波器在时，所以主瓣区间为，其余都为旁瓣，第一旁瓣电平为 因此旁瓣抑制为 当时，旁瓣抑制为 单级CIC滤波器的阻带衰减为 带内容差（通带波纹）为 其中b为带宽比例因子 单级CIC滤波器的旁瓣电平较高，可通过多级CIC级联改善。 对于N级CIC级联滤波器，旁瓣抑制、阻带衰减、带内容差可表示为 增大CIC滤波器阶数的话，可以增加旁瓣抑制和阻带衰减，但是会导致带内容差变大。因此考虑到通带性能，通常选择。在N不变的情况下，带宽比例因子b越小，CIC滤波器的通带和阻带特性也越好，因此CIC一般位于插值系统的最后一级（输入速率最高） 2 位增长问题由多级滤波器的幅频响应可知，当时 由此可知多级CIC滤波器可以引起的幅度增益的最大值为 假设输入的数据为有符号数，位宽为，取值范围为，则输出的最大值为 因此输出的最大位宽为 在FPGA设计时，要合理地设置输出信号的位宽，防止数据的溢出，为了节省资源，也可以在每一级适当的进行截位 3 Matlab设计CIC补偿滤波器由于CIC滤波器通带内不平坦，因此需要在前级加入CIC补偿滤波器。Matlab中的对应函数为**fdesign.ciccomp，**语法如下 1234d = fdesign.ciccompd = fdesign.ciccomp(d,nsections,rcic)d = fdesign.ciccomp(...,spec)h = fdesign.ciccomp(...,spec,specvalue1,specvalue2,...) 其中梳状滤波器的延时长度为d，滤波器阶数为nsections，CIC速率转化因子为rcic。 3.1 example1234h = fdesign.ciccomp;set(h,NumberOfSections=5,DifferentialDelay=1);cicComp = design(h,'equiripple',SystemObject=true);filterAnalyzer(cicComp)","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"C语言知识复习","slug":"C语言知识复习","date":"2025-04-18T16:00:00.000Z","updated":"2025-07-14T11:56:02.008Z","comments":true,"path":"2025/04/19/C语言知识复习/","permalink":"https://www.moerjielovecookie.icu/2025/04/19/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"C 语言教程 | 菜鸟教程 1 Vscode 编译调试 C 代码由于 vscode 只是一个文本编辑器，因此需要配置 task.json 和 launch.json 来完成编译和调试的工作。（笔者的 C 环境基于 WSL 2（Ubuntu-20.04）搭建）task.json 如下： 1234567891011121314151617181920212223{ \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Build C Program\", \"type\": \"shell\", \"command\": \"gcc\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"problemMatcher\": [ \"$gcc\" ] } ]} version：指定配置格式版本，当前仅支持 \"2.0.0\"。 tasks：任务数组，每个元素对应一个可执行任务。 label：任务名称，用于引用（如 preLaunchTask）和在 UI 列表中显示。 type：任务类型，常见值 \"shell\"（在 shell 中运行）或 \"process\"（直接启动可执行文件）。 command：要执行的命令或程序名称。 args：传递给命令的参数列表，可使用内置变量插值。 \"-g\"：生成调试符号，便于 GDB 等调试器进行源码级调试。 \"${file}\"：当前活动编辑器中打开的文件的完整路径（如 /home/user/main.c）。 \"-o\"：GCC 的输出重定向选项，指定后续输出文件路径。 \"${fileDirname}/${fileBasenameNoExtension}\"：将可执行文件输出到源文件同目录，文件名与源文件同名但无扩展名（如输出 /home/user/main）。 group：将任务归类（如 build、test），并可标记为默认组内任务。 problemMatcher：指定如何解析命令输出，将编译器错误/警告映射到“问题”面板。 launch.json 如下： 1234567891011121314151617181920{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"WSL Debug C\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}\", \"args\": [], \"stopAtEntry\": true, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"/usr/bin/gdb\", \"miDebuggerArgs\": \"--nx\", \"preLaunchTask\": \"Build C Program\" } ]} 2 C 语言作用域作用域是程序中定义的变量所存在的区域，超出该区域后变量就不能被访问。C 语言的变量有三种： 在函数内部的局部变量 在所有函数外部的全局变量 在形式参数的函数参数定义 2.1 局部变量在某个函数或者块内部声明的变量称为局部变量。他们只能被该函数或代码块内部的语句访问，在函数或块外部是不可知的。 2.2 全局变量全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。 如果局部变量和全局变量的名字相同的话，在函数内优先使用局部变量。 2.3 形式参数函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。 3 指针指针即为内存地址，指针变量是用来存放内存地址的变量，使用前必须声明。 1type *var_name; type 为指针的基类型，var_name 为指针变量的名称，以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 不同类型的指针对应的指针的值的类型是一样的，都为代表内存地址的十六进制数。不同类型的指针的区别为指针指向的变量或常数的数据类型不同。 3.1 指针使用方法定义一个指针变量，把变量的地址赋给指针，访问指针变量中的地址。 1234567891011121314151617181920#include &lt;stdio.h&gt; int main (){ int var = 20; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ ip = &amp;var; /* 在指针变量中存储 var 的地址 */ printf(\"var 变量的地址: %p\\n\", &amp;var ); /* 在指针变量中存储的地址 */ printf(\"ip 变量存储的地址: %p\\n\", ip ); /* 使用指针访问值 */ printf(\"*ip 变量的值: %d\\n\", *ip ); return 0;}//参考菜鸟教程 3.2 NULL 指针指针变量声明的时候，如果没有确切的地址幅值，则可为指针变量赋一个 NULL，此时该指针被称为空指针。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"}]},{"title":"WSL2 Ubuntu-20.04LTS启动某些软件的gui时花屏","slug":"WSL2 Ubuntu-20.04LTS启动某些软件的gui时花屏","date":"2025-04-18T16:00:00.000Z","updated":"2025-05-02T13:19:10.000Z","comments":true,"path":"2025/04/19/WSL2 Ubuntu-20.04LTS启动某些软件的gui时花屏/","permalink":"https://www.moerjielovecookie.icu/2025/04/19/WSL2%20Ubuntu-20.04LTS%E5%90%AF%E5%8A%A8%E6%9F%90%E4%BA%9B%E8%BD%AF%E4%BB%B6%E7%9A%84gui%E6%97%B6%E8%8A%B1%E5%B1%8F/","excerpt":"","text":"WSL 2 安装的 Ubuntu-20.04 默认的显示管理器是 gdm。默认情况下运行 vivado 的安装程序启动 gui 后，页面发生改变时就会花屏，修改缩放也无法修复。 解决方法安装 kde，将显示管理器修改为 ssdm 后即可修复该问题。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"}]},{"title":"不同波段电磁波的特点和使用场景","slug":"不同波段电磁波的特点和使用场景","date":"2025-04-15T16:00:00.000Z","updated":"2025-04-18T04:37:32.000Z","comments":true,"path":"2025/04/16/不同波段电磁波的特点和使用场景/","permalink":"https://www.moerjielovecookie.icu/2025/04/16/%E4%B8%8D%E5%90%8C%E6%B3%A2%E6%AE%B5%E7%94%B5%E7%A3%81%E6%B3%A2%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"不同波段的电磁波在频率、波长、能量以及传播方式上各有差异，这使得它们在应用上也各有所长。下面我们将对中波、短波之外的主要电磁波波段的特点以及它们在通信或其它领域中的应用做一详细解析： 1. 超低频与极低频波段（ELF、SLF、ULF、VLF） 频率与波长特点 极低频（ELF）：通常在3~30 Hz之间，波长可达数万公里。 超低频（SLF）和特低频（ULF）：频率分别约在30–300 Hz和300–3000 Hz之间，波长仍非常长。 甚低频（VLF）：一般在3 kHz至30 kHz，波长从几十到几百公里不等。 传播特性 由于波长极长，这些频段的波能绕过地形和海水，对传播媒介（如地下和海水）有很好的穿透能力。但其数据带宽非常有限，传输速率低。 主要应用 潜艇通信：ELF和VLF能够穿透海水，适用于与潜艇进行远程低速率的指挥通信。 导航与时间信号：例如LF（低频）信号被用于传送标准时间信号和导航信息。 2. 中低频与中波（LF、MF、AM广播） 频率与波长特点 低频（LF）：一般在30 kHz～300 kHz，波长在1千米以上。 中频（MF）：约300 kHz～3 MHz，涵盖了传统的调幅（AM）广播波段，中波通信便属于此类。 传播特性 中低频段电磁波可通过地波传播，并且在夜间电离层条件较佳时可通过天波进行长距离传播，但由于波长较长，其带宽和数据传输能力相对受限。 主要应用 广播通信：AM广播以及海事、航空导航等都经常使用中低频段信号。 时间与定位信号：例如LF信号常用于一些长距离定位和时间校准系统。 3. 高频与甚高频波段（HF、VHF、UHF） 频率与波长特点 高频（HF）：3–30 MHz，波长在10米到100米左右，适合长距离的短波通信。 甚高频（VHF）：30–300 MHz，对应波长约1米到10米，多为电视、调频广播、航空通信。 特高频（UHF）：300 MHz–3 GHz，波长约为10厘米到1米，常见于移动通信、卫星广播及部分雷达系统。 传播特性 HF：利用电离层反射（天波传播），可以覆盖极远距离，但信号易受大气与电离层条件影响。 VHF和UHF：主要依赖视线传播，传输稳定，抗干扰性能较好，但传输距离受地形阻挡限制，通常用于局部或卫星通信等。 主要应用 长距离通信与业余无线电：HF频段经常用于国际通讯和业余无线电爱好者之间的跨洋联络。 广播、电视与移动通信：VHF/UHF在民用广播、手机通信、无线局域网以及卫星电视中应用广泛。 4. 微波及更高频段（SHF、EHF、THz） 频率与波长特点 微波（SHF）：3–30 GHz，波长从10毫米到1厘米左右。 极高频（EHF）：30–300 GHz，波长在1毫米到10毫米之间。 太赫兹波（THz）：介于微波与红外线之间，频率大致在0.1–10 THz，对应波长在0.03毫米到3毫米之间。 传播特性 微波和EHF信号因其短波长，主要采用视线传播，且易受大气吸收、雨衰和障碍物阻挡；但传输的带宽很宽，支持高速数据传输。 THz波虽然具有潜在极高的数据传输速率，其传播距离较短且对大气中的水汽特别敏感，因此目前主要在短距离、高速通信以及特殊成像与检测中被研究和应用。 主要应用 卫星通信、雷达和无线宽带：微波波段应用于卫星链路、雷达系统以及点对点无线通信。 数据中心与下一代无线通信：EHF、毫米波和部分THz技术正被探索用于5G/6G通信，为实现超高速、低延时数据传输提供新的途径。 成像与检测：THz波在医学成像、无损检测、食品安全与隐形检测等方面也有独特优势。 5. 红外线、可见光、紫外线以及高能射线（X射线、γ射线） 红外线 特点：波长介于0.75μm到1mm，能量比可见光低但高于微波。 应用：广泛用于光纤通信、红外热成像、夜视设备以及某些短距离高速无线光通信（例如自由空间光通信）。 可见光 特点：波长约390～750nm，是人眼可见的部分。 应用：应用于光通信（如激光通信）、光纤传输、显示技术以及一般照明。 紫外线 特点：波长范围约10–400nm，具有较高能量，部分紫外线可引起化学反应。 应用：主要在科学检测、消毒杀菌、材料分析等领域有应用，通信应用较少。 X射线与γ射线 特点：波长极短、频率极高、能量非常大。 应用：因高能量而具有极强的穿透力，主要用于医学成像（如X光检查）、工业无损检测和核物理研究，通常不用于常规通信。 总结不同电磁波波段各有其独特的传输和物理特性，因此在通信系统中各取所长： 低频和极低频波段能穿透海水和地下，适合远距离低速传输和特殊环境通信； 中频至高频（HF、VHF、UHF）波段则适于广播、短波国际通信和视线通信； 微波及其以上频段（SHF、EHF及THz）凭借宽带和高数据速率优势，正成为卫星通信、雷达、下一代无线网络的重要候选； 红外、可见光等则借助光的特性在光纤和自由空间光通信中发挥巨大作用，而紫外、X射线、γ射线则由于能量较高主要用于成像和检测领域，而非常规数据通信。 这种多波段、多模式的应用构成了现代电磁波系统的基石，同时也展示了不同技术在满足不同传输需求时的互补性。选择合适的波段时，需要权衡传播距离、数据速率、抗干扰能力及环境适应性等多个因素。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"Vivado中关于综合的设置","slug":"Vivado中关于综合的设置","date":"2025-04-12T16:00:00.000Z","updated":"2025-07-18T03:48:07.310Z","comments":true,"path":"2025/04/13/Vivado中关于综合的设置/","permalink":"https://www.moerjielovecookie.icu/2025/04/13/Vivado%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%BB%BC%E5%90%88%E7%9A%84%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"1 1. 综合策略（Synthesis Strategy） 作用：控制综合工具优化设计的方向（性能、面积、功耗）。 选项： Vivado Synthesis Defaults：默认策略，平衡性能和资源。 AreaOptimized_high：优先减少资源占用（如LUT、寄存器）。 PerformanceOptimized_high：优先时序性能（降低关键路径延迟）。 PowerOptimized_high：优化功耗（需配合电源约束）。 配置位置： Vivado 的 Project Settings &gt; Synthesis &gt; Strategy。 命令行：set_property strategy &lt;strategy_name&gt; [current_run] 2 2. 关键优化属性2.1 (1) 资源控制 MAX_FANOUT： 限制信号的最大扇出，减少高扇出网络导致的时序问题。 设置方式：在 RTL 代码或 XDC 约束中添加 set_property MAX_FANOUT &lt;value&gt; [get_nets &lt;net_name&gt;]。 RAM_STYLE： 指定 RAM 实现方式（block 使用 BRAM，distributed 使用 LUTRAM）。 示例：set_property RAM_STYLE block [get_cells &lt;ram_instance&gt;]。 USE_DSP48： 强制乘法器使用 DSP48 单元（而非 LUT），提升性能。 设置方式：set_property USE_DSP48 yes [get_cells &lt;mult_instance&gt;]。 2.2 (2) 时序优化 Retiming： 跨寄存器调整逻辑位置，平衡关键路径延迟。 启用方式：在综合设置中勾选 Perform register retiming。 Control Set Optimization： 合并相同控制信号（复位/使能）的寄存器，减少控制集数量。 选项：Auto（默认）或 Aggressive。 3 3. 跨时钟域（CDC）处理 异步路径约束： 对跨时钟域路径设置 set_false_path 或 set_clock_groups，避免无效时序分析。 示例： 1set_clock_groups -asynchronous -group {clkA} -group {clkB} 同步器识别： Vivado 自动识别常见的同步器结构（如双寄存器），无需额外约束。 4 4. 增量综合（Incremental Synthesis） 作用：仅重新综合修改部分，缩短编译时间。 启用条件： 需在首次综合后生成 checkpoint 文件（.dcp）。 后续运行时勾选 Incremental Synthesis 选项。 适用场景：小型设计迭代，避免全流程耗时。 5 5. 约束文件（XDC）关键设置 时钟定义： 1create_clock -period 10 [get_ports clk] ; 定义10ns周期时钟 输入/输出延迟： 12set_input_delay 2.0 -clock [get_clocks clk] [get_ports data_in]set_output_delay 1.5 -clock [get_clocks clk] [get_ports data_out] 多周期路径： 1set_multicycle_path 2 -setup -from [get_pins {regA|C}] -to [get_pins {regB|D}] 6 6. 综合报告分析生成报告的命令：report_timing_summary -file timing.rpt关键指标： WNS (Worst Negative Slack)：最差负裕量（需 ≥0）。 资源利用率：LUT、FF、BRAM、DSP 占用比例。 时钟频率：检查是否满足目标频率（Target Frequency）。 7 7. 常见问题与调优 高扇出网络： 解决方案：插入 BUFG（全局缓冲）或复制寄存器。 关键路径未优化： 检查逻辑层级，手动添加流水线（pipeline）。 控制集过多： 减少复位/使能信号种类，或启用 Control Set Optimization。 8 总结Vivado 综合设置的核心是通过策略、属性、约束协同优化设计目标（性能/面积/功耗）。建议： 初始阶段：使用默认策略，逐步添加约束。 时序违例：优先调整 PerformanceOptimized_high 和 Retiming。 资源紧张：启用 AreaOptimized_high 和资源共享（如 Resource Sharing）。 迭代优化：结合综合报告与增量编译快速验证修改效果。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"多频点数字上变频器-调试记录","slug":"多频点数字上变频器-调试记录","date":"2025-03-13T16:00:00.000Z","updated":"2025-04-18T07:17:32.000Z","comments":true,"path":"2025/03/14/多频点数字上变频器-调试记录/","permalink":"https://www.moerjielovecookie.icu/2025/03/14/%E5%A4%9A%E9%A2%91%E7%82%B9%E6%95%B0%E5%AD%97%E4%B8%8A%E5%8F%98%E9%A2%91%E5%99%A8-%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/","excerpt":"","text":"顶层 bd通过 mm-s-fifo 将 PS 侧的 GP 接口转化为 stream 接口。 调试结果2025-3-14可以看出 mm-s-fifo 的输出一直没变，后级的 ready 信号可能有问题。 mm-s-fifo 的 valid 信号有问题 解决方法勾选 cut through 后才会流式传输数据 3-16写入 fifo 时必须加入打印，后面的 valid 信号才会有效，但是 valid 的速率很低。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"}]},{"title":"win11 Hyper-V消失","slug":"win11 Hyper-V消失","date":"2025-03-11T16:00:00.000Z","updated":"2025-07-14T12:06:40.347Z","comments":true,"path":"2025/03/12/win11 Hyper-V消失/","permalink":"https://www.moerjielovecookie.icu/2025/03/12/win11%20Hyper-V%E6%B6%88%E5%A4%B1/","excerpt":"","text":"在 win 中的“启动或关闭 Windows 功能“中突然找不到 Hyper-V 相关的选项，同时 wsl 无法启动。在桌面新建一个 .bat 文件，内容为 ``` 1234567891011pushd \"%~dp0\"dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V -All /LimitAccess /ALLpause 以管理员身份运行脚本后即可重新打开 Hyper-V","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"}]},{"title":"Linux用到的命令","slug":"Linux相关设置","date":"2025-02-26T16:00:00.000Z","updated":"2025-06-06T00:41:16.517Z","comments":true,"path":"2025/02/27/Linux相关设置/","permalink":"https://www.moerjielovecookie.icu/2025/02/27/Linux%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"1 Tar 命令 1234567tar -xzvf archive.tar.gz # 解压 .tar.gz 格式的文件 tar -xjvf archive.tar.bz2 # 解压 .tar.bz2 格式的文件 tar -xJvf archive.tar.xz # 解压 .tar.xz 格式的文件 tar -xvf archive.tar # 解压 .tar 格式的文件 -x：提取文件 -z：解压 gzip -j：解压 bzip 2 -J：解压 xz 格式 -v：显示详细信息 -f：指定要解压的文件名 2 换源2.1 Ubuntu 20.04 LTS1234567891011121314151617181920212223242526272829sudo cp /etc/apt/sources.list /etc/apt/sources.list.backsudo vim /etc/apt/sources.list# 阿里云deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse#清华源deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 2.2 Ubuntu-22.04 LTS 换源1234567891011#阿里云deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse 2.3 树莓派 4 b bookworm 系统换源12345678910sudo vi /etc/apt/sources.listdeb https://mirrors.tuna.tsinghua.edu.cn/debian bookworm main contrib non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free-firmwaredeb https://mirrors.tuna.tsinghua.edu.cn/debian bookworm-updates main contrib non-free-firmwaresudo vi /etc/apt/sources.list.d/raspi.listdeb https://mirrors.tuna.tsinghua.edu.cn/raspberrypi bookworm main /data","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"}]},{"title":"Petalinux","slug":"Petalinux","date":"2025-02-26T16:00:00.000Z","updated":"2025-04-21T14:05:03.000Z","comments":true,"path":"2025/02/27/Petalinux/","permalink":"https://www.moerjielovecookie.icu/2025/02/27/Petalinux/","excerpt":"","text":"Petalinux 命令参考《UG 1157 PetaLinux Command Line Reference Guide》 123456789101112131415161718192021//创建petalinux工程petalinux-create -t project --template zynq -n &lt;name&gt; //配置工程cd 上一步的工程petalinux-config --get-hw-description ../xsa_folder///配置Linux内核petalinux-config -c kernel//配置Linux根文件系统petalinux-config -c rootfs//编译petalinux-build//制作BOOT.Binpetalinux-package --boot --fsbl --fpga --u-boot --force//挂载NFSmount -t nfs -o nolock 192.168.0.1:/home/moerjie/work /mnt Petalinux 设置本地编译Xilinx下载中心首先在下载中心下载 petalinux 对应版本的”arm sstate-cache”和”download”包。将下载好的文件解压到 /opt/pkg/tools/ 文件路径下，使用 petalinux-config 配置工程。配置过程可见《领航者 ZYNQ 之嵌入式 Linux 开发指南 V 3.2》6.4 节。 与正点原子教程不同的地方正点原子的修改 project-spec/meta-user/conf/petalinuxbsp. Conf 的代码如下： 123456PREMIRRORS_prepend = \" \\git://.*/.* file:///mnt/hgfs/share18/downloads/downloads \\n \\gitsm://.*/.* file:///mnt/hgfs/share18/downloads/downloads \\n \\ftp://.*/.* file:///mnt/hgfs/share18/downloads/downloads \\n \\http://.*/.* file:///mnt/hgfs/share18/downloads/downloads \\n \\https://.*/.* file:///mnt/hgfs/share18/downloads/downloads \\n\" 但是 2023.2 版本的 petalinux 不支持这个语法，需改为： 123456PERMIRRORS:prepend = \"\\git://.*/.* file:///opt/downloads \\n \\gitsm://.*/.* file:///opt/downloads \\n \\ftp://.*/.* file:///opt/downloads \\n \\http://.*/.* file:///opt/downloads \\n \\https://.*/.* file:///opt/downloads \\n\" 12pre-mirror: file:///opt/downloadssstate: /opt/sstate/arm/ 挂载 PL 端的 IP 到设备树将创建好的 petalinux 工程编译一遍后，在 ./components/plnx_workspace/device-tree/device-tree 路径下会生成 pl.dtsi 文件，将内部的设备树相关的配置复制粘贴到 ./project-spec/meta-user/recipes-bsp/device-tree/files 中的 system-user.dtsi 中，编译后在系统中加入新的设备。 Petalinux 支持的 axisfifo 的驱动版本是 4.1，但是 vivado 2023.2 中的 axis fifo 的版本为 4.3，因此要将 compatible 中的 \"xlnx,axi-fifo-mm-s-4.3\" 改为 \"xlnx,axi-fifo-mm-s-4.1\"。Axis fifo 必须将中断信号连接到 zynq processing system 才能正确挂载到设备树。 使用 dtc -I dtb -O dts 反编译在 ./images/linux/ 路径下的 system.dtb 文件，即可看到挂载的新设备。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"Petalinux报错记录","slug":"Petalinux报错记录","date":"2025-02-26T16:00:00.000Z","updated":"2025-05-18T12:36:57.323Z","comments":true,"path":"2025/02/27/Petalinux报错记录/","permalink":"https://www.moerjielovecookie.icu/2025/02/27/Petalinux%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Unable to connect to bitbake server编译时卡住，检查 build.log 发现 log 文件提示 Unable to connect to bitbake server，此时只需要将 build 文件夹下的 bitbake.lock 删除即可 Login incorrect在最新版的UG1144 (v2022.2) 文档中，可以发现当前的 petalinux 登录的用户名为 petalinux，密码在第一次 boot 的时候设置。 The busybox: do_compile sig is computed to be 9 d 71366 ed 13 abee 85683 f 77 d 88 c 75 ecbae 7 d 20 d 529014 e 1 da 8137631 f 8660 fb 2, but the sig is locked to 101 bdd 12 e 211 f 67 f 8 c 0 bf 142 a 8 b 73 aed 7 f 4035684 a 921000 f 805 f 7 ff 5446 d 3 c 8 in SIGGEN_LOCKEDSIGS_t-cortexa 9 t 2 hf-neon该警告表明修改了被 sstate 锁定的固件，解决方法如下：在项目的 project-spec/meta-user/conf/petalinuxbsp.conf 中添加 [!note]SIGGEN_UNLOCKED_RECIPES += “busybox” 告知构建系统忽略此组件的签名锁定，接受本地修改。 Package require xsdb FAILED: Error loading hsi package: couldn’t load file “libxv_commontasks. So”: libtinfo. So. 5: cannot open shared object file: No such file or directory While executing该错误是缺少了链接库，安装后即可正常运行 petalinux 1sudo apt-get install libtinfo5","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"FIFO","slug":"FIFO","date":"2025-02-05T16:00:00.000Z","updated":"2025-07-14T11:44:02.484Z","comments":true,"path":"2025/02/06/FIFO/","permalink":"https://www.moerjielovecookie.icu/2025/02/06/FIFO/","excerpt":"","text":"FIFO 本质是由 RAM 加上读写逻辑构成的先入先出的数据缓冲器。与 RAM 的区别是 FIFO 没有外部读写地址线，顺序写入顺序读出数据，其数据地址是由内部读写指针自增完成，因此 FIFO 在读写时不需要考虑读写冲突的问题。根据 FIFO 工作的时钟域，可以分为同步 FIFO 和异步 FIFO，同步 FIFO 的读时钟和写时钟是同一个时钟，常用于两边数据位宽不同的临时缓冲，异步 FIFO 的读时钟和写时钟不一致，常用于数据信号跨时钟域处理。 1 时序图1.1 同步 fifo初始状态 empty 信号是高电平，此时 fifo 为空，若此时对 fifo 发起读操作，则读取到的数据无效。当 wr_en 拉高后，开始向 fifo 内部写入数据，fifo 中有数据后，empty 信号就会拉低。后面同时发起读写操作后，因为是同步 fifo，所以标志位不会发生变化。只写不读时，fifo 中存在两个及以上的数据，此时 almost empty 也会拉低。当 fifo 处于写满状态时，当 fifo 只能接受一次只写不读操作时，almost full 将会拉高，最后，在没有进行读操作的情况下，再进行了一次写操作，full 信号就会被拉高，说明此时的 FIFO 已经写满了，在发出读请求之前将无法再写入任何数据，如果此时再写入数据，数据就会丢失。 1.2 AXIS FIFO时序图如下：写入数据时，s_axis_tvalid 为高电平，同时 full 为低电平，取反后为 s_axis_tready 为高电平，此时才能写入数据。读数据时同理，只有 valid 和 ready 信号同时拉高时才能读出数据。m_axis_tvalid 对应 fifo 的 wr_en 信号，m_axis_tready 对应 fifo 的 full 信号取反，s_axis_tvalid 对应 fifo 的 empty 信号取反，s_axis_tready 对应 fifo 的 rd_en。 2 AXIS fifoAxis fifo 的 IP 核界面如下：本次是学习 FIFO 的异步读写，因此将 independent clock 选为‘是’，并且不使能 packet 模式。Bd 框图如下：其中 clk_wiz 的输出有两个，端口 1 的时钟速率为 ，端口 2 的时钟速率为 ，axis_data_source 和 axis_dest 的源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041module axis_data_source ( input s_axis_clk, input s_axis_rstn, input m_axis_tready, output [7:0] m_axis_tdata, output m_axis_tvalid );reg [7:0] cnt;always @(posedge s_axis_clk or negedge s_axis_rstn) begin if(!s_axis_rstn) begin cnt&lt;=0; end else begin if(m_axis_tready) begin if(cnt==255) begin cnt&lt;=0; end else begin cnt&lt;=cnt+1'b1; end end endendassign m_axis_tdata=cnt;assign m_axis_tvalid=1'b1; endmodule/*read fifo data*/module axis_dest ( input s_axis_clk, input s_axis_tvalid, input [7:0] s_axis_tdata, output s_axis_tready);assign s_axis_tready=1'b1;endmodule 其中 data_source 以 的速率生成并输出 ，axis_dest 一直以 的速率读取数据。时序图如下：可以看到开始时 FIFO 未被写满，此时写入和读出互不干扰，随着数据不断写入而不能被马上读出，在一段时间后 FIFO 的 full 信号拉高，对应 m_axis_tready 信号拉低，axis_data_source 不在生成新的数据，仿真图如下：可以看到此时写入和读出的速率经过 valid 和 ready 信号的使能而同步。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"FPGA开发时序图绘制","slug":"FPGA开发时序图绘制","date":"2025-01-31T16:00:00.000Z","updated":"2025-02-05T06:44:44.000Z","comments":true,"path":"2025/02/01/FPGA开发时序图绘制/","permalink":"https://www.moerjielovecookie.icu/2025/02/01/FPGA%E5%BC%80%E5%8F%91%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%BB%98%E5%88%B6/","excerpt":"","text":"开始的时候画时序图都是拿 visio 硬连，但是那个线宽太难统一了，丑不拉几的，遂学习 waveform 语法使用代码来画时序图。 开始Vscode 中安装 waveform render 或者在 GitHub 搜索 wavedrom 安装即可。由于 vscode 是我常用的编辑器，所以选择在 vscode 安装插件的方式来学习使用 waveform。在 vscode 中创建一个 json 文件，内容 1234567891011{ \"signal\":[ {\"name\":\"clk\",\"wave\":\"p.....\"}, {\"name\":\"data\",\"wave\":\"010101\"} ]} 在命令面板中选择如下命令后即可查看渲染结果： 语法时钟信号 p 表示上升沿开始的方波 n 表示下降沿开始的方波 l 表示低电平 h 表示高电平 大写会在方波边沿绘制箭头代码渲染出的时序图为： 数据信号 0 和 1 x 表示未知状态 =表示有效数据，也可写成 2~9，会用不同的颜色显示，并且可用 data 变量加上文本标签 可以用 | 表示省略一段信号period 和 phase 变量用于调整时序 period 的值应该是一个数字 n ，表示横向等比例放大或缩小 phase 的值应该是一个数字 n ，表示横向的位置调整，单位是一个时钟周期： 如果是正数，表示向左移动 n 个时钟周期 如果是负数，表示向右移动 n 个时钟周期多个信号可以用 ['group name', {...}, {...}, ...] 语法编成一组，而且支持嵌套时序绘制完毕后，还可以对图片进行修饰。 \"config\": { \"hscale\": n } 表示将图片横向等比例放大 n 倍。\"head\":{ } 和 \"foot\":{ } 分别表示在时序图的上方和下方添加一些内容： text 变量应该设置一个字符串，表示添加一行文本 tick 变量应该设置一个整数，表示在时钟周期的起点显示序号，从 n 开始 tock 变量应该设置一个整数，表示在时钟周期的中点显示序号，从 n 开始","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"ZYNQ-PS GPIO中断过程","slug":"ZYNQ-PS GPIO中断过程","date":"2025-01-26T16:00:00.000Z","updated":"2025-01-28T17:01:57.000Z","comments":true,"path":"2025/01/27/ZYNQ-PS GPIO中断过程/","permalink":"https://www.moerjielovecookie.icu/2025/01/27/ZYNQ-PS%20GPIO%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B/","excerpt":"中断初始化设置过程 查找中断控制器配置信息并初始化中断控制器驱动（XScuGic_LookupConfig、XScuGic_CfgInitialize） 设置中断类型（XScuGic_SetPriorityTriggerType） 为中断设置中断处理函数（XScuGic_Connect） 使能中断 (XScuGic_Enable) 设置并使能中断异常（Xil_ExceptionInit、Xil_ExceptionRegisterHandler、Xil_ExceptionEnable） 打开 GPIO 中断（XGpioPs_IntrEnablePin）","text":"中断初始化设置过程 查找中断控制器配置信息并初始化中断控制器驱动（XScuGic_LookupConfig、XScuGic_CfgInitialize） 设置中断类型（XScuGic_SetPriorityTriggerType） 为中断设置中断处理函数（XScuGic_Connect） 使能中断 (XScuGic_Enable) 设置并使能中断异常（Xil_ExceptionInit、Xil_ExceptionRegisterHandler、Xil_ExceptionEnable） 打开 GPIO 中断（XGpioPs_IntrEnablePin） 代码示例该代码包含部分 AXI GPIO 初始化的代码，其余都为 PS 端 GPIO 的初始化和中断初始化配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275/****************************************************************************** * Copyright (C) 2002 - 2021 Xilinx, Inc. All rights reserved. * SPDX-License-Identifier: MIT ******************************************************************************//*****************************************************************************//** * @file xgpio_example.c * * This file contains a design example using the AXI GPIO driver (XGpio) and * hardware device. It only uses channel 1 of a GPIO device and assumes that * the bit 0 of the GPIO is connected to the LED on the HW board. * * * &lt;pre&gt; * MODIFICATION HISTORY: * * Ver Who Date Changes * ----- ---- -------- ----------------------------------------------- * 1.00a rmm 03/13/02 First release * 1.00a rpm 08/04/03 Removed second example and invalid macro calls * 2.00a jhl 12/15/03 Added support for dual channels * 2.00a sv 04/20/05 Minor changes to comply to Doxygen and coding guidelines * 3.00a ktn 11/20/09 Minor changes as per coding guidelines. * 4.1 lks 11/18/15 Updated to use canonical xparameters and * clean up of the comments and code for CR 900381 * 4.3 sk 09/29/16 Modified the example to make it work when LED_bits are * configured as an output. CR# 958644 * ms 01/23/17 Added xil_printf statement in main function to * ensure that \"Successfully ran\" and \"Failed\" strings * are available in all examples. This is a fix for * CR-965028. * 4.5 sne 06/12/19 Fixed IAR compiler warning. * * &lt;/pre&gt; ******************************************************************************//***************************** Include Files *********************************/#include \"xparameters.h\"#include \"xgpio.h\"#include \"xil_printf.h\"#include \"sleep.h\"#include \"xscugic.h\"#include \"xil_exception.h\"#include &lt;xgpiops.h&gt;/************************** Constant Definitions *****************************/#define MODE_SINGLE_TONE 0x00#define MODE_PRINTER 0x01/* * The following constants map to the XPAR parameters created in the * xparameters.h file. They are defined here such that a user can easily * change all the needed parameters in one place. *///PS端GPIO器件ID#define GPIO_EXAMPLE_DEVICE_ID XPAR_GPIO_0_DEVICE_ID/* * The following constant is used to wait after an LED is turned on to make * sure that it is visible to the human eye. This constant might need to be * tuned for faster or slower processor speeds. */#define LED_DELAY 10000000/* * The following constant is used to determine which channel of the GPIO is * used for the LED if there are 2 channels supported. */#define MODE_CHANGE_CHANNEL 1/*GPIO define *///PS端GPIO器件ID#define MIO_ID XPAR_PS7_GPIO_0_DEVICE_ID//通用中断控制器ID#define INTC_DEVICE_ID XPAR_SCUGIC_SINGLE_DEVICE_ID//PS端GPIO中断ID#define KEY_INTR_ID XPAR_XGPIOPS_0_INTR#define PS_KEY_MIO 50 //key连接到MIO50#define PS_LED_MIO_1 0#define PS_LED_MIO_2 13#define GPIO_INPUT 1#define GPIO_OUTPUT 0/**************************** Type Definitions *******************************//***************** Macros (Inline Functions) Definitions *********************/typedef struct XGpio XGpio;/************************** Function Prototypes ******************************/int IntrInitFunction(XScuGic *InstancePtr, u16 DeviceId, XGpioPs *GpioInstancePtr);void GpioHandler(void *CallBackRef);/************************** Variable Definitions *****************************//* * The following are declared globally so they are zeroed and so they are * easily accessible from a debugger */XGpio Gpio; /* PL端AXI GPIO外设驱动实例 */XGpioPs GpioPs; /* PS端GPIO外设驱动实例 */XScuGic INTCInst; /* 通用中断控制器驱动实例 */int key_flag; // ps key 0 flag/*****************************************************************************//** * * The purpose of this function is to illustrate how to use the GPIO * driver to turn on and off an LED. * * * @return XST_FAILURE to indicate that the GPIO Initialization had * failed. * * @note This function will not return if the test is running. * ******************************************************************************/int main(void){ XGpioPs_Config *GpioConfig; /*PS端GPIO配置信息*/ int Status; int mode_flag = 0; key_flag = 0; /* Initialize the GPIOps driver*/ /*根据器件ID查找配置信息*/ GpioConfig = XGpioPs_LookupConfig(MIO_ID); /*初始化GPIO Driver*/ Status = XGpioPs_CfgInitialize(&amp;GpioPs, GpioConfig, GpioConfig-&gt;BaseAddr); if (Status != XST_SUCCESS) { xil_printf(\"GpioPs Initialization Failed\\r\\n\"); return XST_FAILURE; } else { xil_printf(\"GpioPs Initialization Success\\r\\n\"); } /* Initialize the GPIO driver */ /*初始化PL端AXI GPIO驱动*/ Status = XGpio_Initialize(&amp;Gpio, GPIO_EXAMPLE_DEVICE_ID); if (Status != XST_SUCCESS) { xil_printf(\"Gpio Initialization Failed\\r\\n\"); return XST_FAILURE; } else { xil_printf(\"Gpio Initialization Success\\r\\n\"); } /*GPIO_PS Intr init*/ /*设置KEY连接的MIO引脚的方向为输入*/ XGpioPs_SetDirectionPin(&amp;GpioPs, PS_KEY_MIO, GPIO_INPUT); /*使能按键中断*/ XGpioPs_SetIntrTypePin(&amp;GpioPs, PS_KEY_MIO, XGPIOPS_IRQ_TYPE_EDGE_RISING); XGpioPs_IntrEnablePin(&amp;GpioPs, PS_KEY_MIO); Status = IntrInitFunction(&amp;INTCInst, MIO_ID, &amp;GpioPs); if (Status != XST_SUCCESS) { xil_printf(\"IntrInitFunction Failed\\r\\n\"); return XST_FAILURE; } else { xil_printf(\"IntrInitFunction Success\\r\\n\"); } /* Set the direction for GPIO OUT */ XGpio_SetDataDirection(&amp;Gpio, MODE_CHANGE_CHANNEL, GPIO_OUTPUT); /*Set the direction for PS GPIO 1 for output &amp; 0 for input*/ XGpioPs_SetDirectionPin(&amp;GpioPs, PS_LED_MIO_1, 1); XGpioPs_SetDirectionPin(&amp;GpioPs, PS_LED_MIO_2, 1); XGpioPs_SetOutputEnablePin(&amp;GpioPs, PS_LED_MIO_1, 1); XGpioPs_SetOutputEnablePin(&amp;GpioPs, PS_LED_MIO_2, 1); /* Loop forever blinking the LED */ while (1) { if (key_flag) { if (mode_flag == 0) { XGpio_DiscreteWrite(&amp;Gpio, MODE_CHANGE_CHANNEL, MODE_SINGLE_TONE); xil_printf(\"MODE_SINGLE_TONE, mode flag:%d\\r\\n\", mode_flag); XGpioPs_WritePin(&amp;GpioPs, PS_LED_MIO_1, 0); // LED1 ON XGpioPs_WritePin(&amp;GpioPs, PS_LED_MIO_2, 1); // LED2 OFF mode_flag++; } else if (mode_flag == 1) { XGpio_DiscreteWrite(&amp;Gpio, MODE_CHANGE_CHANNEL, MODE_PRINTER); xil_printf(\"Painter, mode flag:%d\\r\\n\", mode_flag); XGpioPs_WritePin(&amp;GpioPs, PS_LED_MIO_1, 1); // LED1 OFF XGpioPs_WritePin(&amp;GpioPs, PS_LED_MIO_2, 0); // LED2 ON mode_flag = 0; } key_flag = 0; } } return 0;}int IntrInitFunction(XScuGic *InstancePtr, u16 DeviceId, XGpioPs *GpioInstancePtr){ XScuGic_Config *IntcConfig; /*中断控制器配置信息*/ int Status; /* * Initialize the interrupt controller driver so that it is ready to * use. */ /*查找中断控制器配置信息并初始化中断控制器驱动*/ IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); Status = XScuGic_CfgInitialize(InstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); if (Status != XST_SUCCESS) return XST_FAILURE; /* * set priority and trigger type * 设置中断类型为上升沿中断 */ XScuGic_SetPriorityTriggerType(InstancePtr, KEY_INTR_ID, 0xA0, 0x3); /* * Connect the device driver handler that will be called when an * interrupt for the device occurs, the handler defined above performs * the specific interrupt processing for the device. */ /*为中断设置中断处理函数*/ Status = XScuGic_Connect(InstancePtr, KEY_INTR_ID, (Xil_ExceptionHandler)GpioHandler, (void *)GpioInstancePtr); if (Status != XST_SUCCESS) return XST_FAILURE; /* * Enable the interrupt for the device. * 使能来自GPIO的中断 */ XScuGic_Enable(InstancePtr, KEY_INTR_ID); /*设置并使能中断异常*/ Xil_ExceptionInit(); Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler, InstancePtr); Xil_ExceptionEnable(); return XST_SUCCESS;}void GpioHandler(void *CallBackRef){ XGpioPs *GpioInstancePtr = (XGpioPs *)CallBackRef; int intr_val; intr_val = XGpioPs_IntrGetStatusPin(GpioInstancePtr, PS_KEY_MIO); /* Clear the interrupt */ XGpioPs_IntrClearPin(GpioInstancePtr, PS_KEY_MIO); if (intr_val) { xil_printf(\"Button Pressed\\r\\n\"); key_flag = 1; }}","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"}]},{"title":"AXI DMA+AXI-S FIFO回环学习","slug":"ZYNQ-AXI DMA+AXI-S FIFO回环学习","date":"2025-01-24T16:00:00.000Z","updated":"2025-07-14T11:45:02.400Z","comments":true,"path":"2025/01/25/ZYNQ-AXI DMA+AXI-S FIFO回环学习/","permalink":"https://www.moerjielovecookie.icu/2025/01/25/ZYNQ-AXI%20DMA+AXI-S%20FIFO%E5%9B%9E%E7%8E%AF%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1 DMA 简介DMA 是现代计算机的特色之一，是硬件实现存储器与存储器、存储器与 I/O 设备之间直接进行高速数据传输的内存技术，它允许不同速率的设备进行沟通，而不需要依靠 CPU 的中断负载。如果不使用 DMA，那么 CPU 需要从数据源把每一个片段的数据复制到寄存器中，这个过程会一直占用 CPU 的资源。当使用 DMA 时，CPU 向 DMA 发送一个存储传输请求，当 DMA 控制器收到请求时就会将数据从源地址搬运到目的地址，搬运过程中不消化 CPU 的资源，当传输完成后 DMA 控制器以中断的方式通知 CPU。为了发起传输事务，DMA 控制器必须有： 源地址 目的地址 传输长度DMA 存储传输的过程如下： 处理器向 DMA 控制器发送一条 DMA 命令 DMA 控制器把数据从外设传输到存储器或从存储器搬运到存储器，而让 CPU 腾出手来做其它操作 数据传输完成后，DMA 控制器向 CPU 发出一个中断，来通知处理器 DMA 传输完成 ZYNQ 提供两种 DMA，一种是集成在 PS 中的硬核 DMA，一种是 PL 中的软核 AXI DMA IP。各种接口方式的比较如下：PL 的 DMA 和 AXI_HP 接口的传输适用于大量数据的高性能传输，带宽高，传输方式的拓扑图如下： 1.1 AXI DMA IPAXI Direct Memory Access（AXI DMA）IP 核在 AXI 4 内存映射和 AXI 4-Stream IP 接口之间提供高带宽直接储存访问。 AXI DMA 用到了三种总线。AXI 4-Lite 用于对寄存器进行配置，AXI 4 Memory Map 总线用于读写 DDR 中的数据，AXI 4 Stream 总线用于 AXI DMA 对外设数据的读写，其中 AXI 4 Stream Master（MM 2 S，Memory Map to Stream）接口用于向 PL写入数据，AXI 4-Stream Slave (S 2 MM，Stream to Memory Map) 接口用于从 PL读取数据。AXI DMA 提供 3 种模式，分别是 Direct Register 模式、Scatter/Gather 模式和 Cyclic DMA（循环 DMA）模式，常用的是 Direct Register 模式。Direct Register DMA 模式即 Simple DMA 模式。Direct Register 模式提供了一种配置，用于在 MM 2 S 和 S 2 MM 通道上执行简单的 DMA 传输。Simple DMA（简单 DMA）允许应用程序在 DMA 和 Device 之间定义单个事务。它有两个通道：一个从 DMA 到 Device，另一个从 Device 到 DMA。这里有个地方需要大家注意下，在编写 Simple DMA（简单 DMA）代码时必须设置缓冲区地址和长度字段以启动相应通道中的传输。（其中 PL 对应 Device） 1.1.1 Vivado 中的 IP 配置 Enable Scatter Gather Engine选中此选项可启用 Scatter Gather 模式操作，并在 AXI DMA 中包含 Scatter Gather Engine。取消选中此选项可启用 Direct Register 模式操作，但不包括 AXI DMA 中的 Scatter Gather Engine。禁用 Scatter Gather Engine 会使 Scatter/Gather Engine 的所有输出端口都绑定为零，并且所有输入端口都将保持打开状态。此处我们取消勾选 Enable Scatter Gather EngineEnable Micro DMA使能后会生成高度优化的 DMA，资源消耗较少，用于极少量数据的传输Width of Buffer Length Register该选项配置了 AXI DMA 单次最大能搬运多少个字节，字节数 Address Width (32 - 64)指定地址空间的宽度，可以是 32 到 64 之间的任意值Enable Read Channel开启 AXI DMA 的读通道 MM 2 S，相关配置如下： Number of Channels：指定通道数。保持默认值 1 Memory Map Data Width：AXI MM 2 S 存储映射读取数据总线的数据位宽。有效值为 32、64、128、256、512 和 1024。此处保持默认值 32 Stream Data Width：AXI MM 2 S AXI 4-Stream 数据总线的数据位宽。该值必须小于或等于 Memory Map Data Width。有效值为 8、16、32、64、128、512 和 1024。此处保持默认值 32 Max Burst Size：突发分区粒度设置。此设置指定 MM 2 S 的 AXI 4-Memory Map 侧的突发周期的最大值。有效值为 2、4、8、16、32、64、128 和 256 Allow Unaligned Transfers：启用或禁用 MM 2 S 数据重新排列引擎（Data Realignment Engine，DRE）。选中时，DRE 被使能并允许在 MM 2 S 存储映射数据路径上数据重新对齐到 8 位的字节水平。对于 MM 2 S通道，则从内存中读取数据。如果 DRE 被使能，则数据读取可以从任何缓冲区地址字节偏移开始，并且读取数据被对齐，使得第一个字节读取是 AXI 4-Stream 上的第一个有效字节输出Enable Write Channel开启 AXI DMA 的写通道 S 2 MM，相关配置同上 2 Vitis 工程解析2.1 头文件引用和宏定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/***************************** Include Files *********************************/#include \"xaxidma.h\"#include \"xparameters.h\"#include \"xil_exception.h\"#include \"xdebug.h\"#include \"xil_util.h\"#ifdef XPAR_UARTNS550_0_BASEADDR#include \"xuartns550_l.h\" /* to use uartns550 */#endif#ifdef XPAR_INTC_0_DEVICE_ID#include \"xintc.h\"#else#include \"xscugic.h\"#endif/************************** Constant Definitions *****************************//* * Device hardware build related constants. */#define DMA_DEV_ID XPAR_AXIDMA_0_DEVICE_ID#ifdef XPAR_AXI_7SDDR_0_S_AXI_BASEADDR#define DDR_BASE_ADDR XPAR_AXI_7SDDR_0_S_AXI_BASEADDR#elif defined(XPAR_MIG7SERIES_0_BASEADDR)#define DDR_BASE_ADDR XPAR_MIG7SERIES_0_BASEADDR#elif defined(XPAR_MIG_0_C0_DDR4_MEMORY_MAP_BASEADDR)#define DDR_BASE_ADDR XPAR_MIG_0_C0_DDR4_MEMORY_MAP_BASEADDR#elif defined(XPAR_PSU_DDR_0_S_AXI_BASEADDR)#define DDR_BASE_ADDR XPAR_PSU_DDR_0_S_AXI_BASEADDR#endif#define DDR_BASE_ADDR XPAR_PS7_DDR_0_S_AXI_BASEADDR // 0x00100000#ifndef DDR_BASE_ADDR#warning CHECK FOR THE VALID DDR ADDRESS IN XPARAMETERS.H, \\ DEFAULT SET TO 0x01000000#define MEM_BASE_ADDR 0x01000000#else#define MEM_BASE_ADDR (DDR_BASE_ADDR + 0x01000000) // 0x01100000#endif#ifdef XPAR_INTC_0_DEVICE_ID#define RX_INTR_ID XPAR_INTC_0_AXIDMA_0_S2MM_INTROUT_VEC_ID#define TX_INTR_ID XPAR_INTC_0_AXIDMA_0_MM2S_INTROUT_VEC_ID#else#define RX_INTR_ID XPAR_FABRIC_AXIDMA_0_S2MM_INTROUT_VEC_ID#define TX_INTR_ID XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID#endif#define TX_BUFFER_BASE (MEM_BASE_ADDR + 0x00100000) // 0x01200000#define RX_BUFFER_BASE (MEM_BASE_ADDR + 0x00300000) // 0x01400000#define RX_BUFFER_HIGH (MEM_BASE_ADDR + 0x004FFFFF) // 0x015FFFFF#ifdef XPAR_INTC_0_DEVICE_ID#define INTC_DEVICE_ID XPAR_INTC_0_DEVICE_ID#else#define INTC_DEVICE_ID XPAR_SCUGIC_SINGLE_DEVICE_ID#endif#ifdef XPAR_INTC_0_DEVICE_ID#define INTC XIntc#define INTC_HANDLER XIntc_InterruptHandler#else#define INTC XScuGic#define INTC_HANDLER XScuGic_InterruptHandler#endif/* Timeout loop counter for reset */#define RESET_TIMEOUT_COUNTER 10000#define TEST_START_VALUE 0x1/* * Buffer and Buffer Descriptor related constant definition */#define MAX_PKT_LEN 0x200#define NUMBER_OF_TRANSFERS 10#define POLL_TIMEOUT_COUNTER 1000000U#define NUMBER_OF_EVENTS 1 #define DDR_BASE_ADDR XPAR_AXI_7SDDR_0_S_AXI_BASEADDR 重新定义了 DDR 3 的基址.。数据读写的基址为 #define MEM_BASE_ADDR (DDR_BASE_ADDR + 0x01000000) // 0x01100000 AXI DMA 读取数据的起始地址为 #define TX_BUFFER_BASE (MEM_BASE_ADDR + 0x00100000) // 0x01200000，写入地址为 0x01400000 2.2 定义函数和声明相关的 instance 和 flag 变量1234567891011121314151617181920212223242526272829303132333435363738/**************************** Type Definitions *******************************//***************** Macros (Inline Functions) Definitions *********************//************************** Function Prototypes ******************************/#ifndef DEBUGextern void xil_printf(const char *format, ...);#endif#ifdef XPAR_UARTNS550_0_BASEADDRstatic void Uart550_Setup(void);#endifstatic int CheckData(int Length, u8 StartValue);static void TxIntrHandler(void *Callback);static void RxIntrHandler(void *Callback);static int SetupIntrSystem(INTC *IntcInstancePtr, XAxiDma *AxiDmaPtr, u16 TxIntrId, u16 RxIntrId);static void DisableIntrSystem(INTC *IntcInstancePtr, u16 TxIntrId, u16 RxIntrId);/************************** Variable Definitions *****************************//* * Device instance definitions */static XAxiDma AxiDma; /* Instance of the XAxiDma */static INTC Intc; /* Instance of the Interrupt Controller *//* * Flags interrupt handlers use to notify the application context the events. */volatile u32 TxDone;volatile u32 RxDone;volatile u32 Error; 2.3 Main 函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206/*****************************************************************************//** * * Main function * * This function is the main entry of the interrupt test. It does the following: * Set up the output terminal if UART16550 is in the hardware build * Initialize the DMA engine * Set up Tx and Rx channels * Set up the interrupt system for the Tx and Rx interrupts * Submit a transfer * Wait for the transfer to finish * Check transfer status * Disable Tx and Rx interrupts * Print test status and exit * * @param None * * @return * - XST_SUCCESS if example finishes successfully * - XST_FAILURE if example fails. * * @note None. * ******************************************************************************/int main(void){ int Status; XAxiDma_Config *Config; int Tries = NUMBER_OF_TRANSFERS; int Index; u8 *TxBufferPtr; u8 *RxBufferPtr; u8 Value; TxBufferPtr = (u8 *)TX_BUFFER_BASE; RxBufferPtr = (u8 *)RX_BUFFER_BASE; /* Initial setup for Uart16550 */#ifdef XPAR_UARTNS550_0_BASEADDR Uart550_Setup();#endif xil_printf(\"\\r\\n--- Entering main() --- \\r\\n\"); Config = XAxiDma_LookupConfig(DMA_DEV_ID); if (!Config) { xil_printf(\"No config found for %d\\r\\n\", DMA_DEV_ID); return XST_FAILURE; } else { xil_printf(\"Config found for %d\\r\\n\", DMA_DEV_ID); } /* Initialize DMA engine */ Status = XAxiDma_CfgInitialize(&amp;AxiDma, Config); if (Status != XST_SUCCESS) { xil_printf(\"Initialization failed %d\\r\\n\", Status); return XST_FAILURE; } else { xil_printf(\"DMA Initialization success %d\\r\\n\", Status); } if (XAxiDma_HasSg(&amp;AxiDma)) { xil_printf(\"Device configured as SG mode \\r\\n\"); return XST_FAILURE; } else { xil_printf(\"Device configured as simple mode \\r\\n\"); } /* Set up Interrupt system */ Status = SetupIntrSystem(&amp;Intc, &amp;AxiDma, TX_INTR_ID, RX_INTR_ID); if (Status != XST_SUCCESS) { xil_printf(\"Failed intr setup\\r\\n\"); return XST_FAILURE; } /* Disable all interrupts before setup */ XAxiDma_IntrDisable(&amp;AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE); XAxiDma_IntrDisable(&amp;AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA); /* Enable all interrupts */ XAxiDma_IntrEnable(&amp;AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE); XAxiDma_IntrEnable(&amp;AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA); /* Initialize flags before start transfer test */ TxDone = 0; RxDone = 0; Error = 0; Value = TEST_START_VALUE; for (Index = 0; Index &lt; MAX_PKT_LEN; Index++) { TxBufferPtr[Index] = Value; Value = (Value + 1) &amp; 0xFF; } /* Flush the buffers before the DMA transfer, in case the Data Cache * is enabled */ Xil_DCacheFlushRange((UINTPTR)TxBufferPtr, MAX_PKT_LEN); Xil_DCacheFlushRange((UINTPTR)RxBufferPtr, MAX_PKT_LEN); /* Send a packet */ for (int i = 0; i &lt; Tries; i++) { Status = XAxiDma_SimpleTransfer(&amp;AxiDma, (UINTPTR)RxBufferPtr, MAX_PKT_LEN, XAXIDMA_DEVICE_TO_DMA); if (Status != XST_SUCCESS) { return XST_FAILURE; } Status = XAxiDma_SimpleTransfer(&amp;AxiDma, (UINTPTR)TxBufferPtr, MAX_PKT_LEN, XAXIDMA_DMA_TO_DEVICE); if (Status != XST_SUCCESS) { return XST_FAILURE; } Status = Xil_WaitForEventSet(POLL_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &amp;Error); if (Status == XST_SUCCESS) { if (!TxDone) { xil_printf(\"Transmit error %d\\r\\n\", Status); goto Done; } else if (Status == XST_SUCCESS &amp;&amp; !RxDone) { xil_printf(\"Receive error %d\\r\\n\", Status); goto Done; } } /* * Wait for TX done or timeout */ Status = Xil_WaitForEventSet(POLL_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &amp;TxDone); if (Status != XST_SUCCESS) { xil_printf(\"Transmit failed %d\\r\\n\", Status); goto Done; } /* * Wait for RX done or timeout */ Status = Xil_WaitForEventSet(POLL_TIMEOUT_COUNTER, NUMBER_OF_EVENTS, &amp;RxDone); if (Status != XST_SUCCESS) { xil_printf(\"Receive failed %d\\r\\n\", Status); goto Done; } /* * Test finished, check data */ Status = CheckData(MAX_PKT_LEN, 0x1); if (Status != XST_SUCCESS) { xil_printf(\"Data check failed\\r\\n\"); goto Done; } xil_printf(\"Transfer %d done\\r\\n\", i + 1); } xil_printf(\"Successfully ran AXI DMA interrupt Example\\r\\n\"); /* Disable TX and RX Ring interrupts and return success */ DisableIntrSystem(&amp;Intc, TX_INTR_ID, RX_INTR_ID);Done: xil_printf(\"--- Exiting main() --- \\r\\n\"); if (Status != XST_SUCCESS) { return XST_FAILURE; } return XST_SUCCESS;} Tries 为测试回环的次数 2.4 函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355*****************************************************************************//* * * This function checks data buffer after the DMA transfer is finished. * * We use the static tx/rx buffers. * * @param Length is the length to check * @param StartValue is the starting value of the first byte * * @return * - XST_SUCCESS if validation is successful * - XST_FAILURE if validation is failure. * * @note None. * ******************************************************************************/static int CheckData(int Length, u8 StartValue){ u8 *RxPacket; int Index = 0; u8 Value; RxPacket = (u8 *)RX_BUFFER_BASE; Value = StartValue; /* Invalidate the DestBuffer before receiving the data, in case the * Data Cache is enabled */ Xil_DCacheInvalidateRange((UINTPTR)RxPacket, Length); for (Index = 0; Index &lt; Length; Index++) { if (RxPacket[Index] != Value) { xil_printf(\"Data error %d: %x/%x\\r\\n\", Index, RxPacket[Index], Value); return XST_FAILURE; } Value = (Value + 1) &amp; 0xFF; } return XST_SUCCESS;}/*****************************************************************************//* * * This is the DMA TX Interrupt handler function. * * It gets the interrupt status from the hardware, acknowledges it, and if any * error happens, it resets the hardware. Otherwise, if a completion interrupt * is present, then sets the TxDone.flag * * @param Callback is a pointer to TX channel of the DMA engine. * * @return None. * * @note None. * ******************************************************************************/static void TxIntrHandler(void *Callback){ u32 IrqStatus; int TimeOut; XAxiDma *AxiDmaInst = (XAxiDma *)Callback; /* Read pending interrupts */ IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DMA_TO_DEVICE); /* Acknowledge pending interrupts */ XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DMA_TO_DEVICE); /* * If no interrupt is asserted, we do not do anything */ if (!(IrqStatus &amp; XAXIDMA_IRQ_ALL_MASK)) { return; } /* * If error interrupt is asserted, raise error flag, reset the * hardware to recover from the error, and return with no further * processing. */ if ((IrqStatus &amp; XAXIDMA_IRQ_ERROR_MASK)) { Error = 1; /* * Reset should never fail for transmit channel */ XAxiDma_Reset(AxiDmaInst); TimeOut = RESET_TIMEOUT_COUNTER; while (TimeOut) { if (XAxiDma_ResetIsDone(AxiDmaInst)) { break; } TimeOut -= 1; } return; } /* * If Completion interrupt is asserted, then set the TxDone flag */ if ((IrqStatus &amp; XAXIDMA_IRQ_IOC_MASK)) { TxDone = 1; }}/*****************************************************************************//* * * This is the DMA RX interrupt handler function * * It gets the interrupt status from the hardware, acknowledges it, and if any * error happens, it resets the hardware. Otherwise, if a completion interrupt * is present, then it sets the RxDone flag. * * @param Callback is a pointer to RX channel of the DMA engine. * * @return None. * * @note None. * ******************************************************************************/static void RxIntrHandler(void *Callback){ u32 IrqStatus; int TimeOut; XAxiDma *AxiDmaInst = (XAxiDma *)Callback; /* Read pending interrupts */ IrqStatus = XAxiDma_IntrGetIrq(AxiDmaInst, XAXIDMA_DEVICE_TO_DMA); /* Acknowledge pending interrupts */ XAxiDma_IntrAckIrq(AxiDmaInst, IrqStatus, XAXIDMA_DEVICE_TO_DMA); /* * If no interrupt is asserted, we do not do anything */ if (!(IrqStatus &amp; XAXIDMA_IRQ_ALL_MASK)) { return; } /* * If error interrupt is asserted, raise error flag, reset the * hardware to recover from the error, and return with no further * processing. */ if ((IrqStatus &amp; XAXIDMA_IRQ_ERROR_MASK)) { Error = 1; /* Reset could fail and hang * NEED a way to handle this or do not call it?? */ XAxiDma_Reset(AxiDmaInst); TimeOut = RESET_TIMEOUT_COUNTER; while (TimeOut) { if (XAxiDma_ResetIsDone(AxiDmaInst)) { break; } TimeOut -= 1; } return; } /* * If completion interrupt is asserted, then set RxDone flag */ if ((IrqStatus &amp; XAXIDMA_IRQ_IOC_MASK)) { RxDone = 1; }}/*****************************************************************************//* * * This function setups the interrupt system so interrupts can occur for the * DMA, it assumes INTC component exists in the hardware system. * * @param IntcInstancePtr is a pointer to the instance of the INTC. * @param AxiDmaPtr is a pointer to the instance of the DMA engine * @param TxIntrId is the TX channel Interrupt ID. * @param RxIntrId is the RX channel Interrupt ID. * * @return * - XST_SUCCESS if successful, * - XST_FAILURE.if not successful * * @note None. * ******************************************************************************/static int SetupIntrSystem(INTC *IntcInstancePtr, XAxiDma *AxiDmaPtr, u16 TxIntrId, u16 RxIntrId){ int Status;#ifdef XPAR_INTC_0_DEVICE_ID /* Initialize the interrupt controller and connect the ISRs */ Status = XIntc_Initialize(IntcInstancePtr, INTC_DEVICE_ID); if (Status != XST_SUCCESS) { xil_printf(\"Failed init intc\\r\\n\"); return XST_FAILURE; } Status = XIntc_Connect(IntcInstancePtr, TxIntrId, (XInterruptHandler)TxIntrHandler, AxiDmaPtr); if (Status != XST_SUCCESS) { xil_printf(\"Failed tx connect intc\\r\\n\"); return XST_FAILURE; } Status = XIntc_Connect(IntcInstancePtr, RxIntrId, (XInterruptHandler)RxIntrHandler, AxiDmaPtr); if (Status != XST_SUCCESS) { xil_printf(\"Failed rx connect intc\\r\\n\"); return XST_FAILURE; } /* Start the interrupt controller */ Status = XIntc_Start(IntcInstancePtr, XIN_REAL_MODE); if (Status != XST_SUCCESS) { xil_printf(\"Failed to start intc\\r\\n\"); return XST_FAILURE; } XIntc_Enable(IntcInstancePtr, TxIntrId); XIntc_Enable(IntcInstancePtr, RxIntrId);#else XScuGic_Config *IntcConfig; /* * Initialize the interrupt controller driver so that it is ready to * use. */ IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID); if (NULL == IntcConfig) { return XST_FAILURE; } Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig, IntcConfig-&gt;CpuBaseAddress); if (Status != XST_SUCCESS) { return XST_FAILURE; } //设置中断优先级和触发类型 XScuGic_SetPriorityTriggerType(IntcInstancePtr, TxIntrId, 0xA0, 0x3); XScuGic_SetPriorityTriggerType(IntcInstancePtr, RxIntrId, 0xA0, 0x3); /* * Connect the device driver handler that will be called when an * interrupt for the device occurs, the handler defined above performs * the specific interrupt processing for the device. */ //设置中断处理函数 Status = XScuGic_Connect(IntcInstancePtr, TxIntrId, (Xil_InterruptHandler)TxIntrHandler, AxiDmaPtr); if (Status != XST_SUCCESS) { return Status; } Status = XScuGic_Connect(IntcInstancePtr, RxIntrId, (Xil_InterruptHandler)RxIntrHandler, AxiDmaPtr); if (Status != XST_SUCCESS) { return Status; } XScuGic_Enable(IntcInstancePtr, TxIntrId); XScuGic_Enable(IntcInstancePtr, RxIntrId);#endif /* Enable interrupts from the hardware */ Xil_ExceptionInit(); Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)INTC_HANDLER, (void *)IntcInstancePtr); Xil_ExceptionEnable(); return XST_SUCCESS;}/*****************************************************************************//** * * This function disables the interrupts for DMA engine. * * @param IntcInstancePtr is the pointer to the INTC component instance * @param TxIntrId is interrupt ID associated w/ DMA TX channel * @param RxIntrId is interrupt ID associated w/ DMA RX channel * * @return None. * * @note None. * ******************************************************************************/static void DisableIntrSystem(INTC *IntcInstancePtr, u16 TxIntrId, u16 RxIntrId){#ifdef XPAR_INTC_0_DEVICE_ID /* Disconnect the interrupts for the DMA TX and RX channels */ XIntc_Disconnect(IntcInstancePtr, TxIntrId); XIntc_Disconnect(IntcInstancePtr, RxIntrId);#else XScuGic_Disconnect(IntcInstancePtr, TxIntrId); XScuGic_Disconnect(IntcInstancePtr, RxIntrId);#endif}","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"}]},{"title":"hexo部署到github page时，hexo d后page里面绑定的个人域名消失的问题","slug":"hexo部署到github page时，hexo d后page里面绑定的个人域名消失的问题","date":"2025-01-23T16:00:00.000Z","updated":"2025-07-14T12:09:00.063Z","comments":true,"path":"2025/01/24/hexo部署到github page时，hexo d后page里面绑定的个人域名消失的问题/","permalink":"https://www.moerjielovecookie.icu/2025/01/24/hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%20page%E6%97%B6%EF%BC%8Chexo%20d%E5%90%8Epage%E9%87%8C%E9%9D%A2%E7%BB%91%E5%AE%9A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B6%88%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"Hexo 部署博客到 GitHub page 后，可以在 setting 中的 page 中绑定自己的域名，但是我发现更新博客后绑定的域名消失，恢复原始的 githubio 的域名。后面搜索发现需要在 repo 里面添加 CNAME 文件，内容为 page 里面绑定的域名：但是这样的话每次 deploy 后 CNAME 文件会消失。然后我将这个文件放到本地 hexo 文件夹内的 public 文件夹中，这样的话 deploy 后 CNAME 文件就会和别的 html 文件一起推送到 GitHub 仓库里面。看似解决了，可是在调试主题的时候，运行了 hexo clean 后导致 public 文件夹被删除，CNAME 文件又没了。最后的最后，了解到执行 hexo g 的时候，会 source 文件夹内的文件进行编译，因此将 CNAME 放到 source 文件夹中即可完美解决。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"}]},{"title":"Verilog中if语句和case语句综合出的电路区别","slug":"Verilog中if语句和case语句综合出的电路区别","date":"2025-01-20T16:00:00.000Z","updated":"2025-01-21T14:34:40.000Z","comments":true,"path":"2025/01/21/Verilog中if语句和case语句综合出的电路区别/","permalink":"https://www.moerjielovecookie.icu/2025/01/21/Verilog%E4%B8%ADif%E8%AF%AD%E5%8F%A5%E5%92%8Ccase%E8%AF%AD%E5%8F%A5%E7%BB%BC%E5%90%88%E5%87%BA%E7%9A%84%E7%94%B5%E8%B7%AF%E5%8C%BA%E5%88%AB/","excerpt":"","text":"区别是 if else 的逻辑判断有优先级，最内层的 if 的优先级最高，case 的逻辑判断是并列的。每个 if else 综合出来的电路是一个 2 选 1 选通器。当信号有明显优先级时使用该语句，但是 if 嵌套太多的话会导致路径延时过大，降低运行速度。所以在判定条件较少的时候使用。if else 综合出的电路面积较小。case语句适用于无明显优先级的逻辑判断，这些逻辑条件都处于同一个优先级且互斥，比如实现对速度要求较高的编解码；case结构电路速度较快，但占用面积较大，综合为 n 选 1 mux电路。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"ZYNQ-IP-AXI-GPIO","slug":"ZYNQ-IP-AXI-GPIO","date":"2025-01-19T16:00:00.000Z","updated":"2025-04-27T12:28:31.000Z","comments":true,"path":"2025/01/20/ZYNQ-IP-AXI-GPIO/","permalink":"https://www.moerjielovecookie.icu/2025/01/20/ZYNQ-IP-AXI-GPIO/","excerpt":"","text":"AXI GPIO 可以将 PS 端的一个 AXI 4-Lite 接口转化为 GPIO 接口，并且可以被配置为单端口或双端口，每个通道的位宽可以独立配置。通过使能三态门可以将端口动态地配置为输入或输出。AXIGPIO 是 ZYNQ PL 端的一个 IP 核，可以将 AXI-Lite Master 转为 GPIO，并且一个 AXI-Lite 接口可以通过 AXI interconnect 模块控制多个 AXI-GPIO。 AXI-GPIO IP 设置最大时钟频率 的最大频率和 的速率相同，为 。 AXI GPIO 设置默认为单通道。GPIO 的方向在这里设置了以后就不能在 vitis 中设置 GPIO 的方向。中断属于 PL 对 PS 的中断，需要在 ZYNQ 7 Processing System 中勾选 生成的 vitis 的代码中，xparameters.h 中的 id 默认从 ID 0 开始，不管 vivado 这边的 AXI-GPIO 的序号是从 0 开始还是从 1 开始。 [!note] GPIO 只能使能整个通道中断，无法单独使能通道中的某个引脚中断 中断类型只能设置为上升沿或高电平 AXI-GPIO 相关代码初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/****************************************************************************//*** Initialize the XGpio instance provided by the caller based on the* given configuration data.** Nothing is done except to initialize the InstancePtr.** @param InstancePtr is a pointer to an XGpio instance. The memory the* pointer references must be pre-allocated by the caller. Further* calls to manipulate the driver through the XGpio API must be* made with this pointer.* @param Config is a reference to a structure containing information* about a specific GPIO device. This function initializes an* InstancePtr object for a specific device specified by the* contents of Config. This function can initialize multiple* instance objects with the use of multiple calls giving different* Config information on each call.* @param EffectiveAddr is the device base address in the virtual memory* address space. The caller is responsible for keeping the address* mapping from EffectiveAddr to the device physical base address* unchanged once this function is invoked. Unexpected errors may* occur if the address mapping changes after this function is* called. If address translation is not used, use* Config-&gt;BaseAddress for this parameters, passing the physical* address instead.** @return* - XST_SUCCESS if the initialization is successful.** @note None.******************************************************************************/int XGpio_CfgInitialize(XGpio * InstancePtr, XGpio_Config * Config, UINTPTR EffectiveAddr) 设置输入输出方向1234567891011121314151617181920212223242526272829303132/****************************************************************************//*** Set the input/output direction of all discrete signals for the specified* GPIO channel.** @param InstancePtr is a pointer to an XGpio instance to be worked on.* @param Channel contains the channel of the GPIO (1 or 2) to operate on.* @param DirectionMask is a bitmask specifying which discretes are input* and which are output. Bits set to 0 are output and bits set to 1* are input.** @return None.** @note The hardware must be built for dual channels if this function* is used with any channel other than 1. If it is not, this* function will assert.******************************************************************************/void XGpio_SetDataDirection(XGpio *InstancePtr, unsigned Channel, u32 DirectionMask) GPIO 读写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/****************************************************************************//*** Read state of discretes for the specified GPIO channel.* @param InstancePtr is a pointer to an XGpio instance to be worked on.* @param Channel contains the channel of the GPIO (1 or 2) to operate on.* @return Current copy of the discretes register.* @note The hardware must be built for dual channels if this function* is used with any channel other than 1. If it is not, this* function will assert.*****************************************************************************/u32 XGpio_DiscreteRead(XGpio * InstancePtr, unsigned Channel)/****************************************************************************//*** Write to discretes register for the specified GPIO channel.** @param InstancePtr is a pointer to an XGpio instance to be worked on.* @param Channel contains the channel of the GPIO (1 or 2) to operate on.* @param Mask is the value to be written to the discretes register.** @return None.** @note The hardware must be built for dual channels if this function* is used with any channel other than 1. If it is not, this* function will assert. See also XGpio_DiscreteSet() and* XGpio_DiscreteClear().******************************************************************************/void XGpio_DiscreteWrite(XGpio * InstancePtr, unsigned Channel, u32 Mask)","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"}]},{"title":"ZYNQ中的GPIO","slug":"ZYNQ中的IO","date":"2025-01-19T16:00:00.000Z","updated":"2025-01-20T12:50:08.000Z","comments":true,"path":"2025/01/20/ZYNQ中的IO/","permalink":"https://www.moerjielovecookie.icu/2025/01/20/ZYNQ%E4%B8%AD%E7%9A%84IO/","excerpt":"","text":"GPIO 原理GPIO 通过 MIO 提供 54 路接口，其中 16 路位于 bank 500，剩余位于 bank 501。还通过 EMIO 接口提供从 PL 来的 64 路输入和 128 路输出。GPIO 控制和状态寄存器内存映射在基址 。ZYNQ 的 GPIO 引脚分为 4 个 bank，共有 118 个 GPIO。个个（）个（）个（）个（） GPIO 内部结构从图中可以看到 GPIO 有三个功能：输入、输出、中断。其中 MIO 7 和 9 只能做输出。一组寄存器只能控制一个 GPIO bank 的所有引脚。 器件引脚的 GPIO 控制输入/输出寄存器 寄存器名称 说明 DATA_RO GPIO引脚的值存储在此寄存器中，无论GPIO被配置为输入或输出，都可以通过读此寄存器得到GPIO引脚的值。 因为是只读寄存器（对软件来说），软件向此寄存器的写入操作将被忽略。 DATA 输出数据寄存器，当GPIO被配置为输出才起作用，此寄存器中的值就是输出到引脚的值。 向此寄存器写入就是在设置GPIO的输出值， 读此寄存器将返回GPIO前一时刻的输出值，而不是现在的值。 MASK_DATA_LSW Mask Data Least Significant Words，输出数据低16位掩码寄存器，此寄存器只有低16位有效， 对应位为1表示DATA寄存器低16位中对应位的值可以更改， 若不为1，则表示DATA寄存器低16位中对应位保持原值 MASK_DATA_MSW Mask Data Most Significant Words，输出数据高16位掩码寄存器， 功能同MASK_DATA_LSW，只是它对应DATA寄存器高16位 DIRM Direction Memory，方向寄存器，默认为0表示输入，设为1表示输出 注意，即使DIRM为1，软件也可以像输入一样去读此引脚的电平 OEN Output Enable，输出使能寄存器， 仅当DIRM为0时有效，为1表示输出使能， 为0表示输出不使能，此时对应引脚上的值为三态值 中断控制寄存器 寄存器名称 说明 INT_TYPE Interrupt Type 中断类型寄存器， 控制GPIO中断是电平触发还是边缘触发 INT_POLARITY Interrupt Polarity 中断极性寄存器 控制GPIO中断是低电平/下降沿有效，还是高电平/上升沿有效 INT_ANY Interrupt Any，双边沿寄存器， 仅当INT_TYPE为边沿触发时，此寄存器才有效，控制是否双沿均可触发中断 INT_STAT Interrupt State，中断状态寄存器， 此寄存器的值会被与之相连的INT State D触发器读取 D触发器存储中断状态，软件通过读此D触发器输出来判断中断是否发生， 清除此D触发器来清除中断状态 INT_MASK Interrupt Mask，中断掩码寄存器， 显示当前哪些位被屏蔽，哪些位启用 INT_DIS Interrupt Disable，中断失效寄存器， 向该寄存器的任何位写入 1 都会屏蔽该中断信号。 从该寄存器读取会返回不可预测的值 INT_EN Interrupt Enable，中断使能寄存器 向该寄存器的任何位写入 1，可以启用/解除中断信号的掩码。 从该寄存器读取将返回一个不不可预测的值 GPIO 的中断号为 ==52==，中断优先级是固定的，无需配置 GPIO 的中断优先级。GPIO 所有引脚共享同一个中断，即使能两个引脚的中断的话，软件无法判断中断来自哪个引脚。 EMIO 和 MIOMIO，Multiuse I/O，复用输入/输出，对应 PS 端的可配置的多功能引脚。EMIO，Extent MIO，对应 PL 端的可配置多功能引脚。MIO 是外设的基本引脚，由于 MIO 的引脚数量较少，ZYNQ 也提供 EMIO 接口作为 MIO 的扩展，外设通过 EMIO 接口连接到 PL 端的引脚，来实现和 MIO 几乎相同的功能。MIO 和 EMIO 的不同点如下： MIO 对于 PL 端是透明的，PL 无法读取 MIO 引脚上的电平；PS 端可以通过 EMIO 与 PL 端通信。 外设与 MIO 是固定搭配的，初始化时要根据开发板原理图来选择引脚约束。EMIO 相对灵活，引脚可以任意指定，通过 xdc 文件约束指定到 PL 端的某个引脚。 因为 MIO 引脚更靠近外围电路，相较于 EMIO，一些外设使用 MIO 的性能更好，还有一些外设只能使用 MIO。 MIO bank 和封装的 bank 的区别与联系MIO 分为 Bank 0 和 Bank 1，Bank 0 是封装 Bank 500 中的部分引脚，Bank 1 是封装的 bank 501 的部分引脚。Bank 0 包含 MIO 015 共 16 个 MIO，bank 1 包括 MIO 1653 共 38 个 MIO，总共有 54 个 MIO。EMIO 一共有 64 个。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"}]},{"title":"Vitis开发过程中遇到的错误","slug":"Vitis开发过程中遇到的错误","date":"2025-01-14T16:00:00.000Z","updated":"2025-07-14T12:13:50.506Z","comments":true,"path":"2025/01/15/Vitis开发过程中遇到的错误/","permalink":"https://www.moerjielovecookie.icu/2025/01/15/Vitis%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"","text":"1 Error while launching program: Memory write error at 0 x 105000. MMU section translation fault没找到具体原因。先生成 boot. Bin 文件烧录到内存卡后再启动 zynq 就不会出现这个报错。 1.1 解决方案将开发板的 boot 选项从 SD 切换到 jtag 即可 2 Unresolved inclusion: “stdio. H”在 Linux 环境下和 win 环境下创建工程添加 stdio 库时都会有这个问题。 2.1 解决方案Properties -&gt; C/C++ General -&gt; Preprocessor Includes… -&gt; Providers ，并选中 CDT GCC Built-in Compiler Settings","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"}]},{"title":"FIR滤波器的架构","slug":"FIR滤波器的架构","date":"2024-12-28T16:00:00.000Z","updated":"2025-04-27T12:28:31.000Z","comments":true,"path":"2024/12/29/FIR滤波器的架构/","permalink":"https://www.moerjielovecookie.icu/2024/12/29/FIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E6%9E%B6%E6%9E%84/","excerpt":"","text":"数学基础有限脉冲响应滤波器，其突出特点为单位取样响应 是一个 N 点长的有限序列，滤波器的输出 表示为输入序列 和 的线性卷积系统函数为由此可见 FIR 只在原点上存在极点，具有全局稳定性不同阶数的 FIR 滤波器特性 单位取样响应特征 滤波器种类 系数偶对称，阶数为偶数 适合各种滤波器 系数偶对称，阶数为奇数 不适合高通和带阻滤波器 系数奇对称，阶数为偶数 只适合带通滤波器 系数奇对称，阶数为奇数 适合高通和带通滤波器 系数量化将一组数据先进行归一化处理，再乘上一个整数因子，最后进行四舍五入截尾处理即可 1h = round(h/max(abs(h))*(2^N-1)) //N为量化位数 Fully Parallel Systolic Architecture（全并行脉动结构）全并行脉动滤波器对对称系数、反对称系数和零值系数进行了优化。滤波器的时延受到滤波器系数的对称性影响。当对称系数绝对相等时，它们共享同一个 DSP block。这种配对共享允许在实现的过程中使用 Xilinx 和 Altera 的 dsp block 中的 pre-adder。对称的滤波器如果不适用对称系数优化架构的话，结构如下图的上半部分，优化后为下半部分： Fully Parallel Transposed Architecture（全并行转置结构）Fully Parallel Transposed Architecture 通过为任意的绝对相等的系数共享乘法器，同时移除零值系数所需的乘法器。此结构的滤波器时延为固定的 6 个 clk。下图的上半部分是没有优化的部分对称滤波器，下半部分为优化后的结构： Partly Serial Systolic Architecture (1 &lt; N &lt; L)其中 N 为延时长度，L 为滤波器阶数。部分串行滤波器需要 M=ceil(L/N) 个脉动单元，结构如下：滤波器的时延为 M+ceil(L/M)+5。如果一个乘法器对应的查找表里面的系数为 0 或者 2 的幂次，则实现过程不包含乘法器，通过移位来实现幂次的变化。 Fully Serial Systolic Architecture (N ≥ L)如果延时的长度大于滤波器的阶数，此时滤波器为全串行结构。滤波器延时为 。","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"Quartus报错记录","slug":"Quartus报错记录","date":"2024-12-27T16:00:00.000Z","updated":"2025-07-08T08:15:45.000Z","comments":true,"path":"2024/12/28/Quartus报错记录/","permalink":"https://www.moerjielovecookie.icu/2024/12/28/Quartus%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1 Error (176310): Can’t place multiple pins assigned to pin location Pin_F 16 (IOPAD_X 34_Y 18_N 21)报错如下可以看到 Pin_F 16 既被用于 DAC_DATA，又被用于 nCEO 引脚，因此才会报错不能将多个引脚赋到 Pin_F 16 上。 1.1 Solution将nCEO 的 value 设置为 Use as regual I&#x2F;O 即可解决问题。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"git学习","slug":"git学习","date":"2024-12-10T16:00:00.000Z","updated":"2025-08-20T03:39:31.985Z","comments":true,"path":"2024/12/11/git学习/","permalink":"https://www.moerjielovecookie.icu/2024/12/11/git%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1 Git 基础概念1.1 Git 概念汇总 概念 描述 工作区（Workspace） 在本地的代码库，新增和修改的文件会提交到暂存区 暂存区（stage） 用于临时存放文件的修改，实际上是一个文件（. Git&#x2F;index），保存待提交的文件列表 仓库（repository） Git 的管理仓库，记录文件状态的地方，所有的代码版本都在里面 远程仓库（origin&#x2F;remote） 专用的 git 服务器，为多人提供共享服务。本地的仓库通过 &#x3D;&#x3D;push&#x3D;&#x3D;命令将代码推送到远程仓库里 本地仓库 本地电脑内直接使用的版本库 分支（Branch） 分支是从主线分离出的副本，可以独立操作而不干扰主线，仓库初始化后会有一个默认主分支“master”或“main” 头（HEAD） HEAD 类似指针，指向当前活动分支的最新版本 提交（Commit） 将 stage 中的所有变更提交到当前仓库的活动分支 推送（Push） 将本地仓库的版本推送到远程仓库 拉取（Pull） 从远程仓库获取更新到本地仓库 获取（Fetch） 从远程仓库更新，作用同 pull，但是不会自动合并 冲突（Conflict） 多人对同一个文件进行修改后在远程仓库合并时会面临冲突，需要人工合并处理 合并（Merge） 对有 conflict 的文件进行合并操作，git 可以自动合并变更内容，无法自动处理的文件需要人工处理 标签（Tag） 标签指的是某个分支某个特定时间点的状态，可以理解为提交记录的别名，常用来标记版本。 main&#x2F;master 仓库的默认主分支 origin&#x2F;main 表示远程仓库的 main 分支 1.2 工作区&#x2F;暂存区&#x2F;仓库 图中的 objects 标识的区域为 git 的对象库，实际的位置是“. Git&#x2F;objects”目录中，里面包含了创建的各种对象和内容 当对工作区的修改&#x2F;新增文件执行 git add命令后，暂存区的目录树被更新，同时工作区修改&#x2F;新增文件的内容被写入 objects 的一个新的对象中，而该对象的 ID 被记录在 stage 的文件索引中 当执行 git commit时，stage 的目录树写入 objects 中，main 分支做出更新 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 git rm –cached “file” 命令时，会直接从暂存区删除文件，工作区则不做出改变 1.2.1 工作区本地计算机内的项目文件 1.2.2 暂存区（stage）暂存区是一个临时存储区域，包含即将提交到版本库中的文件快照常用命令 123git add filename # 将单个文件添加到暂存区git add . # 将工作区中的所有修改添加到暂存区git status # 查看哪些文件在暂存区中 1.2.3 版本库（Repository）版本库包含项目的所有版本历史记录，每次提交都会在版本库中创建一个新的快照，这些快照不可变，确保了项目的完整历史记录常用命令 1234git commit -m &quot;Commit message&quot; # 将暂存区的更改提交到本地版本库git log # 查看提交历史git diff # 查看工作区和暂存区之间的差异git diff --cached # 查看暂存区和最后一次提交之间的差异 1.2.4 三者之间的关系 工作区-&gt;暂存区 1git add 暂存区-&gt;版本库 1git commit -m &quot;Commit message&quot; 版本库-&gt;远程仓库 1git push origin branch-name 远程仓库-&gt;本地版本库 1234git pull origin branch-name# 或者git fetch origin branch-namegit merge origin/branch-name 1.3 Git 工作流程 1.3.1 1、克隆仓库如果你要参与一个已有的项目，首先需要将远程仓库克隆到本地： 12git clone https://github.com/username/repo.gitcd repo 1.3.2 2、创建新分支为了避免直接在 main 或 master 分支上进行开发，通常会创建一个新的分支： 1git checkout -b new-feature 1.3.3 3、工作目录在工作目录中进行代码编辑、添加新文件或删除不需要的文件。 1.3.4 4、暂存文件将修改过的文件添加到暂存区，以便进行下一步的提交操作： 1git add filename 或者添加所有修改的文件 1git add . 1.3.5 5、提交更改将暂存区的更改提交到本地仓库，并添加提交信息： 1git commit -m &quot;Add new feature&quot; 连接远程仓库 1git remote add origin [git@github.com] 1.3.6 6、拉取最新更改在推送本地更改之前，最好从远程仓库拉取最新的更改，以避免冲突： 1git pull origin main 或者如果在新的分支上工作 1git pull origin new-feature 1.3.7 7、推送更改将本地的提交推送到远程仓库： 1git push origin new-feature 1.3.8 8、删除分支如果不再需要新功能分支，可以将其删除： 1git branch -d new-feature 或者从远程仓库删除分支： 1git push origin --delete new-feature 2 Git 指令 3 Git 分支Git 仓库在 fork 中打开后界面如下：可以看到每一个分支相互平行，只有完成某些项目的开发时才会合并到主分支。那么分支有什么用呢？当计划开发一个新的功能时，第一天完成了百分之 50，如果直接提交到 master 分支，则可能导致别人无法开发，如果全部写完再提交的话又可能因为意外丢失之前的进度。此时就体现出来分支的优越性了。我们可能创建一个属于自己的别人不可见的分支，在这个分支上开发提交代码不会影响他人，可以随意操作，等到开发结束了再一次性合并到 master 分支。 3.1 Git 分支常用命令12345678910111213141516171819git branch # 列出所有本地分支git branch -r #列出所有远程分支git branch -a #列出所有本地和远程的分支git branch [new-branch-name] #创建一个新的分支，但停留在当前分支git checkout -b [new-branch-name] #创建一个新的分支，并切换到该分支git branch --track [branch] [remote-branch] #创建一个新分支，并与指定的远程分支建立追踪关系git checkout [new-branch-name] #切换到指定分支，并更新工作区git merge [branch] #合并指定分支到当前分支git branch -d [branch] #删除分支git push origin --delete [branch] #删除远程分支","categories":[],"tags":[{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"}]},{"title":"脉冲成形滤波器","slug":"脉冲成形滤波器","date":"2024-11-20T16:00:00.000Z","updated":"2025-07-14T09:45:39.688Z","comments":true,"path":"2024/11/21/脉冲成形滤波器/","permalink":"https://www.moerjielovecookie.icu/2024/11/21/%E8%84%89%E5%86%B2%E6%88%90%E5%BD%A2%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"","text":"数字信号要想在信道中传输，必须在发射机的基带部分进行脉冲成型，将数字信号转化为脉冲信号；脉冲信号到达接收机后，在基带部分进行采样判决后恢复出数字信号。 1 脉冲成形1.1 矩形脉冲最容易实现的脉冲波形就是矩形脉冲，以数字信号“00010110”为例，在发射端可以将“0”映射为正脉冲，“1”映射为负脉冲。在接受端采样时刻的信号电平为正电平则为“0”，信号电平为负电平则为“1”。但是矩形脉冲信号的频谱为无限宽，所以在带宽有限的信道传输时会发生失真，甚至可能导致采样判决失真，无法恢复出数字信号。 1.2 Sinc 脉冲Sinc 脉冲信号有两个优点： Sinc 信号的频谱带宽是有限的，经过带宽有限的信道进行传输时不会出现失真。 一个码元达到最大幅值时其他码元的幅值刚好为 0，码元之间不会相互影响，实现无码间串扰。以数字信号 00010110 为例，0 映射为正脉冲，1 映射为负脉冲。发射端经过脉冲成形后的波形如下：接收端的采样判决如下： 2 基带滤波器2.1 理想低通滤波器如果要脉冲成形为 sinc 波形，只要将单位冲激信号输入理想 LPF 即可得到 sinc 脉冲信号。如果 LPF 的带宽为 B，则输出的 sinc 脉冲信号波形如下：只要 sinc 脉冲信号发送间隔设为 $\\frac{1}{B}$，也就是码元传输速率 $R_B&#x3D;2B$，就可以实现无码间串扰。 2.2 升余弦滚降滤波器采用理想低通滤波器对单位冲激信号进行滤波得到的 sinc 脉冲信号，拖尾振荡幅度比较大、衰减速度比较慢，当定时出现偏差时，码间串扰会比较大。考虑到实际的系统总是存在一定的定时误差，所以脉冲成形一般不采用理想低通滤波器，而是采用升余弦滚降滤波器，这种滤波器拖尾振幅小、衰减快，对于减小码间串扰和降低对定时的要求都有利。升余弦滚降滤波器的频率响应为：$$\\begin{aligned}&amp;\\mathrm{H}(f)&#x3D;\\begin{cases}\\frac{1}{2B},&amp;0\\leqslant\\left|f\\right|&lt;\\left(1-\\alpha\\right)B\\\\frac{1}{4B}\\left{1+\\cos\\frac{\\pi}{2B\\alpha}\\Big[\\left|f\\right|-B\\left(1-\\alpha\\right)\\right]\\Big},&amp;(1-\\alpha)B\\leqslant|f|&lt;(1+\\alpha)B\\0,&amp;\\left|f\\right|\\geqslant\\left(1+\\alpha\\right)B \\\\end{cases}\\end{aligned}$$其中，$B&#x3D;\\frac{R_B}{2}$升余弦滚降滤波器的频率响应曲线如下：升余弦滚降滤波器的单位冲激响应为：$$\\mathrm h(t)&#x3D;\\mathscr{F}^{-1}\\big[\\mathrm H(f)\\big]&#x3D;\\mathrm sinc\\big(2Bt\\big)\\frac{\\cos\\big(2\\pi\\alpha Bt\\big)}{1-\\big(4\\alpha Bt\\big)^2}$$其中 $\\alpha$ 是升余弦滚降滤波器的一个很重要的参数，称为滚降系数。当 $\\alpha&#x3D;0$ 时，升余弦滚降滤波器就是一个带宽为 B 的理想低通滤波器。当 $\\alpha&#x3D;0.5$ 时，升余弦滚降滤波器的频率响应和单位冲激响应如下：此时滤波器的带宽为 $（1+\\alpha）B&#x3D;1.5B$。当 $\\alpha&#x3D;1$ 时，升余弦滚降滤波器的频率响应和单位冲激响应如下：此时滤波器带宽为 $（1+\\alpha）B&#x3D;2B$。在使用升余弦滚降滤波器进行脉冲成形时，要想实现无码间串扰，则脉冲信号之间的时间间隔必须为 $\\frac{1}{2B}$，即码元速率为 $R_B&#x3D;2B$。由于升余弦滚降滤波器会展宽带宽，因此在给定码元速率 $R_B$ 的情况下，基带信号的频谱带宽为 $(1+\\alpha)\\times \\frac{R_B}{2}$。 3 眼图眼图可以用来评估一个系统的码间串扰情况。","categories":[],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"FPGA中的电平标准","slug":"FPGA中的电平标准","date":"2024-11-15T16:00:00.000Z","updated":"2025-04-27T12:28:31.000Z","comments":true,"path":"2024/11/16/FPGA中的电平标准/","permalink":"https://www.moerjielovecookie.icu/2024/11/16/FPGA%E4%B8%AD%E7%9A%84%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/","excerpt":"","text":"FPGA 在与外界进行信息交换时，为了确保信息的正确性，发送和接收信息都要对信息有认定的标准。在数字电路中，我们常用电压高低来表示“0”和“1”，那么多高的电压才会被当作“1”呢，这个时候就需要一个标准，这个标准就是电平标准。 常见电平标准 TTLTTL (Transistor - Transistor Logic，三极管 - 三极管逻辑电平) 是电平标准中的元老级成员。在早期的数字电路中有广泛的应用，但是它有一些缺点，比如高电平的判决门限和供电电压之间的电压空间较大，容易造成信号的不稳定性；而且 5 V 的电压过于耗电。 LVTTLLVTTL（Low Voltage Transistor - Transistor Logic，低压 TTL 电平标准）改进了 TTL 的缺点，将供电电压改为了 $3.3V$，功耗也相应降低了，而且提升了信号稳定性。 CMOSCMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体电平）的特点是功耗较低，可以根据电路的工作状态自动调整功耗。 LVCMOSLVCMOS（Low Voltage Complementary Metal Oxide Semiconductor，低压 CMOS 电平标准）在 CMOS 的基础上进一步降低供电电压，降低功耗。LVCMOS 在低功耗、中低速数字电路中非常受欢迎。 LVDSLVDS，全称是Low Voltage Differential Signaling，是一种利用低压差分信号传输高速信号的电平标准，有低压，低功耗，噪声抑制能力强的特点。LVDS 的输出电压摆幅极小，只有 $\\pm 350mV$，电流只有 $3.5mA$ 左右。由于其超低功耗和超快数据传输速率，常用于高速数据传输。","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"电路中的电平标准","slug":"电路中的电平标准","date":"2024-11-15T16:00:00.000Z","updated":"2025-07-14T09:45:19.570Z","comments":true,"path":"2024/11/16/电路中的电平标准/","permalink":"https://www.moerjielovecookie.icu/2024/11/16/%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/","excerpt":"","text":"FPGA 在与外界进行信息交换时，为了确保信息的正确性，发送和接收信息都要对信息有认定的标准。在数字电路中，我们常用电压高低来表示“0”和“1”，那么多高的电压才会被当作“1”呢，这个时候就需要一个标准，这个标准就是电平标准。 1 常见电平标准 1.1 TTLTTL (Transistor - Transistor Logic，三极管 - 三极管逻辑电平) 是电平标准中的元老级成员。在早期的数字电路中有广泛的应用，但是它有一些缺点，比如高电平的判决门限和供电电压之间的电压空间较大，容易造成信号的不稳定性；而且 5 V 的电压过于耗电。 1.2 LVTTLLVTTL（Low Voltage Transistor - Transistor Logic，低压 TTL 电平标准）改进了 TTL 的缺点，将供电电压改为了 $3.3V$，功耗也相应降低了，而且提升了信号稳定性。 1.3 CMOSCMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体电平）的特点是功耗较低，可以根据电路的工作状态自动调整功耗。 1.4 LVCMOSLVCMOS（Low Voltage Complementary Metal Oxide Semiconductor，低压 CMOS 电平标准）在 CMOS 的基础上进一步降低供电电压，降低功耗。LVCMOS 在低功耗、中低速数字电路中非常受欢迎。 1.5 LVDSLVDS，全称是Low Voltage Differential Signaling，是一种利用低压差分信号传输高速信号的电平标准，有低压，低功耗，噪声抑制能力强的特点。LVDS 的输出电压摆幅极小，只有 $\\pm 350mV$，电流只有 $3.5mA$ 左右。由于其超低功耗和超快数据传输速率，常用于高速数据传输。","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"Matlab R2024b安装本地文档","slug":"Matlab R2024b安装本地文档","date":"2024-10-27T16:00:00.000Z","updated":"2025-07-14T12:21:30.403Z","comments":true,"path":"2024/10/28/Matlab R2024b安装本地文档/","permalink":"https://www.moerjielovecookie.icu/2024/10/28/Matlab%20R2024b%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0%E6%96%87%E6%A1%A3/","excerpt":"","text":"安装包 通过网盘分享的文件：MATLAB R2024b链接: https://pan.baidu.com/s/1T8-V_guBJhSD-Yze0wEVmQ?pwd&#x3D;9h5c 提取码: 9h5c–来自百度网盘超级会员v2的分享 1 挂载后导航到镜像中的安装包文件夹1cd &lt;mountedDocImage&gt;/bin/&lt;arch&gt; &lt;mountedDocImage&gt; 是装载的文档 ISO 或 DMG 镜像的根目录。 &lt;arch&gt; 是 ISO 或 DMG 镜像的操作系统架构文件夹，例如 win64、glnxa64、maci64 或 maca64 2 使用mpm install-doc命令运行文档安装程序为了将文档安装到指定的位置，要使用**—destination命令，用—source**命令指定安装程序文件路径 12.\\mpm install-doc --matlabroot=&lt;matlabrootfolder&gt; --source=&lt;docinstallfolder&gt; --destination=&lt;destinationfolder&gt; 3 配置MATLAB 预设项中，将帮助中的文档位置选为本地 在userpath中创建startup.m文件，使用docroot命令 指定帮助文档的路径 4 验证本地安装验证文档是否在本地打开。在 MATLAB 命令提示符下，输入：doc 在打开的浏览器页面中，检查 URL 的地址。 如果 URL 指向本地 IP 地址和端口号（例如 http://127.0.0.1:12345），则 MATLAB 访问的是本地安装的文档。 如果 URL 指向 Web 地址（例如 https://www.mathworks.com/help/...），则 MATLAB 访问的仍然是 Web 文档。更新 MATLAB 以指向本地安装的文档，如配置 MATLAB 以使用安装的文档中所述。 $$ $$","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"DVB-S系统设计报告","slug":"DVB-S系统设计报告","date":"2024-10-19T16:00:00.000Z","updated":"2025-08-13T01:16:33.190Z","comments":true,"path":"2024/10/20/DVB-S系统设计报告/","permalink":"https://www.moerjielovecookie.icu/2024/10/20/DVB-S%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/","excerpt":"","text":"1 DVB标准Digital Video Broadcasting（数字视频广播）是一个完整的数字电视解决方案，其中包括DVB-C（数字电视有线传输标准），DVB-T（数字电视地面传输标准），DVB-S（数字电视卫星传输标准），下面主要介绍DVB-S系统。 DVB-S为数字卫星广播标准，卫星传输具有覆盖面广、节目容量大等优点。信号采用RS(188，204)和卷积码的级联编码，调制方式为QPSK。 2 DVB-S信道编码及调制的基本原理2.1 原理框图根据ETSI的DVB-S标准，原理框图如下所示 由于卫星提供的DTH服务特别受功率限制的影响，因此主要的设计目的应该为抗噪声和干扰，而不是频谱效率。为了在不过度损害频谱效率的前提下实现很高的能量效率，系统应使用QPSK调制和卷积码和RS码的级联。 2.2 接口 2.3 信道编码2.4 TS流适配单元（adaptation）输入的TS流根据MPEG-2格式按照固定的长度打包，数据包的长度为188，帧头为同步字 。DVB-S标准中要求每8个TS数据包组成一个超帧，将超帧中的8个同步头进行反转，变为，其余的同步头不变。同时还要自动插入空包，在数据包后插入16个0，将长度为188的数据包包补充成长度为204的数据包，与后续的信道编码模块建立时钟匹配和接口连接。 2.5 扰码单元（energy dispersal）基带信号中含有很多连“1”或者连“0”的现象，会导致基带信号的频谱中含有较多的低频成分，既不利于信号在信道的传输，也不利于在接收端提取时钟信号。因此采用扰码，将TS流转化成伪随机序列。DVB-S标准中的随机化的原理图如下： 伪随机二进制序列的生成多项式如下： 扰码以8个数据包组成的超帧为单位进行处理，在每一个单元开始处理时，将序列”100101010000000“装入寄存器，对其进行扰码处理。数据包的同步字不进行扰码处理。 2.6 RS编码外码采用RS编码，其具有同时纠正随机错误和突发错误的能力，并且纠正突发错误更有效。DVB-S采用的编码格式为RS(239,255)截断而得到的RS(188,204)编码，最大可纠错长度为8个字节，编码从同步字或开始。 2.7 编码原理简述假设信息多项式为 码生成多项式为 其中的_a_ = 02_hex_，则生成多项式的展开式为 将除以后，余式为关于x的15次多项式，其16个系数即为生成的16个校验字节，将其添加到188长度的数据包后即可完成RS(188,204)的编码。 2.8 卷积交织在数字信号传输过程中，由于一些突发性干扰，会导致一连串的数据错误，很有可能超出RS码的纠错范围。而卷积交织可以将错误的字符分散开，使得信道变成近似无记忆信道。DVB-S中采用的是交织深度为12的卷积交织。交织和解交织的框图如下： 2.9 卷积编码内码采用的是(2,1,7)型的卷积码，编码效率为，由6个移位寄存器和2个模二加加法器构成，1个bit信号生成2个bit的编码信号，约束长度为7。 当信道质量较好时可以对编码信号进行删余，提高信道利用率。 3 Matlab仿真3.1 TS流适配及扰码模块 3.1.1 CLKdivide一路高清电视信号的码率为，因此二进制信号的速率为，输入的数据为类型，所以输入的信号速率为。所以CLKdivide模块将的时钟分频到和。 3.1.2 sigSource此模块产生输入的TS流信号，并且生成RS编码的开始、结束和使能信号。由于每输出一个188字节长度的数据包后要暂停输出TS流插入空包，所以采用使能系统，每计数188次后拉低使能插入空包。 3.1.3 HeaderProcess此模块对输入的TS流进行速率转换和组超帧，每八个数据包组合为一个超帧，并反转第一个同步字，由转为，并生成使能sigSource的信号。同时生成扰码模块的控制信号。 第一个Multiport Switch用来进行插入空包，第二个Multiport Switch用来反转超帧的第一个同步字。 3.1.4 myScrambler根据扰码的生成多项式进行设计。HeaderProcess生成的扰码使能信号正好在输入同步字时拉低，不进行扰码处理，扰码复位信号在输入了一个超帧后重新装入初始序列”100101010000000“。 3.1.5 仿真数据 3.2 RS编码模块 使用HDL Coder中的模块，由于时钟速率为200 ，因此需要加入一个触发模块，保证RS编码是按照码元速率进行编码 3.3 卷积交织 同样加入触发模块，保证交织的速度为码元速率。 3.4 uint8转binary模块 首先对输入的数据按位相与，取出每一位的数据后使用Multiport Switch逐位输出，计数器的使能速率为码元速率的8倍。 3.5 卷积编码 不进行删余的话，编码效率为。也可以进行删余，可以得到、、、的编码效率。在一定带宽内，编码效率越大传输效率越大，同时纠错能力越差。 4 Vivado实现Vivado的代码大部分都由HDL Coder生成，或者由Matlab生成系数文件，再导入到Vivado的IP核中。 4.1 DataSource_Scrambler直接生成hdl代码的话，DataSource_Scrambler模块中的sigSource模块在200 的频率下建立时间的裕量不满足时序，因此在生成HDL之前进行如下配置： 在输出端加入一级流水线后，综合布线后时序即可通过。同时在这个模块的输出信号处全部加上一个delay模块组成流水线。 4.1.1 扰码模块 可以看到每输入8个数据包后，扰码内部的D触发器的初值得到重置，同时反转后的同步字没有被扰码处理。 4.1.2 数据对齐在仿真过程中，发现同步字和RS编码的使能信号没有对齐，因此添加如下模块： 在将输出的使能信号延后一个数据周期，即可保证信号的同步。 4.2 RS编码将modelsim的数据导入到matlab进行解码，可以看到将188个数据包完整的解了出来。 4.3 升余弦滚降滤波器4.3.1 Matlab滤波器设计根据DVB-S标准的要求，升余弦滚降系数为，使用Matlab的filterDesigner工具设计滤波器系数。 在FPGA中要对滤波器系数进行定点化处理。 对系数进行32位量化后幅值响应如下： 对系数进行16位量化后幅值响应如下： 可以看出16位量化的幅值响应和32位量化的响应几乎一样，为了节省空间，因此使用16位量化。 量化结束后点击目标→Xilinx系数文件 生成coe文件。 4.3.2 Vivado Fir滤波器设计选择 Source为COE FIle 输入的采样频率要和时钟频率相等，不进行过采样。 在Implementation中将系数类型选择为有符号数，位宽设置为16。 输入的信号为正负1，所以输入的位宽为2，第一位为符号位。输出模式设置为全精度。 4.3.3 波形 5 使用XDMA进行数据的输入和输出采集 结构框图如上。 工程的总体结构如上所示，数据通过XDMA的M_AXIS_H2C接口写入数据。由于写入数据的位宽为128bit，工程中信号处理部分的输入位宽为8bit，因此加入AXISDataWidthConverter模块将位宽从16BYTE转为1BYTE，并写入FIFO，使用AXIGPIO模块读取FIFO的almost full信号，如果FIFO被写满，almost full被拉高，就停止写入数据。读取DVB-S生成的QPSK信号时，由于经过了升余弦滚降滤波和调制，信号的位宽已经较大，为了降低复杂度选择将调制信号高位补零至128bit后经M_AXIS_C2H接口输出到Host主机。 调试过程见","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"Report","slug":"Report","permalink":"https://www.moerjielovecookie.icu/tags/Report/"}]},{"title":"ZYNQ","slug":"ZYNQ","date":"2024-09-26T16:00:00.000Z","updated":"2025-04-27T12:28:32.000Z","comments":true,"path":"2024/09/27/ZYNQ/","permalink":"https://www.moerjielovecookie.icu/2024/09/27/ZYNQ/","excerpt":"","text":"ZYNQ 体系结构Zynq 的总体架构包含两个部分：PS（处理器系统）和 PL（可编程逻辑）。这两部分的供电电路上相互独立的，因此 PS 和 PL 可以单独使用，不被使用的部分可以断电以降低功耗。不过 Zynq 最有价值的模式上两个组成部分结合起来使用。 PS（处理器系统）作为处理器系统的基础，所有芯片都包含一颗双核的 ARM Cortex- A 9 芯片。这是一颗硬处理器，是芯片上专门且优化过的硅片元件。 除了“硬”处理器，还有另外一种方案，像是 MicroBlaze 这样的“软”处理器，这是由 PL 端端单元组合成的，即和 PL 端的 IP 是等价的。相比之下，“硬”处理器可以获得相对较高的性能，“软”处理器的数量和精确实现是灵活的。 值得一提的是，可以在 zynq 的 PL 端分配一个或多个 MicroBlaze 软处理器，用于和硬核协同工作。比如可以让软核负责协调特定的底层功能和系统之间的配合，将要求不高的任务从硬核上脱离出来，提高整体性能。 Zynq 的 PS 端里面并非只有 ARM 处理器，还有一组相关的处理资源，构成一个应用处理器单元（Application Processing Uint，APU），另外还有扩展外设接口、cache 存储器、存储器接口、互联接口和时钟发生电路。 PL（可编程逻辑）Zynq 中的逻辑部分是基于 Artix 7 和 Kintex 7 的 fpga 组件。 逻辑部分 可配置逻辑块（CLB）—— CLB 是逻辑单元的小规模、普通编组，在 PL 中排列为一个二维阵列，通过可编程互联连接到其他类似的资源。每个 CLB 内都含有两个逻辑片，并紧邻一个开关矩阵。 片（Slice）—— CLB 里的子单元，里面有实现组合和时序逻辑电路的资源。 查找表（Lookup Table，LUT）—— 一个灵活的资源，可以实现 至多 6 个输入的逻辑函数 一小片只读存储器（ROM） 一小片随机访问存储器（RAM） 一个移位寄存器 LUT 可以按需组合形成一个更大的逻辑函数、存储器或移位寄存器。 触发器（Flip-flop，FF）—— 一个实现一位寄存的时序电路，带有复位功能。其中一个用处是实现锁存。 开关矩阵（Switch Matrix）—— 每个 CLB 旁边都有一个开关矩阵，实现灵活的布线功能来连接 CLB 内的单元，或把 CLB 与 PL 内的其他资源连接起来。 进位逻辑（Carry Logic）—— 算术电路需要在相邻的片之间传递信号，这就是通过进位逻辑来实现的。 输入/输出块（IOB）—— IOB 实现了 PL 逻辑资源之间的对接，并提供物理设备“焊盘”来连接外部电路。每个 IOB 可以处理一位的输入或输出信号，IOB 一般位于芯片的周边。 特殊资源：DSP 48 E 1 和 BRAM这两个资源都按列排列集成在逻辑阵列中，嵌入在逻辑部分中，而且彼此靠近，原因是密集计算和给内存中存储数据往往是紧密联系的运算。 BRAMZynq-7000 的 BRAM 和其他 Xilinx 7 系列 FPGA 里的 BRAM 是相同的，都可以实现 RAM、ROM、FIFO，同时还支持纠错编码。 每个 BRAM 里最多可以存储 36 KB 的信息，可以被配置为一个 36 KB 的 RAM 或者两个独立的 18 KB 的 RAM。还可以被“重塑”来包含更多的更小的单元，或者组合起来组成更大容量大 RAM。 使用 BRAM 意味着能在芯片内部优化的专用存储单元内，用很小的物理空间存储大量的数据。另一种方法是分布式 RAM（Distributed RAM），DRAM 是用逻辑部分里的 LUT 来搭建的，想要构成和 BRAM 大小相当的的存储器，需要用到大量的 LUT，而且实现的结果还受到剧增的逻辑和布线延迟所造成的时序性能受限的影响。另一方面，用 DRAM 实现小存储器是有优势的，这样资源利用率高，并且布局更灵活。BRAM 往往能工作在芯片支持的最高时钟频率下。 DSP 48 E 1逻辑部分的 LUT 可以用来实现任意长度的算术运算，但由于长字长的算术电路会在逻辑片内占据较大的空间，这样的布局和布线会导致时钟频率是次优的，因此最好拿 LUT 做短字长的运算。 DSP 48 E 1 是专门用于实现对长字长信号的高速算术运算的逻辑片，是专用的硅片资源，并且在逻辑单元内部包含了预加法器/减法器、乘法器和后加法器/减法器。 后加法器还可以用作逻辑单元，此时它可以做逻辑运算，支持所有的基础布尔运算。 如果需要更大字长的运算，可以将多个 DSP 组合起来做扩展。 通用输入/输出Zynq 上的通用输入/输出功能合起来被成为 SelectIO 资源，它们被组成 50 个 IOB 一组，每个 IOB 都有一个焊盘，与外部世界连接。 I/O 组分为高性能（High Preformance，HP）或高范围（High Range，HR）。HP 接口的电压最高为 1.8 V，通常用作连接存储器和其他芯片的高速接口；HR 接口允许 3.3 V 的电压，适合做各种 IO 标准的连接。两种接口都支持单端和差分信号。 每个 IOB 还包含一个 IOSERDES 资源，可以做并行和串行的可编程转换，数据位宽是 2～8 位。 通信接口Zynq 内部含有嵌入在逻辑部分里的 GTX 收发器和高速通信接口块。 其他可编程逻辑扩展接口 ADC—— XADC，具有两个独立的 12 位 ADC，每个采样率为 1 Msps。 时钟—— PL 接收来自 PS 的四个独立的时钟输入，另外还能产生和分发它自己的与 PS 无关的时钟。 JTAG 调试接口 PS 与 PL 之间的接口如前所述，Zynq 的表现不仅仅依赖于它的两个组成部分 PS 和 PL 的特性，还在于能把两者协同起来形成完整、集成的系统的能力。这其中起关键作用的，是一组高度定制的 AXI 互联和接口用来在两个部分之间形成桥梁。另外，在 PS 和 PL 之间还有一些其他类型的连接，特别是 EMIO。 AXI高级可扩展接口（Advanced eXtensible Interface）。当前版本为第四代 AXI 4 。 AXI 4用于存储映射连接，支持最高的性能，通过一簇高达 256 个数据字的传输来给定一个地址。 AXI 4-Lite简化的连接，只支持每次传输一个数据。AXI 4 Lite 也是存储映射的，每次传输一个地址和单个数据。 AXI 4-Stream用于高速流式数据，支持批量传输无线大小的数据。没有地址机制，适合源与目的之间的直接数据流。 EMIO 接口EMIO 涉及两个域之间的传输，是由一组简单的导线连接实现的。 EBAZ 4205 矿板资料汇总扩展版ebaz4205拓展板 - 立创开源硬件平台 (oshwhub.com) 开发板补全从零开始的ZYNQ学习（基于矿卡EBAZ4205）（一）-CSDN博客 原理图相关矿板原理图 Elrori/EBAZ4205: EBAZ4205 BOARD (github.com) PCB EBAZ4205-master.zip bookmark","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"HDL coder使用手册","slug":"HDL coder使用手册","date":"2024-09-20T16:00:00.000Z","updated":"2025-04-27T12:28:31.000Z","comments":true,"path":"2024/09/21/HDL coder使用手册/","permalink":"https://www.moerjielovecookie.icu/2024/09/21/HDL%20coder%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"","text":"由于本科毕设女朋友准备使用FPGA完成，因此写这篇文章帮助她快速上手HDL coder的使用，降低前期入门的难度。 支持生成HDL代码的simulink库 名字中含有HDL的库中的模块一般都可以用来生成HDL代码。直接搜索模块名称，比如搜索fir， 可以看到旁边会显示位于哪个库中，模块有可能位于多个库，只要有一个库的名字里面有HDL，就代表这个模块可以用来生成HDL代码。 一些常用操作创建子系统将库中的模块拖到主界面组合好后，可能会占据很大的空间，如果工程较大，模块越连越多就特别臃肿，因此当我们完成某个功能以后，就可以将这部分的模块全部选中，此时右下角会出现三个点，将鼠标移到上面后会展开，出现很多不同的功能。下图是一个AM调制的过程，可以看到选中所有相关的模块后点击创建子系统，即可得到右图的子系统。刚生成的子系统的命名为subsystem，可以将命名改为更清晰易懂的名字。 观察节点的信号波形当选中某根连线时，同样会出现三个点，鼠标移动到上面后会展开，选择WiFi形状的选项即可记录该连线上的信号。运行仿真后再次点击WiFi图标即可打开逻辑分析仪，即可查看该连线上的信号。 逻辑分析仪内部选中某个信号后即可在波形中调节数制、高度等设置。 也可以使用scope模板看节点信号。 频谱分析使用Spectrum Analyzer模块进行频谱分析。 当样点比较少的时候可以将估计方法改为welch。 信号数据格式显示 可以显示模块输入输出信号的数据类型和小数位数。 采样时间一栏中的时间图例选中以后，会用不同的颜色显示不同采样速率的模块，在多速率系统设计中有很大的用处。 生成HDL代码前期准备设置诊断类型 模型设置中选择诊断&#x2F;采样时间 单任务和多任务数据传输必须设置成错误。 兼容性检测 选择代码生成的目标文件夹，运行兼容性检查器，如果工程没有问题的话会出现如下界面 目标平台选择 根据使用的FPGA选择综合工具和FPGA的系列。 模块设置在要生成代码的子系统上右键，选择HDL模块属性： 可以对流水线、乘法器等参数进行设置 如果生成的代码在EDA工具中编译以后无法满足时序约束，可以加输入和输出的流水线 💡 如果模块的输出对前面的模块有反馈信号的话不能添加流水线，详细见bookmark [bookmark](https://blog.sawenmoerjie.top/article/ec96aebc-b5a5-4059-bbef-02f0003e7a45) 代码生成 点击为子系统生成HDL代码后会自动进行一次编译，命令行窗口会出现如下信息 同时会生成一个report 没有报错的话即可在上面选择的文件夹里面看到生成的Verilog代码文件 将这些文件导入到EDA工具中即可直接例化使用。 💡 所有文件都要导入，不能只导入需要的某个名字的模块！ 💡 一定要看EDA软件编译后的报告，尤其是大型设计，很容易不满足时序要求，这个时候就要回去simulink里面优化设计，如果时序报告里面是A模块的某个地方时序满足不了要求，那么就要在simulink中在A模块中添加流水线。（注：Quartus中我没有遇见过时序报错的，可能是没有在Quartus中开发大工程）","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"多速率信号处理-半带滤波器","slug":"多速率信号处理-半带滤波器","date":"2024-09-09T16:00:00.000Z","updated":"2025-07-14T12:11:23.826Z","comments":true,"path":"2024/09/10/多速率信号处理-半带滤波器/","permalink":"https://www.moerjielovecookie.icu/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8D%8A%E5%B8%A6%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"","text":"半带滤波器本质上是FIR滤波器，但是有近一半的系数为0，因此运算量降至普通FIR滤波器运算量的一半。 半带滤波器具有如下特性： 半带滤波器的通带宽度（通带截止频率）与阻带宽度（为阻带起始频率）相等，通带纹波和阻带纹波页相等 半带滤波器的频率响应满足 单位冲激响应满足 当为偶数时当时 N为滤波器长度，必须为奇数","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"多速率信号处理-Nobel恒等式","slug":"多速率信号处理-Nobel恒等式","date":"2024-09-09T16:00:00.000Z","updated":"2025-07-14T12:11:40.551Z","comments":true,"path":"2024/09/10/多速率信号处理-Nobel恒等式/","permalink":"https://www.moerjielovecookie.icu/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-Nobel%E6%81%92%E7%AD%89%E5%BC%8F/","excerpt":"","text":"典型的插值器的结构，滤波器位于插值操作后，意味着滤波器工作在较高的采样率下，对滤波器的设计带来压力。可以通过恒等变换将插值操作后置，滤波器前置，简化系统的设计。 1 第一恒等式表明抽取操作位于乘加操作之后和抽取操作位于乘加之前是等效的。 2 第二恒等式M个延迟之后再进行M抽取和M抽取之后再进行1个延迟是等效的。 3 第三恒等式信号通过滤波器H（zM ）并经M抽取后与信号通过M抽取并经滤波器H（z）是等效的 4 第四恒等式插值操作位于乘加之前与插值操作位于乘加之后是等效的 5 第五恒等式信号先经1个延迟再做L插值与先经L插值再做L个延迟是等效的 6 第六恒等式信号先经滤波器$H(z)$再做L插值与信号先做L插值再经滤波器$H(z^L)$是等效的","categories":[],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"多速率信号处理-插值和插值滤波器","slug":"多速率信号处理-插值和插值滤波器","date":"2024-09-09T16:00:00.000Z","updated":"2025-07-14T11:45:41.551Z","comments":true,"path":"2024/09/10/多速率信号处理-插值和插值滤波器/","permalink":"https://www.moerjielovecookie.icu/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E6%8F%92%E5%80%BC%E5%92%8C%E6%8F%92%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"","text":"插值意味着提高采样率，故而被称为上采样（Up Sample）。设原始序列为，采样率为，插值因子为，则插值的过程为原始序列每相邻两个样点之间插入个构成一个新序列，数学表达式为其他以表示的采样率，则采样率之间的关系为 图示如下： 从频域角度看， 原始序列的频谱以为周期做周期延拓。 插值后的新序列以新的采样率做周期延拓。 可以看到插值前后频谱成分不变，但是在的整数倍频点处的频谱称为镜像成分。所以插值后要加入一个低通滤波器滤除镜频。典型的插值器就是由上采样器和抗镜像滤波器共同完成的。 由于插值是在原始序列中插入零值，即某些采样点处的信号幅度为0，会改变信号的幅度，因此插值会造成信号幅度的损失。要保证插值前后信号幅度的统一，可在插值滤波器后设置一个增益因子L。","categories":[],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"多速率信号处理","slug":"多速率信号处理","date":"2024-09-09T16:00:00.000Z","updated":"2025-05-21T01:25:59.182Z","comments":true,"path":"2024/09/10/多速率信号处理/","permalink":"https://www.moerjielovecookie.icu/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/","excerpt":"","text":"随着芯片技术的发展，ADC的采样率越来越高，导致数字化越来越靠近系统前端。目前，工程上采用较多的是中频采样技术，即在中频时就对模拟信号数字化，此时ADC的采样率低于奈奎斯特采样定律的最低采样率（2倍的信号带宽），为过采样。过采样可以将采样过程的固有的量化噪声均匀地分散在更大的带宽上，降低目标信号带宽上的噪声功率，随后通过滤波器滤除带外噪声，即可产生比临界采样信号更优的信噪比。 当信号被ADC采样并传输到FPGA时，信号就进入了数字域。然而过高的采样率会对后续的信号处理带来较大压力，为了缓解压力，就需要降低信号的采样率，即为抽取。抽取后的信号数据率相对较低，因而有效地降低了对FPGA资源的占用，同时有助于简化系统的时序收敛。 当驱动高速率DAC时，需要提高信号的采样率，即为内插。因为DAC的采样率越高，输出端的频谱的频域分离度就越高，可以简化DAC后的模拟滤波器的工作，从而提高信噪比。 多速率信号处理的典型应用即为数字上变频DUC（Digital Up Conversion）和数字下变频DDC（Digital Down Conversion）。","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"Matlab的4个取整函数","slug":"Matlab的4个取整函数","date":"2024-09-02T16:00:00.000Z","updated":"2025-07-14T12:21:13.514Z","comments":true,"path":"2024/09/03/Matlab的4个取整函数/","permalink":"https://www.moerjielovecookie.icu/2024/09/03/Matlab%E7%9A%844%E4%B8%AA%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0/","excerpt":"","text":"1 Round舍入至最近的小数或整数 Y = round(X) 将 X 的每个元素四舍五入为最近的整数。在舍入机会均等的情况下，即有元素的十进制小数部分为 0.5（在舍入误差内）时，round 函数会偏离零四舍五入到最接近的具有更大幅值的整数。 Y = round(X,N) 四舍五入到 N 位数： N &gt; 0：舍入到小数点_右侧_的第 N 位数。 N = 0：四舍五入到最接近的整数。 N &lt; 0：舍入到小数点_左侧_的第 N 位数。 示例 Y = round(X,N,type) 指定四舍五入的类型。指定 &quot;significant&quot; 以四舍五入为 N 位有效数（从最左位数开始计数）。在此情况下，N 必须为正整数。 示例 Y = round(___,TieBreaker=direction) 按照 direction 指定的方向对结值进行舍入。在上述语法中的任何输入参数组合后使用此参数。 示例 Y = round(t) 将 duration 数组 t 的每个元素四舍五入到最接近的秒数。 示例 Y = round(t,unit) 将 t 的每个元素四舍五入到指定单位时间的最接近的数。 2 Ceil向正无穷舍入 Y = ceil(X) 将 X 的每个元素四舍五入到大于或等于该元素的最接近整数。 示例 Y = ceil(t) 将 duration 数组 t 的每个元素四舍五入到大于或等于此元素的最接近的秒数。 示例 Y = ceil(t,unit) 将 t 的每个元素四舍五入到大于或等于此元素的最接近的数（使用指定的时间单位）。 3 Floor向负无穷舍入 Y = floor(X) 将 X 的每个元素四舍五入到小于或等于该元素的最接近整数。 示例 Y = floor(t) 将 duration 数组 t 的每个元素四舍五入到小于或等于此元素的最接近的秒数。 示例 Y = floor(t,unit) 将 t 的每个元素四舍五入到小于或等于该元素的最接近数（使用指定的时间单位）。 4 Fix向零舍入 Y = fix(X) 将 X 的每个元素朝零方向四舍五入为最近的整数。此操作实际上是通过删除 X 中每个数的小数部分，将它们截断为整数： 对于正数，fix 的行为与 floor 相同。 对于负数，fix 的行为与 ceil 相同。","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"2023年全国赛C题《 电容电感测量装置》设计报告","slug":"2023年全国赛C题《电容电感测量装置》设计报告","date":"2024-08-18T16:00:00.000Z","updated":"2025-07-14T12:10:04.772Z","comments":true,"path":"2024/08/19/2023年全国赛C题《电容电感测量装置》设计报告/","permalink":"https://www.moerjielovecookie.icu/2024/08/19/2023%E5%B9%B4%E5%85%A8%E5%9B%BD%E8%B5%9BC%E9%A2%98%E3%80%8A%E7%94%B5%E5%AE%B9%E7%94%B5%E6%84%9F%E6%B5%8B%E9%87%8F%E8%A3%85%E7%BD%AE%E3%80%8B%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/","excerpt":"","text":"1 测量原理参考下面网站的方案 bookmark 参考LCR测试仪，基本工作原理为给DUT加上正弦激励信号，然后测得该DUT两端的电压和流过DUT的电流，即可通过计算得到DUT的性质和参数。 对于一个理想电容，电流相位应该超前电容两端电压90°。然而实际的电容存在损耗，可以等效为一个理想电容$C_p$和一个理想电阻$R_p$的并联，因此电流超前电压的相位将小于90°，这个角度差即为损耗角。 假设DUT两端电压$\\dot{V}&#x3D;V\\cos(\\omega t)$，流过DUT的电流为$\\dot{I}&#x3D;I sin(\\omega t - \\varphi)$，电流在虚轴上的投影为流过理想电容的电流，在实轴上的投影为流过损耗电阻的电流。 因此可以计算出并联电容的容抗为$X_{Cp}&#x3D;\\frac{V}{I cos\\varphi}$，容值$C_P&#x3D;\\frac{1}{\\omega X_{Cp}}&#x3D;\\frac{I cos \\varphi}{\\omega V}$。 损耗电阻的值为$R_p&#x3D;\\frac{V}{Isin\\varphi}$。 定义元件消耗的无功功率和有功功率之比为元件的Q值，Q值的倒数为D值（损耗角正切） $$Q&#x3D;\\frac{R_P}{X_{Cp}}&#x3D;cot \\varphi, D&#x3D;\\frac{1}{Q}&#x3D;tan \\varphi$$ 上述需要的参数可以借助正交算法求得： $$\\begin{align}I\\sin(\\omega t-\\varphi)\\cdot V\\cos(\\omega t) &amp; &#x3D; \\frac12VI\\sin(2\\omega t-\\varphi)-\\frac12VI\\sin\\varphi\\I\\sin(\\omega t-\\varphi)\\cdot V\\sin(\\omega t) &amp; &#x3D; -\\frac12VI\\cos(2\\omega t-\\varphi)+\\frac12VI\\cos\\varphi \\end{align}$$ 相乘以后经过低通滤波器后即可得到直流成分$-\\frac{1}{2} VI sin\\varphi 和\\frac{1}{2} VI cos\\varphi$，即可求得题目要求的损耗角正切 $$tan\\varphi &#x3D; \\frac{VI sin \\varphi}{VI cos \\varphi}$$ 同时可求得以下参数 $$\\text{并联形式的理想电容的容抗 }X_{cp}&#x3D;\\frac V{I\\cos\\varphi}&#x3D;\\frac{V^2}{VI\\cos\\varphi} \\text{,电容为 }C_p&#x3D;\\frac1{\\omega X_{cp}},\\text{并联形式的损耗电阻}\\R_{p}&#x3D;\\frac V{I\\sin\\varphi}&#x3D;\\frac{V^2}{VI\\sin\\varphi}\\text{。其中 }V^2\\text{可以通过电压自乘后滤除高频成分后得到。}$$ 2 参数仿真现有的ADC的输入电压范围为0~2V，输入偏置为1V；DAC的输出电压范围为1V峰峰值，同时可以加偏置， 电容容值为1nF-100nF，检流电阻为0.33Ω时，输出电压峰峰值为4-200mv。测量电感时频率为1MHz，电感感值为10uF-100uF时，输出电压峰峰值为15-150mv。由于ADC模块的输入范围为0~2V，因此对信号进行9倍放大，峰峰值放大到1.8V左右。 2.1 调试记录DAC输出的信号和LC滤波器阻抗不匹配，导致LC滤波器的输入端信号幅值较低 待测元件检测电路上电后输入端有-500mv的偏置 LC滤波器设计如下，DAC输出1MHz的信号时高次谐波较为严重，因此设计一个通带为1.2MHz的LC低通滤波器滤除高次杂波。 3 PCB设计3.1 初代其中R8是用来连接测试夹具的，激励信号从P1输入，经过R8上的待测电容或电感后电流经过C5流入后级电流检测电路， 这样设计的话，电路的输入阻抗为测量夹具上的待测元件的在特定频率下的阻抗值，而前级放大器的输出阻抗为50Ω，会导致输入信号的幅值不是期望的幅值。 3.2 改进将前级放大器的输出端用于阻抗匹配的50Ω电阻拆掉，利用运放输出阻抗很低的特性，使得输出的信号的电压全都加在上面电路的输入端。 这样改进的原因是运放后级不带容性负载、LC滤波器、长同轴电缆的话输出端不需要接匹配电阻。 4 FPGA程序设计根据上面的原理，需要两个ADC采集电流和电压信号，1个DAC生成激励信号。因此选择DE0nano，有两个扩展的40pin排针，可以接入两个ADDA模块。 FPGA的晶振频率为50MHz，通过PLL分频出20MHz和80MHz，其中ADC的时钟为20M，DAC的时钟为80M。然后分别连接到ADC_Interface和DAC_Interface。 ADC部分采集到的信号位宽为10，舍弃低两位以便于后续对信号的处理，同时每采1024个样点后暂停0.5秒，然后再进行下次采集。 DAC部分采用一个NCO生成正弦波信号，通过拨码开关切换频率字，输出到DAC_interface后左移1位后输出，再通过一个同相放大器放大2倍，增强信号的驱动能力。 ADC采集到的电流和电压的数据存放到RAM中，通过改变起始的取地址来实现移相。使用的ADC的采样率为20M，采集100K的信号时，每个周期采集200个点，因此想要移相$\\frac{\\pi}{2}$时，只需要从50开始读取RAM里的数据，读出的信号即为从0开始读取的RAM的读出的信号进行$\\frac{\\pi}{2}$移相后的信号。 经ADC采集的数据为无符号数，做乘法滤波会和计算结果不匹配，因此再加入一级无符号转有符号数的module，转成有符号数后做乘法，再送入低通滤波器后即可获得需要的数值。对低通滤波器的输出进行截断，只保留高16位的数据，降低抖动的直流信号对结果的影响。 5 测量结果 第一个Lowpass的输出为$VIcos\\phi$，第二个Lowpass的输出为$\\frac{1}{2}VIcos \\varphi$，第三个Lowpass的输出为$V^2$，容抗的计算过程如下: 根据仿真的输入电流和输出电压的拟合关系可得，在输出采集的电压的幅值等于电流÷0.305，因此容抗为 第三个输出÷2÷第一个输出÷0.305 5.1 电路展示 6 后续计划加入spi通信，将采样计算出的数据传输到TI的开发板上进行进一步计算和显示。","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"Report","slug":"Report","permalink":"https://www.moerjielovecookie.icu/tags/Report/"},{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"黑金Alinx xc7z020 原理图","slug":"黑金Alinx xc7z020 原理图","date":"2024-07-22T16:00:00.000Z","updated":"2025-07-14T12:10:29.509Z","comments":true,"path":"2024/07/23/黑金Alinx xc7z020 原理图/","permalink":"https://www.moerjielovecookie.icu/2024/07/23/%E9%BB%91%E9%87%91Alinx%20xc7z020%20%E5%8E%9F%E7%90%86%E5%9B%BE/","excerpt":"","text":"1 时钟引脚1.1 CLK：U182 复位2.1 RST：N153 扩展接口3.1 J10 3.2 J11 4 PL LED 5 PL KEY","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"C标准库读写文件","slug":"C标准库读写文件","date":"2024-06-19T16:00:00.000Z","updated":"2025-07-14T11:43:38.763Z","comments":true,"path":"2024/06/20/C标准库读写文件/","permalink":"https://www.moerjielovecookie.icu/2024/06/20/C%E6%A0%87%E5%87%86%E5%BA%93%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/","excerpt":"","text":"1 函数介绍1.1 库变量 变量 描述 size_t 无符号整数类型，是sizeof关键字的结果，表示对象大小 FILE 文件流类型，适合存储文件流信息的对象类型 1.2 库宏 宏 描述 NULL 空指针常量 EOF 表示已经到达文件结束的负整数 stderr、stdin、stdout 指向FILE类型的指针，分别对应标准错误、标准输入和标准输出流 1.3 库函数1.3.1 fopen12FILE *fopen(const char *filename, const char *mode) //以给定的模式mode打开filename指向的文件 mode 描述 “r“ 打开一个用于读取的文件，文件必须存在 ”w“ 创建一个用于写入的空文件。若存在同名文件，则删除旧文件的内容 ”a“ 追加到一个文件，写操作向文件末尾追加数据，文件不存在就创建文件 ”r+“ 打开一个用于更新的文件，可读取也可写入。该文件必须存在 ”w+“ 创建一个用于读写的空文件 “a+” 打开一个用于读取和追加的文件 函数返回一个FILE指针，否则返回NULL 1.3.2 fread声明： 12345size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)//ptr：指向带有最小尺寸 size*nmemb 字节的内存块的指针//size：读取的每个元素的大小，以字节为单位//nmemb：元素的个数//stream：指向FILE对象的指针，指定了一个输入流 成功读取的元素会以size_t对象返回 1.3.3 fwrite12345size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)//ptr：指向被写入元素数组的指针//size：读取的每个元素的大小，以字节为单位//nmemb：元素的个数//stream：指向FILE对象的指针，指定了一个输出流 1.3.4 fseek1234int fseek(FILE *stream, long int offset, int whence)//stream：指向FILE对象的指针//offset：相对whence的偏移量，以字节为单位//whence：表示开始添加偏移的位置 whence一般为下面三个常量 常量 描述 SEEK_SET 文件开头 SEEK_CUR 文件指针的当前位置 SEEK_END 文件的末尾 返回从whence位置开始查找的字节数 1.3.5 ftell1long int ftell(FILE *stream) 返回位置标识符的当前值 2 使用C标准库读取TS文件并写入txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; FILE *fileInput, *fileOutput; unsigned char buffer[188]; // TS流的标准包大小为188字节 size_t bytesRead; // 打开TS文件 fileInput = fopen(&quot;/home/sawen/my_test_pcie/test.ts&quot;, &quot;rb&quot;); if (!fileInput) &#123; perror(&quot;Failed to open input file&quot;); return EXIT_FAILURE; &#125; else &#123; printf(&quot;Input file opened successfully.\\n&quot;); &#125; // 检查文件大小 fseek(fileInput, 0, SEEK_END); long fileSize = ftell(fileInput); rewind(fileInput); if (fileSize == 0) &#123; printf(&quot;Input file is empty.\\n&quot;); fclose(fileInput); return EXIT_FAILURE; &#125; else &#123; printf(&quot;Input file size: %ld bytes.\\n&quot;, fileSize); &#125; // 打开TXT文件 fileOutput = fopen(&quot;output.txt&quot;, &quot;w&quot;); if (!fileOutput) &#123; perror(&quot;Failed to open output file&quot;); fclose(fileInput); return EXIT_FAILURE; &#125; else &#123; printf(&quot;Output file opened successfully.\\n&quot;); &#125; // 读取数据并写入到TXT文件 int packetCount = 0; while ((bytesRead = fread(buffer, 1, sizeof(buffer), fileInput)) &gt; 0) &#123; for (size_t i = 0; i &lt; bytesRead; ++i) &#123; fprintf(fileOutput, &quot;%02x &quot;, buffer[i]); // 将字节以十六进制格式写入 &#125; fprintf(fileOutput, &quot;\\n&quot;); // 每个TS包后换行 packetCount++; &#125; // 检查是否有数据被读取 if (packetCount == 0) &#123; printf(&quot;No data read from file.\\n&quot;); &#125; else &#123; printf(&quot;Processed %d TS packets.\\n&quot;, packetCount); &#125; // 关闭文件 fclose(fileInput); fclose(fileOutput); printf(&quot;Data transfer complete.\\n&quot;); return EXIT_SUCCESS;&#125; 运行结果如下 可以看到以188个字节为一行写入txt","categories":[{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"}],"tags":[{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"}]},{"title":"MATLAB中使用HDL Coder生成HDL代码时的报错集合","slug":"MATLAB中使用HDL Coder生成HDL代码时的报错集合","date":"2024-06-12T16:00:00.000Z","updated":"2025-07-14T12:08:48.980Z","comments":true,"path":"2024/06/13/MATLAB中使用HDL Coder生成HDL代码时的报错集合/","permalink":"https://www.moerjielovecookie.icu/2024/06/13/MATLAB%E4%B8%AD%E4%BD%BF%E7%94%A8HDL%20Coder%E7%94%9F%E6%88%90HDL%E4%BB%A3%E7%A0%81%E6%97%B6%E7%9A%84%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/","excerpt":"","text":"1 Delay balancing unsuccessful because an extra 4 cycles of latency introduced by optimizations in the feedback loop cannot be offset using design delays for the loop latency budget.1.1 产生原因 由于时序考虑，在每个模块的输出端添加了1到2级的输入输出流水线，但是在这种带反馈的结构上添加输入输出流水线后，会产生如下的报错 可以看出加入的输入输出流水线会导致额外的时钟延时，使得延时平衡失败。 1.2 解决方法在保证时序的前提下将带有反馈回路的模块输入输出流水线设置为0，也可以在同级输出端口加入delay手动添加流水线。","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"Modelsim中使用tcl命令导出仿真数据到txt文件","slug":"Modelsim中使用tcl命令导出仿真数据到txt文件","date":"2024-06-08T16:00:00.000Z","updated":"2025-07-14T12:08:13.521Z","comments":true,"path":"2024/06/09/Modelsim中使用tcl命令导出仿真数据到txt文件/","permalink":"https://www.moerjielovecookie.icu/2024/06/09/Modelsim%E4%B8%AD%E4%BD%BF%E7%94%A8tcl%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BA%E4%BB%BF%E7%9C%9F%E6%95%B0%E6%8D%AE%E5%88%B0txt%E6%96%87%E4%BB%B6/","excerpt":"","text":"参考下面的CSDN博客 bookmark 1 Tcl命令12345678910proc write_sim_data &#123;env name radix cycle file&#125; &#123; set fid [open $file w] for &#123;set i 0&#125; &#123;$i &lt;= $::now&#125; &#123;incr i [expr $cycle * 1000]&#125; &#123; set str [exa -env $env -radix $radix -time $&#123;i&#125;ps &#123;*&#125;$name] puts $fid $str &#125; close $fid &#125; Line1：定义一个名为write_sim_data的过程，参数列表为：{env name radix cycle file} env：指定查找对象名称的路径。如top_tb&#x2F;top_u name：需要导出的变量列表。如{I_reset_n R_data_cnt} radix：进制。可选：ascii,binary, decimal,hexadecimal,unsigned等 cycle：时钟周期，单位ns file：输出文件。如.&#x2F;1.txt Line2：打开一个文档，返回文件描述符 Line3：分别获得从0到仿真结尾时间，按时钟周期间隔对数据进行取样输出 Line4：获得具体数据 Line5：将数据写入文件 Line7：关闭文件 示例： 1write_sim_data sim:/top_tb/u_top_wrapper/top_i/RS_Enc_0 &#123;RS_Out Trigger&#125; unsigned 1000 data.txt","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"Xilinx FPGA中的BUFFER","slug":"Xilinx FPGA中的BUFFER","date":"2024-05-28T16:00:00.000Z","updated":"2025-07-14T12:13:02.309Z","comments":true,"path":"2024/05/29/Xilinx FPGA中的BUFFER/","permalink":"https://www.moerjielovecookie.icu/2024/05/29/Xilinx%20FPGA%E4%B8%AD%E7%9A%84BUFFER/","excerpt":"","text":"FPGA大型设计中推荐使用同步时序电路，同步时序电路基于时钟触发沿设计，对时钟的周期、占空比、延时和抖动有更高的要求。为满足时序的要求，一般采用全局时钟资源驱动设计的主时钟，FPGA的主时钟一般使用全铜层工艺实现，并设计了专用时钟缓冲与驱动结构。 1 缓冲和驱动1.1 缓冲输入输出缓冲，主要用于片外输入时钟或者片外差分输入的信号。 差分信号和差分时钟进入片内后如果不经过IBUFGDS、IBUFDS缓冲就无法直接处理 1.2 驱动当信号扇出过大时可以通过加BUFG增加信号稳定性 过一次BUFG有10ns左右的延时，但是通过BUFG后输出到片上所有单元的延时都可以忽略不记 2 Buffer的类别和作用2.1 BUFG BUFG是一个高扇出缓冲器，将信号连接到全局布线资源上，使得信号的延时和抖动最小 通常用于时钟网络以及其他高扇出网络，比如复位和使能信号 2.2 BUFGCE BUFGCE具有单门控输入的全局时钟缓冲器，CE高电平有效 当CE为低电平时 O 端口输出0 2.3 BUFH BUFH原语允许直接访问BUFG的时钟区域入口，允许访问全局时钟网络中未使用的部分，作为高速低偏移的本地路由资源（单时钟区域） 2.4 IBUFDS 支持低压差分信号输入的缓冲器，有两个输入的端口，一个为主端口一个为从端口，输入的信号相位相反 2.5 IBUFDS_GTE27系列器件中的Gbit 收发器输入缓冲，REFCLK应连接到串行收发器的专用参考时钟输入引脚 2.6 OBUFDS差分信号输出缓冲器","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"NCO模块的各项参数","slug":"NCO模块的各项参数","date":"2024-05-18T16:00:00.000Z","updated":"2025-07-14T12:15:24.308Z","comments":true,"path":"2024/05/19/NCO模块的各项参数/","permalink":"https://www.moerjielovecookie.icu/2024/05/19/NCO%E6%A8%A1%E5%9D%97%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0/","excerpt":"","text":"NCO模块可以生成实数或者复数正弦信号，同时提供硬件友好的控制信号 1 Accumulator累加器位数正弦波的频率分辨率取决于累加器的位数的大小，根据频率分辨率可以计算出累加器的位数，根据此位数设置累加器的数据类型字长 计算公式为 $$N&#x3D;ceil(log_2(\\frac{F_s}{\\Delta f}))$$ 2 量化位数量化累加器的输出可以在不增加查找表的大小的情况下提高频率分辨率 要根据无杂散动态范围来计算量化位数，计算公式为 $$Q&#x3D;ceil(\\frac{SFDR-12}{6})$$ 3 相位增量$$phInc&#x3D;round(\\frac{f\\times 2^N}{F_s})$$","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"运放的同相与反相放大","slug":"运放的同相与反相放大","date":"2024-05-04T16:00:00.000Z","updated":"2025-07-14T12:10:47.503Z","comments":true,"path":"2024/05/05/运放的同相与反相放大/","permalink":"https://www.moerjielovecookie.icu/2024/05/05/%E8%BF%90%E6%94%BE%E7%9A%84%E5%90%8C%E7%9B%B8%E4%B8%8E%E5%8F%8D%E7%9B%B8%E6%94%BE%E5%A4%A7/","excerpt":"","text":"1 反相放大器同相端接地，电压为 0，反相端和同相端虚短，因此也是 0 V 的电压，同时由于虚断，几乎没有电流注入，所以R 1 和R 2 相当于串联，电阻上的电流相等 因此可以求出输入输出关系式为 $$V_{out}&#x3D;-\\frac{R_2}{R_1}\\times V_i$$ 2 同相放大器同样根据虚断和虚短可以求得输入输出关系式为 $$V_{out}&#x3D;\\frac{R_1+R_2}{R_2}\\times V_i $$ 3 同相放大器和反相放大器的优缺点3.1 反相放大器 优点：两个输入端电位始终近似为 0，只有差模信号，抗干扰能力强 缺点：输入阻抗小，等于信号到输入端的串联电阻阻值 3.2 同相放大器 优点：输入阻抗接近无穷大 缺点：放大电路没有虚地，有较大共模电压，抗干扰能力差，使用时要求运放有较高的共模抑制比 如果要求输入阻抗不高且相位无要求时，首选反相放大，因为反相放大只存在差模信号，抗干扰能力强，可以得到更大的输入信号范围 在设计中要求放大倍数相同的情况下尽量选择数值小的电阻配合，这样可以减小输入偏置电流的影响和分布电容的影响","categories":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"Vivado报错集合","slug":"Vivado报错集合","date":"2024-04-30T16:00:00.000Z","updated":"2025-07-14T12:06:54.608Z","comments":true,"path":"2024/05/01/Vivado报错集合/","permalink":"https://www.moerjielovecookie.icu/2024/05/01/Vivado%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/","excerpt":"","text":"1 ERROR: [Common 17-49] Internal Data Exception:这个错误通常表示在使用 vvdo 进行逻辑分析时出现了问题。错误信息表明，存在一个断言失败，即在获取探针数据时，数据不匹配。 2 Synth 8-5535报错代码 12345[Synth 8-5535] port &lt;clk_0&gt; has illegal connections. It is illegal to have a port connected to an input buffer and other components. The following are the port connections :Input Buffer: Port I of instance clkin1_ibufg(IBUF) in module &lt;top_clk_wiz_0_1_clk_wiz&gt;Other Components: 2.1 原因普通IO输入的时钟信号必须要经过buffer才能驱动PLL 2.2 解决方法将clocking wizard中的输入信号配置为 No Buffer 3 Warning：filegmt 56-199 3.1 解决方法在Sources栏右键选择refresh hierarchy即可 4 Warning：CRITICAL WARNING: [filemgmt 56-176] Module references are not supported in manual compile order mode and will be ignored.4.1 解决方法 将刷新层次结构的模式设置为自动更新和编译即可 5 [BD 41-237] Bus Interface property FREQ_HZ does not match between &#x2F;M_AXIS_DATA_0(100000000) and &#x2F;dds_compiler_0&#x2F;M_AXIS_DATA(200000000) 引发这个报错的原因是IP核的时钟频率为200M，但是AXI4s的端口的频率为100M，因此将端口的频率设置为和IP核匹配的频率即可 6 vivado的各种设置无法保存6.1 原因“C:\\Users\\31651\\AppData\\Roaming\\Xilinx\\Vivado\\2023.2\\vivado.xml”这个文件里面存放了vivado的设置，例如最近打开的文件等 如果这些路径中有中文字符或其他vivado无法识别的字符，那么每次启动时vivado无法正常读取这些配置，就会重置这个文件，表现为重启vivado后所有配置全部丢失 6.2 解决方法将含有中文字符的文件路径删除或者改成英语命名 7 [Common 17-180] Spawn failed: No error 7.1 导致原因在 Vivado 中，报错信息 “[Common 17-180] Spawn failed: No error” 表示 Vivado 无法成功启动或创建某个进程，尽管没有明确的错误信息。这个错误通常发生在 Vivado 尝试启动外部进程或执行某些操作时，比如编译、生成比特流或启动仿真工具等。 7.2 TIMING #1 Critical Warning A primary clock top_i&#x2F;clk_wiz_0&#x2F;inst&#x2F;clk_in 1 is created on an inappropriate pin top_i&#x2F;clk_wiz_0&#x2F;inst&#x2F;clk_in 1. It is recommended to create a primary clock only on a proper clock source (input port or primitive output pin with no timing arc)PS 输出 120 MHz 时钟的时候，真实输出的频率为 $125MHz$，因此在 PS 的时钟输出后级联了 clk_wiz 来转化时钟频率。综合后报错。 7.2.1 解决方法由于 clk-wiz 输入端加入了 buffer，所以警告，只需要把输入设置为 no buffer 即可。 7.3 Debug 时不能将 axis 总线的某个信号接入到 ila，否则会导致下一个模块的这个信号无法联通","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"Matlab生成txt文件导入到Vivado仿真","slug":"Matlab生成txt文件导入到Vivado仿真","date":"2024-04-24T16:00:00.000Z","updated":"2025-07-14T12:07:22.511Z","comments":true,"path":"2024/04/25/Matlab生成txt文件导入到Vivado仿真/","permalink":"https://www.moerjielovecookie.icu/2024/04/25/Matlab%E7%94%9F%E6%88%90txt%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E5%88%B0Vivado%E4%BB%BF%E7%9C%9F/","excerpt":"","text":"1 Matlab处理数据并将其写入txt文件1234567%% Txt Generatepre_RS_data=dec2bin(simDataIn,8); %将数据转化为8bit的二进制fid=fopen(&quot;F:\\FPGA\\Xilinx_vivado\\project\\dvbstestbench\\dbvs\\matlab\\pre_RS_data.txt&quot;,&quot;wt&quot;);for i=1:n*nMessages %数据长度 fprintf(fid,&quot;%s\\n&quot;,pre_RS_data(i,1:8)); %由于二进制数据为8位，因此是1:8endfclose(fid); 使用fopen函数获取文件id，fopen的语法如下 其中permisson为文件访问类型，有以下几种权限 &#39;r&#39; 打开要读取的文件。 &#39;w&#39; 打开或创建要写入的新文件。放弃现有内容（如果有）。 &#39;a&#39; 打开或创建要写入的新文件。追加数据到文件末尾。 &#39;r+&#39; 打开要读写的文件。 &#39;w+&#39; 打开或创建要读写的新文件。放弃现有内容（如果有）。 &#39;a+&#39; 打开或创建要读写的新文件。追加数据到文件末尾。 &#39;A&#39; 打开文件以追加（但不自动刷新）当前输出缓冲区。 &#39;W&#39; 打开文件以写入（但不自动刷新）当前输出缓冲区。 💡 要以文本模式打开的话，要附加’t’ 2 Vivado中testbench写法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354`timescale 1ns/1psmodule top_tb();reg clk;reg rst_n;reg [7:0]SEQ_IN_0;reg [7:0] data_mem[1:1020];reg [31:0] i;wire BIN_OUT;wire ce_out;wire locked;//clk &amp; rst_n geninitial begin clk=1&#x27;b0; rst_n=1&#x27;b0; #100 rst_n=1&#x27;b1; endalways #5 clk=~clk;//data readinitial begin $readmemb(&quot;F:/FPGA/Xilinx_vivado/project/dvbstestbench/dbvs/matlab/pre_RS_data.txt&quot;,data_mem); endinitial begin i=1; forever @(posedge clk) begin if(i&lt;1020) begin i=i+1; end else i=1; end $display(&quot;%s&quot;,data_mem[i]);endalways @(posedge clk) begin SEQ_IN_0&lt;=data_mem[i];endtop_wrapper top_wrapper_u0( .clk_0 (clk), .rst_n_0 (rst_n), .SEQ_IN_0(SEQ_IN_0), .BIN_OUT_0 (BIN_OUT), .ce_out_0 (ce_out), .locked_0 (locked));endmodule 💡 直接在文件夹内部复制的文件路径是\\，但是testbench中要将所有反斜杠改为&#x2F;，否则无法读取txt文件","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"DVB-S系统仿真学习","slug":"DVB-S系统仿真学习","date":"2024-03-26T16:00:00.000Z","updated":"2025-07-14T12:15:50.904Z","comments":true,"path":"2024/03/27/DVB-S系统仿真学习/","permalink":"https://www.moerjielovecookie.icu/2024/03/27/DVB-S%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"DVB-S系统用于卫星电视信号传输，发送端框图如下所示 1 扰码实际数字通信中，载荷数据的码元会出现长连0或长连1的情况，不利于接收端提取时钟信号，同时会使得数据流中含有大量的低频分量，使得QPSK调制器的相位长时间不变，使得信号易受干扰。因此要对载荷数据进行随机化扰码处理 DVB-S标准中规定扰码的生成多项式为 $$p(x)&#x3D;x^{15}+x^{14}+1$$ 同时移位寄存器的初始状态为”1001_0101_0000_000” 1.1 Matlab代码仿真12345678n=500;% origin_data=randi([0 1],n,1);origin_cnt_1=nnz(origin_data==1)scrambling = comm.Scrambler(&quot;CalculationBase&quot;,2,&quot;InitialConditions&quot;,[1 0 0 1 0 1 0 1 0 0 0 0 0 0 0], ... &quot;Polynomial&quot;,[1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1]);scrambling_data=step(scrambling,origin_data);scrambling_data_cnt_1=nnz(scrambling_data==1) 运行结果如下图所示 可以看出初始的500点长度的数据包中有403个“1”，经过扰码处理后“1”的个数接近数据总量的一半 2 外码纠错编码（RS编码）RS码定义： $GF(q)上（q \\neq 2, 通常q&#x3D;2^m），码长n&#x3D;q-1的本原BCH码$ 能纠正 t 个错误的RS码的参数为 - 分组长度n=q-1 - 校验符号数n-k=2t - 码的最小距离dmin=2t+1 DVB-S系统中使用的RS(188，204)是由RS(239,255)截断而来的，可以纠正8个字节的错误 2.1 Matlab仿真12345678910111213141516171819m=8; %bit per symboln=204;k=188;data_test=randi([0,n],1,k);data_gf=gf(data_test,m);data_rs_enc=rsenc(data_gf,n,k);data_enc=data_rs_enc.x;data_rs_dec=rsdec(data_rs_enc,n,k);data_dec=data_rs_dec.x;subplot(3,1,1);stem(data_test);subplot(3,1,2);stem(data_enc);subplot(3,1,3);stem(data_dec); 首先生成一个长度为188的序列，将其转换到伽罗华域后，使用rsenc函数进行RS编码，再进行译码，根据对比可以看出译码后的比特和译码前的完全一样 3 卷积交织在实际的传输过程中，由于脉冲干扰、多径效应等因素会带来持续一定时间的突发错误，虽然RS码对突发错误有较好的纠错能力，但是当其持续时间较长时，就会超出RS码的纠错能力，因此在编码过程中引入了卷积交织，将数据的传输顺序按照一定的规律分散开，就可以使得错误的码元也被分散开 DVB-S中交织深度为12，总共17个FIFO，数据按行写入寄存器，按列读出 交织后最大可纠错长度为12*8&#x3D;96 可以看出前一段时间读取到了很多0，说明下面的移位寄存器中的数据还没有移动到末端 4 卷积编码卷积码是一种有效的前向纠错码记作$(n,k,m)$，将k个信息比特编为n个比特，m为编码存储长度，N&#x3D;m+1为约束长度，即卷积码的当前码元不仅与当前输入的k的信息码元有关，还与前面m个时刻输入的信息码元有关 12345678910111213141516171819clc;close all;n=500;tre1=[1 1 1 1 0 0 1]; %oct 171tre2=[1 0 1 1 0 1 1]; %oct 133trellis = poly2trellis(7,[171 133]);convData=convenc(scrambling_data,trellis);decData=vitdec(convData,trellis,499,&quot;trunc&quot;,&quot;hard&quot;);subplot(3,1,1);stem(scrambling_data);subplot(3,1,2);stem(convData);subplot(3,1,3);stem(decData);biterr(scrambling_data,decData) 使用poly2trellis将卷积编码多项式转换为网格描述 比对后可以看到解码出的数据和原数据完全相同","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}]},{"title":"QPSK simulink实现","slug":"QPSK simulink实现","date":"2024-03-23T16:00:00.000Z","updated":"2025-07-14T12:14:10.174Z","comments":true,"path":"2024/03/24/QPSK simulink实现/","permalink":"https://www.moerjielovecookie.icu/2024/03/24/QPSK%20simulink%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"1 调制部分1.1 总体框架 1.2 各模块参数升余弦滚降滤波器滚降系数为 1 单双极性变换 1.3 各阶段波形1.4 Buffer 1.5 Demux 1.6 Raised Cosine TransmitFilter 1.7 QPSK 信号功率谱密度 2 解调部分经过 AWGN 信道后，假设已经进行了载波同步 2.1 部分模块参数2.2 载波模块 2.3 Pulse Generator 由于经过了串并转换，因此数据率减半 2.4 部分波形 将初始信号经过一定时间的延时后，在示波器中和解调输出的信号基本对齐，可以发现基本实现QPSK 调制解调","categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"}]},{"title":"8bit数据转1bit逐位输出电路仿真","slug":"8bit数据转1bit逐位输出电路仿真","date":"2024-03-22T16:00:00.000Z","updated":"2025-07-14T12:09:14.994Z","comments":true,"path":"2024/03/23/8bit数据转1bit逐位输出电路仿真/","permalink":"https://www.moerjielovecookie.icu/2024/03/23/8bit%E6%95%B0%E6%8D%AE%E8%BD%AC1bit%E9%80%90%E4%BD%8D%E8%BE%93%E5%87%BA%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9F/","excerpt":"","text":"在DVB-S系统中，TS流在经过RS编码后，会变成uint8类型的数据，在后续QPSK星座映射时又需要二进制码流，因此在进行了RS编码后要将8个bit的数据转化成1个bit逐位输出 1 实现思路首先使用BitwiseOperator模块按位与操作，分别将8位二进制数据提取出来，然后使用一个计数器产生0~7的计数信号作为mux模块的使能，在8个时钟周期内分别输出提取出来的8位数据 2 结构框图 3 仿真结果 输入的数据是133，二进制为10000101，可以看到输出的结果符合需求","categories":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]},{"title":"AXI-STREAM简介","slug":"AXI-STREAM简介","date":"2024-03-19T16:00:00.000Z","updated":"2025-04-27T12:28:31.000Z","comments":true,"path":"2024/03/20/AXI-STREAM简介/","permalink":"https://www.moerjielovecookie.icu/2024/03/20/AXI-STREAM%E7%AE%80%E4%BB%8B/","excerpt":"","text":"AXI-STREAM简介概念AXI-Stream总线是一种高效、简单的数据传输协议，主要用于高吞吐量的数据流传输场景。相比于传统的AXI总线，AXI-Stream总线更加简单和轻量级，它通过无需地址的方式，将数据从一个模块传输到另一个模块，适用于需要高速数据传输的应用场景。 部分术语 Transfer：基于TVALID和TREADY握手协议的传输 Packet：一组通过axi-stream传输的数据 Frame：最大的Byte组合，包含整数个Packet 接口信号 信号 描述 ACLK 全局时钟信号，上升沿有效 ARSTn 全局复位信号，低电平有效 TVALID 主机驱动有效数据 TREADY 从机可以接收数据 TDATA[(8n-1):0] 位宽为整数倍byte TLAST 表示数据包的边界 TID 由主机发出，Identity标识符，在存在多个stream数据传输时起作用，用于识别不同的数据流 当clk上升沿检测到TVALID和TREADY均为高电平时开始传输数据 由于AXI-STREAM不需要传输地址，仅进行简单的发送和接收，因此减小了传播时延","categories":[],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"}]}],"categories":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/categories/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"电子测量","slug":"电子测量","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E5%AD%90%E6%B5%8B%E9%87%8F/"},{"name":"杂类","slug":"杂类","permalink":"https://www.moerjielovecookie.icu/categories/%E6%9D%82%E7%B1%BB/"},{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/categories/%E7%94%B5%E8%B7%AF/"},{"name":"射频","slug":"射频","permalink":"https://www.moerjielovecookie.icu/categories/%E5%B0%84%E9%A2%91/"},{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/categories/FPGA/"},{"name":"MCU","slug":"MCU","permalink":"https://www.moerjielovecookie.icu/categories/MCU/"}],"tags":[{"name":"数字通信","slug":"数字通信","permalink":"https://www.moerjielovecookie.icu/tags/%E6%95%B0%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"name":"射频","slug":"射频","permalink":"https://www.moerjielovecookie.icu/tags/%E5%B0%84%E9%A2%91/"},{"name":"电路","slug":"电路","permalink":"https://www.moerjielovecookie.icu/tags/%E7%94%B5%E8%B7%AF/"},{"name":"coding","slug":"coding","permalink":"https://www.moerjielovecookie.icu/tags/coding/"},{"name":"硬件","slug":"硬件","permalink":"https://www.moerjielovecookie.icu/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.moerjielovecookie.icu/tags/MATLAB/"},{"name":"FPGA","slug":"FPGA","permalink":"https://www.moerjielovecookie.icu/tags/FPGA/"},{"name":"测量","slug":"测量","permalink":"https://www.moerjielovecookie.icu/tags/%E6%B5%8B%E9%87%8F/"},{"name":"MCU","slug":"MCU","permalink":"https://www.moerjielovecookie.icu/tags/MCU/"},{"name":"bug","slug":"bug","permalink":"https://www.moerjielovecookie.icu/tags/bug/"},{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://www.moerjielovecookie.icu/tags/ZYNQ/"},{"name":"Report","slug":"Report","permalink":"https://www.moerjielovecookie.icu/tags/Report/"}]}