<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/01/19/template/blog_template/"/>
    <url>/2025/01/19/template/blog_template/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多速率信号处理-CIC滤波器</title>
    <link href="/2025/01/19/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-CIC%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2025/01/19/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-CIC%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>级联积分梳状滤波器（Cascade Intergrator Comb）是多速率信号处理中一种十分高效的数字滤波器。CIC滤波器具有低通滤波器的特性，同时具有以下优势：</p><ul><li>滤波器系数全为1，设计时不需要存储滤波器系数，节省存储单元，同时使得滤波时只需要加法器和累加器，不需要乘法器</li><li>结构规则，可灵活设置插值因子而不影响整体结构</li></ul><h2 id="积分器"><a href="#积分器" class="headerlink" title="积分器"></a>积分器</h2><p>积分器结构为</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409052106726.png" srcset="/img/banner.png" lazyload alt="2024after4202409052106726.png"></p><p>时域上可表示为</p><p>$$<br>y_1(n)&#x3D;x(n)+y_1(n-1)<br>$$</p><p>频域上可表示为</p><p>$$<br>H_1(\mathrm{e}^{\mathrm{j}w})&#x3D;\frac{1}{1-\mathrm{e}^{-\mathrm{j}w}}<br>$$</p><p>可得积分器的幅度谱为</p><p>$$<br>\left|H_1(\mathrm{e}^{jw})\right|&#x3D;\left|\frac{1}{1-\mathrm{e}^{-jw}}\right|&#x3D;\left|\frac{1}{\mathrm{e}^{-jw&#x2F;2}(\mathrm{e}^{jw&#x2F;2}-\mathrm{e}^{-jw&#x2F;2})}\right|&#x3D;\left|\frac{1}{2\sin\left(\frac{w}{2}\right)}\right|<br>$$</p><p>从公式可以得出积分器只有极点$(\omega &#x3D; 2k \pi，k为整数)$而无零点，且对直流信号具有无限大的增益。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725542139077.png" srcset="/img/banner.png" lazyload alt="1725542139077.png"></p><h2 id="梳状滤波器"><a href="#梳状滤波器" class="headerlink" title="梳状滤波器"></a>梳状滤波器</h2><p>时域上可表示为</p><p>$$<br>y_C(n)&#x3D;x(n)-x(n-RM)<br>$$</p><p>其中</p><ul><li>R 是插值因子或抽取因子</li><li>M 是微分时延</li></ul><p>频域上可表示为</p><p>$$<br>H_\mathrm{C}(z)&#x3D;1-z^{-RM}<br>$$</p><p>幅度谱为</p><p>$$<br>\left|H_{\mathrm{C}}(\mathrm{e}^{\mathrm{j}w})\right|&#x3D;\left|1-\mathrm{e}^{-\mathrm{j}RMw}\right|&#x3D;\left|\mathrm{e}^{-\mathrm{j}RMw&#x2F;2}(\mathrm{e}^{\mathrm{j}RMw&#x2F;2}-\mathrm{e}^{-\mathrm{j}RMw&#x2F;2})\right|&#x3D;2\left|\sin\left(\frac{RM}{2}w\right)\right|<br>$$</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725542829180.png" srcset="/img/banner.png" lazyload alt="1725542829180.png"></p><p>可知梳状滤波器只有零点，没有极点</p><p>若R&#x3D;8、M&#x3D;1，则结构为</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725542752856.png" srcset="/img/banner.png" lazyload alt="1725542752856.png"></p><p>由此可知单级CIC滤波器的幅度谱为</p><p>$$<br>\left|H_{\mathrm{CIC}}(\mathrm{e}^{\mathrm{j}w})\right|&#x3D;\left|H_{1}(\mathrm{e}^{\mathrm{j}w})\right|\cdot\left|H_{\mathrm{C}}(\mathrm{e}^{\mathrm{j}w})\right|&#x3D;\left|\frac{\sin\left(\frac{RM}{2}w\right)}{\sin\left(\frac{w}{2}\right)}\right|<br>$$</p><p>当$\mathrm{RM\omega}&#x2F;2&#x3D;\mathrm{k}:\pi $时，即$w&#x3D;\frac{2k\pi}{RM}\quad(k&#x3D;\pm1,\pm2,\cdots,\pm(RM-1))$时可以确定零点</p><p>当$\omega &#x2F;2 &#x3D;k\pi，即\omega &#x3D; 2k\pi$时，可得此时的幅频响应为</p><p>$$<br>\left|H_{\mathrm{CIC}}(\mathrm{e}^{\mathrm{j}\omega})\right|_{\omega&#x3D;2k\pi}&#x3D;RM<br>$$</p><p>从而实现了零极点相消</p><p>单级CIC滤波器在$\omega &#x3D;0时 \left| H_{CIC}(e^{j\omega}) \right|&#x3D;RM$，所以主瓣区间为$\begin{bmatrix}0,\frac{2\pi}{RM}\end{bmatrix}$，其余都为旁瓣，第一旁瓣电平为</p><p>$$<br>A_1&#x3D;\left|H_{\mathrm{CIC}}(\mathrm{e}^{\mathrm{j}w})\right|_{w&#x3D;\frac{3\pi}{RM}}&#x3D;\left|\frac{\sin\left(\frac{RM}{2}\times\frac{3\pi}{RM}\right)}{\sin\left(\frac{1}{2}\times\frac{3\pi}{RM}\right)}\right|&#x3D;\left|\frac{1}{\sin\left(\frac{3\pi}{2RM}\right)}\right|<br>$$</p><p>因此旁瓣抑制为</p><p>$$<br>A&#x3D;\left|RM\sin\left(\frac{3\pi}{2RM}\right)\right|<br>$$</p><p>当$\mathrm{R}\rightarrow\infty $时，旁瓣抑制为</p><p>$$<br>A&#x3D;20lg(\lim_{R\to\infty}A)&#x3D;20lg(\frac{3\pi}{2})&#x3D;13.46dB<br>$$</p><p>单级CIC滤波器的阻带衰减为</p><p>$$<br>\alpha &#x3D;-20lgb<br>$$</p><p>带内容差（通带波纹）为</p><p>$$<br>\delta &#x3D; 20lg\left|\frac{b\pi}{\sin(b\pi)}\right|<br>$$</p><p>其中b为带宽比例因子</p><p>$$<br>b&#x3D;\frac{B}{f_s&#x2F;(RM)}<br>$$</p><p>单级CIC滤波器的旁瓣电平较高，可通过多级CIC级联改善。</p><p>$$<br>\left|H(\mathrm{e}^{\mathrm{j}w})\right|&#x3D;\left|\frac{\sin\left(\frac{RM}{2}w\right)}{\sin\left(\frac{w}{2}\right)}\right|^N<br>$$</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725886131150.png" srcset="/img/banner.png" lazyload alt="1725886131150.png"></p><p>对于N级CIC级联滤波器，旁瓣抑制、阻带衰减、带内容差可表示为</p><p>$$<br>\begin{cases}A_\mathrm{N}&#x3D;13.46N:\mathrm{dB}\\alpha_\mathrm{N}&#x3D;-20N\lg b\\delta_\mathrm{N}&#x3D;20N\lg\left|\frac{b\pi}{\sin(b\pi)}\right|\end{cases}<br>$$</p><p>增大CIC滤波器阶数的话，可以增加旁瓣抑制和阻带衰减，但是会导致带内容差变大。因此考虑到通带性能，通常选择$N\leq5$。在N不变的情况下，带宽比例因子b越小，CIC滤波器的通带和阻带特性也越好，因此CIC一般位于插值系统的最后一级（输入速率最高）</p><h1 id="位增长问题"><a href="#位增长问题" class="headerlink" title="位增长问题"></a>位增长问题</h1><p>由多级滤波器的幅频响应可知，当$\omega \rightarrow 0$时</p><p>$$<br>\lim\limits_{w\to0}\Bigl|H(\mathrm{e}^{\mathrm{j}w})\Bigr|&#x3D;\lim\limits_{w\to0}\Biggl|\frac{\frac{RM}{2}\cdot\cos(RMw&#x2F;2)}{\frac{1}{2}\cdot\cos(w&#x2F;2)}\Biggr|^N&#x3D;(RM)^N<br>$$</p><p>由此可知多级CIC滤波器可以引起的幅度增益的最大值为</p><p>$$<br>G_{max}&#x3D;(RM)^N<br>$$</p><p>假设输入的数据$x(n)$为有符号数，位宽为$B_{in}$，取值范围为$[-2^{B_{in}-1},2^{B_{in}-1}-1]$，则输出$y(n)$的最大值为</p><p>$$<br>y_{max}&#x3D;-2^{B_{\mathrm{m}}-1}\cdot\left(RM\right)^N<br>$$</p><p>因此输出的最大位宽为</p><p>$$<br>B_{\mathrm{out}}&#x3D;\text{ceil}[\log_2|y_{\mathrm{max}}|]+1&#x3D;N\cdot\text{ceil}[\log_2(RM)]+B_{\mathrm{in}}<br>$$</p><p>在FPGA设计时，要合理地设置输出信号的位宽，防止数据的溢出，为了节省资源，也可以在每一级适当的进行截位</p><h1 id="Matlab设计CIC补偿滤波器"><a href="#Matlab设计CIC补偿滤波器" class="headerlink" title="Matlab设计CIC补偿滤波器"></a>Matlab设计CIC补偿滤波器</h1><p>由于CIC滤波器通带内不平坦，因此需要在前级加入CIC补偿滤波器。Matlab中的对应函数为**fdesign.ciccomp，**语法如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">d = fdesign.ciccomp<br>d = fdesign.ciccomp(d,nsections,rcic)<br>d = fdesign.ciccomp(...,spec)<br>h = fdesign.ciccomp(...,spec,specvalue1,specvalue2,...)<br></code></pre></td></tr></table></figure><p>其中梳状滤波器的延时长度为d，滤波器阶数为nsections，CIC速率转化因子为rcic。</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">h = fdesign.ciccomp;<br>set(h,NumberOfSections=<span class="hljs-number">5</span>,DifferentialDelay=<span class="hljs-number">1</span>);<br>cicComp = design(h,<span class="hljs-string">&#x27;equiripple&#x27;</span>,SystemObject=<span class="hljs-built_in">true</span>);<br>filterAnalyzer(cicComp)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运放选型</title>
    <link href="/2025/01/19/%E8%BF%90%E6%94%BE%E9%80%89%E5%9E%8B/"/>
    <url>/2025/01/19/%E8%BF%90%E6%94%BE%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在使用OP07设计单路运放时，设计目标为将100K到1M的1V峰峰值的正弦波放大2倍，但是测试过程中发现100K频率下输出的波形类似三角波，数据手册说OP07的增益带宽积为0.5MHz，正常来说100K的频率下2倍增益是没问题的。</p><p>但是数据手册又说OP07的压摆率Slew Rate为0.3V&#x2F;us，那么根据设计目标可以计算得出运放的压摆率至少要到6.28V&#x2F;us，可以看到OP07的压摆率完全不够，因此波形会失真。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202407211436085.png" srcset="/img/banner.png" lazyload alt="2024after4202407211436085.png"></p><p>当使用正负5V供电时，AD8051的压摆率最小值在105V&#x2F;us，，因此可以满足设计要求。</p>]]></content>
    
    
    <categories>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阻塞赋值和非阻塞赋值</title>
    <link href="/2025/01/19/%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC/"/>
    <url>/2025/01/19/%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="阻塞和非阻塞的区别"><a href="#阻塞和非阻塞的区别" class="headerlink" title="阻塞和非阻塞的区别"></a>阻塞和非阻塞的区别</h1><h2 id="阻塞赋值“-”"><a href="#阻塞赋值“-”" class="headerlink" title="阻塞赋值“&#x3D;”"></a>阻塞赋值“&#x3D;”</h2><p>必须是阻塞赋值完成后，才进行下一条语句的执行；赋值一旦完成，等号左边的变量值立即变化。在同一个块中，阻塞赋值表达式的书写顺序会影响赋值的结果。硬件没有对应的电路。</p><blockquote><p>即串行赋值，语句从上到下顺序执行，立即生效<br>1111</p></blockquote><h2 id="非阻塞赋值“"><a href="#非阻塞赋值“" class="headerlink" title="非阻塞赋值“&lt;&#x3D;”"></a>非阻塞赋值“&lt;&#x3D;”</h2><p>在赋值开始时计算表达式右边的值，在本次仿真周期时钟的下降沿时才更新被赋值变量，即赋值不是立即生效的；非阻塞赋值允许块中其他语句同时执行。在同一个块中，非阻塞赋值表达式的书写顺序不影响赋值的结果。硬件有对应的电路。</p><blockquote><p>并行执行，不是立即生效，语句同时执行</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>阻塞赋值对应的硬件电路与时钟触发沿没有关系，只和输入的电平变化有关；阻塞赋值对应触发器，只有触发沿才会发生赋值。</p><ol><li>时序电路建模时，用非阻塞赋值</li><li>锁存器建模时，用非阻塞赋值</li><li>在 always 块中建立组合逻辑时，用阻塞赋值</li><li>在同一个 always 块中建立时序和组合逻辑时，用非阻塞</li><li>在同一个 always 块中不能既用阻塞又用非阻塞</li><li>不要在一个以上的always块中为同一个变量赋值</li><li>赋值时不能延时</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Testbench仿真脚本编写指北</title>
    <link href="/2025/01/19/Testbench%E4%BB%BF%E7%9C%9F%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%8C%87%E5%8C%97/"/>
    <url>/2025/01/19/Testbench%E4%BB%BF%E7%9C%9F%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!note]<br>由于 Quartus 的 VWF 仿真只能仿真很短的时间，而且 Vivado 仿真的时候也需要添加激励信号，因此需要编写 testbench 文件进行激励仿真。</p></blockquote><h1 id="Testbench-文件结构"><a href="#Testbench-文件结构" class="headerlink" title="Testbench 文件结构"></a>Testbench 文件结构</h1><p>编写 testbench 的目的是为了测试 module 的功能、性能是否符合设计的预期。验证设计的功能包括以下步骤：</p><ol><li>产生合适的激励波形：该激励通常要覆盖被测 HDL 模块所有可能产生的输入状态；</li><li>将产生的激励信号加入到 DUT 中并观察其响应：即将 DUT 模块例化的 Testbench 中，运行仿真测试；</li><li>将输出的响应与期望值比较。<br>Testbench 的结构一般模块如下：<br>&#96;&#96;</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">module</span> Test_bench_name();<br><span class="hljs-comment">// 01:信号或变量声明定义</span><br><span class="hljs-comment">// --逻辑设计中输入对应 reg 型</span><br><span class="hljs-comment">// --逻辑设计中输出对应 wire 型</span><br><span class="hljs-comment">// 02:使用 ini[ti](https://bbs.elecfans.com/group_715)al 或 always 语句产生激励</span><br><span class="hljs-comment">// 03:例化待测试DUT模块</span><br><span class="hljs-comment">// 04:监控和比较输出响应</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="时钟激励输入示例"><a href="#时钟激励输入示例" class="headerlink" title="时钟激励输入示例"></a>时钟激励输入示例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">/*----------------------------------------------------------------</span><br><span class="hljs-comment">时钟激励产生方法一：50%占空比时钟</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-keyword">parameter</span> ClockPeriod=<span class="hljs-number">10</span>; <span class="hljs-comment">//参数化时钟周期</span><br><span class="hljs-keyword">initial</span><br>  <span class="hljs-keyword">begin</span><br>    clk_i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">forever</span><span class="hljs-variable">#(ClockPeriod/2)</span> clk_i = ~clk_i;<br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-comment">/*----------------------------------------------------------------</span><br><span class="hljs-comment">时钟激励产生方法二：50%占空比时钟</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-keyword">initial</span><br><span class="hljs-keyword">begin</span><br>  clk_i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">always</span> <span class="hljs-variable">#(ClockPeriod/2)</span> clk_i=~clk_i;<br><br><br><span class="hljs-comment">/*----------------------------------------------------------------</span><br><span class="hljs-comment">时钟激励产生方法三：产生固定数量的时钟脉冲</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-keyword">parameter</span> ClockPeriod=<span class="hljs-number">10</span>; <span class="hljs-comment">//参数化时钟周期</span><br><span class="hljs-keyword">initial</span><br><span class="hljs-keyword">begin</span><br>  clk_i=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">6</span>)<br>  <span class="hljs-variable">#(ClockPeriod/2)</span> clk_i=~clk_i;<br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-comment">/*----------------------------------------------------------------</span><br><span class="hljs-comment">时钟激励产生方法四：产生非占空比为 50%的时钟</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-keyword">parameter</span> ClockPeriod=<span class="hljs-number">10</span>; <span class="hljs-comment">//参数化时钟周期</span><br><span class="hljs-keyword">initial</span><br><span class="hljs-keyword">begin</span><br>clk_i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">forever</span><br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-variable">#((ClockPeriod/2)-2)</span> clk_i=<span class="hljs-number">0</span>;<br>    <span class="hljs-variable">#((ClockPeriod/2)+2)</span> clk_i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h2 id="复位激励输入示例"><a href="#复位激励输入示例" class="headerlink" title="复位激励输入示例"></a>复位激励输入示例</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">/*---------------------------------------------------------------- </span><br><span class="hljs-comment">复位信号产生方法一：异步复位</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-keyword">initial</span><br><span class="hljs-keyword">begin</span><br>  [rs](https:<span class="hljs-comment">//www.elecfans.com/tags/rs/)t_n_i=1;</span><br>  #<span class="hljs-number">100</span>; rst_n_i=<span class="hljs-number">0</span>;<br>  #<span class="hljs-number">100</span>; rst_n_i=<span class="hljs-number">1</span>; <br><span class="hljs-keyword">end</span><br><span class="hljs-comment">/*---------------------------------------------------------------- </span><br><span class="hljs-comment">复位信号产生方法二：同步复位</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-keyword">initial</span><br><span class="hljs-keyword">begin</span><br>  rst_n_i=<span class="hljs-number">1</span>; clk_i = <span class="hljs-number">0</span>;<br>  @（<span class="hljs-keyword">negedge</span> clk_i)<br>  rst_n_i=<span class="hljs-number">0</span>;<br>  #<span class="hljs-number">100</span>; <span class="hljs-comment">//固定时间复位</span><br>  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">10</span>) @（<span class="hljs-keyword">negedge</span> clk_i); <span class="hljs-comment">//固定周期数复位</span><br>  @（<span class="hljs-keyword">negedge</span> clk_i)<br>  rst_n_i=<span class="hljs-number">1</span>; <br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk_i=~clk_i;<br><br><br><span class="hljs-comment">/*---------------------------------------------------------------- </span><br><span class="hljs-comment">复位信号产生方法三：复位任务封装</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-keyword">task</span> reset;<br><span class="hljs-keyword">input</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] reset_time; <span class="hljs-comment">//复位时间可调，输入复位时间</span><br>  RST_ING=<span class="hljs-number">0</span>; <span class="hljs-comment">//复位方式可调，低电平或高电平</span><br>  <span class="hljs-keyword">begin</span><br>    rst_n=RST_ING; <span class="hljs-comment">//复位中</span><br>    #reset_time; <span class="hljs-comment">//复位时间</span><br>    rst_n_i=~RST_ING; <span class="hljs-comment">//撤销复位，复位结束</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endtask</span><br></code></pre></td></tr></table></figure><h2 id="仿真控制语句和系统任务描述"><a href="#仿真控制语句和系统任务描述" class="headerlink" title="仿真控制语句和系统任务描述"></a>仿真控制语句和系统任务描述</h2><p>&#96;&#96;</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">/*---------------------------------------------------------------- </span><br><span class="hljs-comment">仿真控制语句及系统任务描述</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-built_in">$stop</span>  <span class="hljs-comment">// 停止运行仿真，modelsim 中可继续仿真</span><br><span class="hljs-built_in">$stop</span>(n) <span class="hljs-comment">//带参数系统任务，根据参数 0,1或2不同，输出仿真信息</span><br><span class="hljs-built_in">$finish</span> <span class="hljs-comment">//结束运行仿真，不可继续仿真</span><br><span class="hljs-built_in">$finish</span>(n) <span class="hljs-comment">//带参数系统任务，根据参数 0,1或2不同，输出仿真信息</span><br><span class="hljs-comment">//0:不输出任何信息</span><br><span class="hljs-comment">//1:输出当前仿真时刻和位置</span><br><span class="hljs-comment">//2:输出当前仿真时刻、位置和仿真过程中用到的 memory 以及 CPU 时间的统计</span><br><span class="hljs-built_in">$random</span> <span class="hljs-comment">//产生随机数</span><br><span class="hljs-built_in">$random</span> % n <span class="hljs-comment">//产生范围-n 到 n 之间的随机数</span><br>&#123;<span class="hljs-built_in">$random</span>&#125; % n <span class="hljs-comment">//产生范围 0 到 n 之间的随机数</span><br><span class="hljs-comment">/*----------------------------------------------------------------</span><br></code></pre></td></tr></table></figure><h2 id="文本读取"><a href="#文本读取" class="headerlink" title="文本读取"></a>文本读取</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-comment">/*---------------------------------------------------------------- </span><br><span class="hljs-comment">文本输入方式：$readmemb/$readmemh</span><br><span class="hljs-comment">----------------------------------------------------------------*/</span><br><span class="hljs-built_in">$readmemb</span>/<span class="hljs-built_in">$readmemh</span>(<span class="hljs-string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;存储器名&gt;);<br><span class="hljs-built_in">$readmemb</span>/<span class="hljs-built_in">$readmemh</span>(<span class="hljs-string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;存储器名&gt;,&lt;起始地址&gt;);<br><span class="hljs-built_in">$readmemb</span>/<span class="hljs-built_in">$readmemh</span>(<span class="hljs-string">&quot;&lt;数据文件名&gt;&quot;</span>,&lt;存储器名&gt;,&lt;起始地址&gt;,&lt;结束地址&gt;);<br><span class="hljs-built_in">$readmemb</span>:<span class="hljs-comment">/*读取二进制数据，读取文件内容只能包含：空白位置，注释行，二进制数</span><br><span class="hljs-comment">数据中不能包含位宽说明和格式说明，每个数字必须是二进制数字。*/</span><br><span class="hljs-built_in">$readmemh</span>:<span class="hljs-comment">/*读取十六进制数据，读取文件内容只能包含：空白位置，注释行，十六进制数</span><br><span class="hljs-comment">数据中不能包含位宽说明和格式说明，每个数字必须是十六进制数字。*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑金Alinx xc7z020 原理图</title>
    <link href="/2025/01/19/%E9%BB%91%E9%87%91Alinx%20xc7z020%20%E5%8E%9F%E7%90%86%E5%9B%BE/"/>
    <url>/2025/01/19/%E9%BB%91%E9%87%91Alinx%20xc7z020%20%E5%8E%9F%E7%90%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="时钟引脚"><a href="#时钟引脚" class="headerlink" title="时钟引脚"></a>时钟引脚</h1><h2 id="CLK：U18"><a href="#CLK：U18" class="headerlink" title="CLK：U18"></a>CLK：U18</h2><h1 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h1><h2 id="RST：N15"><a href="#RST：N15" class="headerlink" title="RST：N15"></a>RST：N15</h2><h1 id="扩展接口"><a href="#扩展接口" class="headerlink" title="扩展接口"></a>扩展接口</h1><h2 id="J10"><a href="#J10" class="headerlink" title="J10"></a>J10</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1715858667344.png" srcset="/img/banner.png" lazyload alt="1715858667344.png|400"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1715858711730.png" srcset="/img/banner.png" lazyload alt="1715858711730.png|400"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1715858778817.png" srcset="/img/banner.png" lazyload alt="1715858778817.png|400"></p><h2 id="J11"><a href="#J11" class="headerlink" title="J11"></a>J11</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1715858828182.png" srcset="/img/banner.png" lazyload alt="1715858828182.png|400"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1715858880857.png" srcset="/img/banner.png" lazyload alt="1715858880857.png|400"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1715859009851.png" srcset="/img/banner.png" lazyload alt="1715859009851.png|400"></p><h1 id="PL-LED"><a href="#PL-LED" class="headerlink" title="PL LED"></a>PL LED</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1715859045637.png" srcset="/img/banner.png" lazyload alt="1715859045637.png|400"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1736475075441.png" srcset="/img/banner.png" lazyload alt="1736475075441.png|400"></p><h1 id="PL-KEY"><a href="#PL-KEY" class="headerlink" title="PL KEY"></a>PL KEY</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1736475179705.png" srcset="/img/banner.png" lazyload alt="1736475179705.png|400"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1736475192537.png" srcset="/img/banner.png" lazyload alt="1736475192537.png|400"></p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vitis开发过程中遇到的错误</title>
    <link href="/2025/01/15/Vitis%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <url>/2025/01/15/Vitis%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Error-while-launching-program-Memory-write-error-at-0-x-105000-MMU-section-translation-fault"><a href="#Error-while-launching-program-Memory-write-error-at-0-x-105000-MMU-section-translation-fault" class="headerlink" title="Error while launching program: Memory write error at 0 x 105000. MMU section translation fault"></a>Error while launching program: Memory write error at 0 x 105000. MMU section translation fault</h1><p>没找到具体原因。<br>先生成 boot. Bin 文件烧录到内存卡后再启动 zynq 就不会出现这个报错。</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZYNQ中的GPIO</title>
    <link href="/2025/01/10/ZYNQ%E4%B8%AD%E7%9A%84GPIO/"/>
    <url>/2025/01/10/ZYNQ%E4%B8%AD%E7%9A%84GPIO/</url>
    
    <content type="html"><![CDATA[<h1 id="GPIO-原理"><a href="#GPIO-原理" class="headerlink" title="GPIO 原理"></a>GPIO 原理</h1><p>GPIO 通过 MIO 提供 54 路接口，其中 16 路位于 bank 500，剩余位于 bank 501。还通过 EMIO 接口提供从 PL 来的 64 路输入和 128 路输出。GPIO 控制和状态寄存器内存映射在基址 $0xE000_A000$。<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1736500884874.png" srcset="/img/banner.png" lazyload alt="500"></p><h2 id="GPIO-内部结构"><a href="#GPIO-内部结构" class="headerlink" title="GPIO 内部结构"></a>GPIO 内部结构</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202501101733911.png" srcset="/img/banner.png" lazyload alt="|400"></p><h3 id="器件引脚的-GPIO-控制"><a href="#器件引脚的-GPIO-控制" class="headerlink" title="器件引脚的 GPIO 控制"></a>器件引脚的 GPIO 控制</h3><ol><li>DATA_RO：总是读取 GPIO 引脚的状态，不考虑 GPIO 是输入还是输出，忽略对该寄存器的写操作。<blockquote><p>[!note]+<br>如果没有将 MIO 配置为 GPIO，则 DATA_RO 的内容不可读。</p></blockquote></li><li>DATA：当把 GPIO 配置为输出时，该寄存器用于控制给输出的值，一次性对这 32 位寄存器进行写操作。当读取该寄存器时，返回上次写到 DATA 或 MASK_DATA_[LSW, MSW]的值，不返回当前引脚的值。</li><li>DIRM：方向模式，控制 I&#x2F;O 引脚是输入还是输出，$DIRM&#x3D;&#x3D;0$ 时禁止输出驱动器。</li><li>OEN：输出使能，当 I&#x2F;O 配置为输出时，控制使能&#x2F;禁止输出。当 $OEN&#x3D;&#x3D;0$ 时禁用输出驱动器，禁止时引脚为三态。</li></ol>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>ZYNQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FIR滤波器的架构</title>
    <link href="/2024/12/29/FIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/12/29/FIR%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>有限脉冲响应滤波器，其突出特点为单位取样响应 $h(n)$ 是一个 N 点长的有限序列，滤波器的输出 $y(n)$ 表示为输入序列 $x(n)$ 和 $h(n)$ 的线性卷积<br>$$<br>y(n)&#x3D;\sum_{k&#x3D;0}^{N-1}x(k)h(n-k)&#x3D;x(n)*h(n)<br>$$<br>系统函数为<br>$$<br>H(z)&#x3D;\sum_{n&#x3D;0}^{N-1}h(n)z^{-n}&#x3D;h(0)+h(1)z^{-1}+\cdots+h(N-1)z^{-(N-1)}<br>$$<br>由此可见 FIR 只在原点上存在极点，具有全局稳定性<br>不同阶数的 FIR 滤波器特性</p><table><thead><tr><th>单位取样响应特征</th><th>滤波器种类</th></tr></thead><tbody><tr><td>系数偶对称，阶数为偶数</td><td>适合各种滤波器</td></tr><tr><td>系数偶对称，阶数为奇数</td><td>不适合高通和带阻滤波器</td></tr><tr><td>系数奇对称，阶数为偶数</td><td>只适合带通滤波器</td></tr><tr><td>系数奇对称，阶数为奇数</td><td>适合高通和带通滤波器</td></tr></tbody></table><h2 id="系数量化"><a href="#系数量化" class="headerlink" title="系数量化"></a>系数量化</h2><p>将一组数据先进行归一化处理，再乘上一个整数因子，最后进行四舍五入截尾处理即可</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">h = <span class="hljs-built_in">round</span>(h/<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(h))*(<span class="hljs-number">2</span>^N<span class="hljs-number">-1</span>)) //N为量化位数<br></code></pre></td></tr></table></figure><h1 id="Fully-Parallel-Systolic-Architecture（全并行脉动结构）"><a href="#Fully-Parallel-Systolic-Architecture（全并行脉动结构）" class="headerlink" title="Fully Parallel Systolic Architecture（全并行脉动结构）"></a>Fully Parallel Systolic Architecture（全并行脉动结构）</h1><p>全并行脉动滤波器对对称系数、反对称系数和零值系数进行了优化。滤波器的时延受到滤波器系数的对称性影响。<br>当对称系数绝对相等时，它们共享同一个 DSP block。这种配对共享允许在实现的过程中使用 Xilinx 和 Altera 的 dsp block 中的 pre-adder。<br>对称的滤波器如果不适用对称系数优化架构的话，结构如下图的上半部分，优化后为下半部分：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412292142810.png" srcset="/img/banner.png" lazyload alt="fir_arch_systolic_sym.png|500"></p><h1 id="Fully-Parallel-Transposed-Architecture（全并行转置结构）"><a href="#Fully-Parallel-Transposed-Architecture（全并行转置结构）" class="headerlink" title="Fully Parallel Transposed Architecture（全并行转置结构）"></a>Fully Parallel Transposed Architecture（全并行转置结构）</h1><p>Fully Parallel Transposed Architecture 通过为任意的绝对相等的系数共享乘法器，同时移除零值系数所需的乘法器。此结构的滤波器时延为固定的 6 个 clk。<br>下图的上半部分是没有优化的部分对称滤波器，下半部分为优化后的结构：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412292146523.png" srcset="/img/banner.png" lazyload alt="fir_arch_transposed_sym.png|500"></p><h1 id="Partly-Serial-Systolic-Architecture-1"><a href="#Partly-Serial-Systolic-Architecture-1" class="headerlink" title="Partly Serial Systolic Architecture (1 &lt; N &lt; L)"></a>Partly Serial Systolic Architecture (1 &lt; N &lt; L)</h1><p>其中 N 为延时长度，L 为滤波器阶数。<br>部分串行滤波器需要 <code>M=ceil(L/N)</code> 个脉动单元，结构如下：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412292149737.png" srcset="/img/banner.png" lazyload alt="fir_arch_systolic_partly_serial.png|500"><br>滤波器的时延为 <code>M+ceil(L/M)+5</code>。<br>如果一个乘法器对应的查找表里面的系数为 0 或者 2 的幂次，则实现过程不包含乘法器，通过移位来实现幂次的变化。</p><h1 id="Fully-Serial-Systolic-Architecture-N-≥-L"><a href="#Fully-Serial-Systolic-Architecture-N-≥-L" class="headerlink" title="Fully Serial Systolic Architecture (N ≥ L)"></a>Fully Serial Systolic Architecture (N ≥ L)</h1><p>如果延时的长度大于滤波器的阶数，此时滤波器为全串行结构。滤波器延时为 $L+5$。<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412292156578.png" srcset="/img/banner.png" lazyload alt="fir_arch_systolic_fully_serial.png|500"></p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quartus报错记录</title>
    <link href="/2024/12/28/Quartus%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/12/28/Quartus%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Error-176310-Can’t-place-multiple-pins-assigned-to-pin-location-Pin-F-16-IOPAD-X-34-Y-18-N-21"><a href="#Error-176310-Can’t-place-multiple-pins-assigned-to-pin-location-Pin-F-16-IOPAD-X-34-Y-18-N-21" class="headerlink" title="Error (176310): Can’t place multiple pins assigned to pin location Pin_F 16 (IOPAD_X 34_Y 18_N 21)"></a>Error (176310): Can’t place multiple pins assigned to pin location Pin_F 16 (IOPAD_X 34_Y 18_N 21)</h1><p>报错如下<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412282018135.png" srcset="/img/banner.png" lazyload><br>可以看到 Pin_F 16 既被用于 DAC_DATA，又被用于 nCEO 引脚，因此才会报错不能将多个引脚赋到 Pin_F 16 上。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412282020011.png" srcset="/img/banner.png" lazyload><br>将nCEO 的 value 设置为 Use as regual I&#x2F;O 即可解决问题。</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习</title>
    <link href="/2024/12/11/git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/12/11/git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-基础概念"><a href="#Git-基础概念" class="headerlink" title="Git 基础概念"></a>Git 基础概念</h1><h2 id="Git-概念汇总"><a href="#Git-概念汇总" class="headerlink" title="Git 概念汇总"></a>Git 概念汇总</h2><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td><strong>工作区</strong>（Workspace）</td><td>在本地的代码库，新增和修改的文件会提交到暂存区</td></tr><tr><td><strong>暂存区</strong>（stage）</td><td>用于临时存放文件的修改，实际上是一个文件（. Git&#x2F;index），保存待提交的文件列表</td></tr><tr><td><strong>仓库</strong>（repository）</td><td>Git 的管理仓库，记录文件状态的地方，所有的代码版本都在里面</td></tr><tr><td><strong>远程仓库</strong>（origin&#x2F;remote）</td><td>专用的 git 服务器，为多人提供共享服务。本地的仓库通过 &#x3D;&#x3D;push&#x3D;&#x3D;命令将代码推送到远程仓库里</td></tr><tr><td><strong>本地仓库</strong></td><td>本地电脑内直接使用的版本库</td></tr><tr><td><strong>分支</strong>（Branch）</td><td>分支是从主线分离出的副本，可以独立操作而不干扰主线，仓库初始化后会有一个默认主分支“master”或“main”</td></tr><tr><td><strong>头</strong>（HEAD）</td><td>HEAD 类似指针，指向当前活动分支的最新版本</td></tr><tr><td><strong>提交</strong>（Commit）</td><td>将 stage 中的所有变更提交到当前仓库的活动分支</td></tr><tr><td><strong>推送</strong>（Push）</td><td>将本地仓库的版本推送到远程仓库</td></tr><tr><td><strong>拉取</strong>（Pull）</td><td>从远程仓库获取更新到本地仓库</td></tr><tr><td><strong>获取</strong>（Fetch）</td><td>从远程仓库更新，作用同 pull，但是不会自动合并</td></tr><tr><td><strong>冲突</strong>（Conflict）</td><td>多人对同一个文件进行修改后在远程仓库合并时会面临冲突，需要人工合并处理</td></tr><tr><td><strong>合并</strong>（Merge）</td><td>对有 conflict 的文件进行合并操作，git 可以自动合并变更内容，无法自动处理的文件需要人工处理</td></tr><tr><td><strong>标签</strong>（Tag）</td><td>标签指的是某个分支某个特定时间点的状态，可以理解为提交记录的别名，常用来标记版本。</td></tr><tr><td><strong>main&#x2F;master</strong></td><td>仓库的默认主分支</td></tr><tr><td><strong>origin&#x2F;main</strong></td><td>表示远程仓库的 main 分支</td></tr></tbody></table><h2 id="工作区-暂存区-仓库"><a href="#工作区-暂存区-仓库" class="headerlink" title="工作区&#x2F;暂存区&#x2F;仓库"></a>工作区&#x2F;暂存区&#x2F;仓库</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412082111865.png" srcset="/img/banner.png" lazyload></p><ul><li>图中的 objects 标识的区域为 git 的对象库，实际的位置是“. Git&#x2F;objects”目录中，里面包含了创建的各种对象和内容</li><li>当对工作区的修改&#x2F;新增文件执行 <em>git add</em>命令后，暂存区的目录树被更新，同时工作区修改&#x2F;新增文件的内容被写入 objects 的一个新的对象中，而该对象的 ID 被记录在 stage 的文件索引中</li><li>当执行 <em>git commit</em>时，stage 的目录树写入 objects 中，main 分支做出更新</li><li>当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 git rm –cached “file” 命令时，会直接从暂存区删除文件，工作区则不做出改变</li></ul><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>本地计算机内的项目文件</p><h3 id="暂存区（stage）"><a href="#暂存区（stage）" class="headerlink" title="暂存区（stage）"></a>暂存区（stage）</h3><p>暂存区是一个临时存储区域，包含即将提交到版本库中的文件快照<br>常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git add filename       # 将单个文件添加到暂存区<br>git add .              # 将工作区中的所有修改添加到暂存区<br>git status             # 查看哪些文件在暂存区中<br></code></pre></td></tr></table></figure><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>版本库包含项目的所有版本历史记录，每次提交都会在版本库中创建一个新的快照，这些快照不可变，确保了项目的完整历史记录<br>常用命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git commit -m <span class="hljs-string">&quot;Commit message&quot;</span>   <span class="hljs-comment"># 将暂存区的更改提交到本地版本库</span><br>git log                          <span class="hljs-comment"># 查看提交历史</span><br>git <span class="hljs-keyword">diff </span>                        <span class="hljs-comment"># 查看工作区和暂存区之间的差异</span><br>git <span class="hljs-keyword">diff </span>--<span class="hljs-keyword">cached </span>               <span class="hljs-comment"># 查看暂存区和最后一次提交之间的差异</span><br></code></pre></td></tr></table></figure><h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><ul><li>工作区-&gt;暂存区</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span><br></code></pre></td></tr></table></figure><ul><li>暂存区-&gt;版本库</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;Commit message&quot;</span><br></code></pre></td></tr></table></figure><ul><li>版本库-&gt;远程仓库</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> branch-name<br></code></pre></td></tr></table></figure><ul><li>远程仓库-&gt;本地版本库</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git pull <span class="hljs-keyword">origin </span><span class="hljs-keyword">branch-name</span><br><span class="hljs-keyword"></span><span class="hljs-comment"># 或者</span><br>git fetch <span class="hljs-keyword">origin </span><span class="hljs-keyword">branch-name</span><br><span class="hljs-keyword"></span>git merge <span class="hljs-keyword">origin/branch-name</span><br></code></pre></td></tr></table></figure><h2 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412111054384.png" srcset="/img/banner.png" lazyload alt="|420"></p><h3 id="1、克隆仓库"><a href="#1、克隆仓库" class="headerlink" title="1、克隆仓库"></a>1、克隆仓库</h3><p>如果你要参与一个已有的项目，首先需要将远程仓库克隆到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/username/repo.git<br><span class="hljs-built_in">cd</span> repo<br></code></pre></td></tr></table></figure><h3 id="2、创建新分支"><a href="#2、创建新分支" class="headerlink" title="2、创建新分支"></a>2、创建新分支</h3><p>为了避免直接在 main 或 master 分支上进行开发，通常会创建一个新的分支：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git checkout -b <span class="hljs-keyword">new</span>-<span class="hljs-built_in">feature</span><br></code></pre></td></tr></table></figure><h3 id="3、工作目录"><a href="#3、工作目录" class="headerlink" title="3、工作目录"></a>3、工作目录</h3><p>在工作目录中进行代码编辑、添加新文件或删除不需要的文件。</p><h3 id="4、暂存文件"><a href="#4、暂存文件" class="headerlink" title="4、暂存文件"></a>4、暂存文件</h3><p>将修改过的文件添加到暂存区，以便进行下一步的提交操作：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> filename<br></code></pre></td></tr></table></figure><p>或者添加所有修改的文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure><h3 id="5、提交更改"><a href="#5、提交更改" class="headerlink" title="5、提交更改"></a>5、提交更改</h3><p>将暂存区的更改提交到本地仓库，并添加提交信息：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;Add new feature&quot;</span><br></code></pre></td></tr></table></figure><p>连接远程仓库</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git remote <span class="hljs-keyword">add</span> origin [git<span class="hljs-title">@github.com</span>]<br></code></pre></td></tr></table></figure><h3 id="6、拉取最新更改"><a href="#6、拉取最新更改" class="headerlink" title="6、拉取最新更改"></a>6、拉取最新更改</h3><p>在推送本地更改之前，最好从远程仓库拉取最新的更改，以避免冲突：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git pull origin <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><p>或者如果在新的分支上工作</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git pull <span class="hljs-built_in">origin</span> <span class="hljs-built_in">new</span>-<span class="hljs-built_in">feature</span><br></code></pre></td></tr></table></figure><h3 id="7、推送更改"><a href="#7、推送更改" class="headerlink" title="7、推送更改"></a>7、推送更改</h3><p>将本地的提交推送到远程仓库：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> <span class="hljs-built_in">new</span>-<span class="hljs-built_in">feature</span><br></code></pre></td></tr></table></figure><h3 id="8、删除分支"><a href="#8、删除分支" class="headerlink" title="8、删除分支"></a>8、删除分支</h3><p>如果不再需要新功能分支，可以将其删除：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git branch -d <span class="hljs-keyword">new</span>-<span class="hljs-built_in">feature</span><br></code></pre></td></tr></table></figure><p>或者从远程仓库删除分支：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> <span class="hljs-built_in">new</span>-<span class="hljs-built_in">feature</span><br></code></pre></td></tr></table></figure><h1 id="Git-指令"><a href="#Git-指令" class="headerlink" title="Git 指令"></a>Git 指令</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412102151126.png" srcset="/img/banner.png" lazyload></p><h1 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h1><p>Git 仓库在 fork 中打开后界面如下：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202412172133789.png" srcset="/img/banner.png" lazyload alt="|405"><br>可以看到每一个分支相互平行，只有完成某些项目的开发时才会合并到主分支。<br>那么分支有什么用呢？当计划开发一个新的功能时，第一天完成了百分之 50，如果直接提交到 master 分支，则可能导致别人无法开发，如果全部写完再提交的话又可能因为意外丢失之前的进度。此时就体现出来分支的优越性了。我们可能创建一个属于自己的别人不可见的分支，在这个分支上开发提交代码不会影响他人，可以随意操作，等到开发结束了再一次性合并到 master 分支。</p><h2 id="Git-分支常用命令"><a href="#Git-分支常用命令" class="headerlink" title="Git 分支常用命令"></a>Git 分支常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch # 列出所有本地分支<br><br>git branch -r #列出所有远程分支<br><br>git branch -a #列出所有本地和远程的分支<br><br>git branch [new-branch-name] #创建一个新的分支，但停留在当前分支<br><br>git checkout -b [new-branch-name] #创建一个新的分支，并切换到该分支<br><br>git branch --track [branch] [remote-branch] #创建一个新分支，并与指定的远程分支建立追踪关系<br><br>git checkout [new-branch-name] #切换到指定分支，并更新工作区<br><br>git merge [branch] #合并指定分支到当前分支<br><br>git branch -d [branch] #删除分支<br><br>git push origin --delete [branch] #删除远程分支<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脉冲成形滤波器</title>
    <link href="/2024/11/21/%E8%84%89%E5%86%B2%E6%88%90%E5%BD%A2%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2024/11/21/%E8%84%89%E5%86%B2%E6%88%90%E5%BD%A2%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>数字信号要想在信道中传输，必须在发射机的基带部分进行脉冲成型，将数字信号转化为脉冲信号；脉冲信号到达接收机后，在基带部分进行采样判决后恢复出数字信号。</p><h1 id="脉冲成形"><a href="#脉冲成形" class="headerlink" title="脉冲成形"></a>脉冲成形</h1><h2 id="矩形脉冲"><a href="#矩形脉冲" class="headerlink" title="矩形脉冲"></a>矩形脉冲</h2><p>最容易实现的脉冲波形就是矩形脉冲，以数字信号“00010110”为例，在发射端可以将“0”映射为正脉冲，“1”映射为负脉冲。在接受端采样时刻的信号电平为正电平则为“0”，信号电平为负电平则为“1”。<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411182156690.png" srcset="/img/banner.png" lazyload alt="|525"><br>但是矩形脉冲信号的频谱为无限宽，所以在带宽有限的信道传输时会发生失真，甚至可能导致采样判决失真，无法恢复出数字信号。</p><h2 id="Sinc-脉冲"><a href="#Sinc-脉冲" class="headerlink" title="Sinc 脉冲"></a>Sinc 脉冲</h2><p>Sinc 脉冲信号有两个优点：</p><ul><li>Sinc 信号的频谱带宽是有限的，经过带宽有限的信道进行传输时不会出现失真。<br>  <img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411182201184.png" srcset="/img/banner.png" lazyload alt="|500"></li><li>一个码元达到最大幅值时其他码元的幅值刚好为 0，码元之间不会相互影响，实现无码间串扰。<br>以数字信号 00010110 为例，0 映射为正脉冲，1 映射为负脉冲。<br>发射端经过脉冲成形后的波形如下：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411182204636.png" srcset="/img/banner.png" lazyload alt="|500"><br>接收端的采样判决如下：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411182204500.png" srcset="/img/banner.png" lazyload alt="|500"></li></ul><h1 id="基带滤波器"><a href="#基带滤波器" class="headerlink" title="基带滤波器"></a>基带滤波器</h1><h2 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h2><p>如果要脉冲成形为 sinc 波形，只要将单位冲激信号输入理想 LPF 即可得到 sinc 脉冲信号。<br>如果 LPF 的带宽为 B，则输出的 sinc 脉冲信号波形如下：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411182209002.png" srcset="/img/banner.png" lazyload alt="|500"><br>只要 sinc 脉冲信号发送间隔设为 $\frac{1}{B}$，也就是码元传输速率 $R_B&#x3D;2B$，就可以实现无码间串扰。</p><h2 id="升余弦滚降滤波器"><a href="#升余弦滚降滤波器" class="headerlink" title="升余弦滚降滤波器"></a>升余弦滚降滤波器</h2><p>采用理想低通滤波器对单位冲激信号进行滤波得到的 sinc 脉冲信号，拖尾振荡幅度比较大、衰减速度比较慢，当定时出现偏差时，码间串扰会比较大。考虑到实际的系统总是存在一定的定时误差，所以脉冲成形一般不采用理想低通滤波器，而是采用升余弦滚降滤波器，这种滤波器拖尾振幅小、衰减快，对于减小码间串扰和降低对定时的要求都有利。<br>升余弦滚降滤波器的频率响应为：<br>$$<br>\begin{aligned}<br>&amp;\mathrm{H}(f)&#x3D;\begin{cases}\frac{1}{2B},&amp;0\leqslant\left|f\right|&lt;\left(1-\alpha\right)B\\frac{1}{4B}\left{1+\cos\frac{\pi}{2B\alpha}\Big[\left|f\right|-B\left(1-\alpha\right)\right]\Big},&amp;(1-\alpha)B\leqslant|f|&lt;(1+\alpha)B\0,&amp;\left|f\right|\geqslant\left(1+\alpha\right)B \<br>\end{cases}\end{aligned}<br>$$<br>其中，$B&#x3D;\frac{R_B}{2}$<br>升余弦滚降滤波器的频率响应曲线如下：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411182214240.png" srcset="/img/banner.png" lazyload><br>升余弦滚降滤波器的单位冲激响应为：<br>$$<br>\mathrm h(t)&#x3D;\mathscr{F}^{-1}\big[\mathrm H(f)\big]&#x3D;\mathrm sinc\big(2Bt\big)\frac{\cos\big(2\pi\alpha Bt\big)}{1-\big(4\alpha Bt\big)^2}<br>$$<br>其中 $\alpha$ 是升余弦滚降滤波器的一个很重要的参数，称为滚降系数。<br>当 $\alpha&#x3D;0$ 时，升余弦滚降滤波器就是一个带宽为 B 的理想低通滤波器。<br>当 $\alpha&#x3D;0.5$ 时，升余弦滚降滤波器的频率响应和单位冲激响应如下：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411182219396.png" srcset="/img/banner.png" lazyload><br>此时滤波器的带宽为 $（1+\alpha）B&#x3D;1.5B$。<br>当 $\alpha&#x3D;1$ 时，升余弦滚降滤波器的频率响应和单位冲激响应如下：<br><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411190916731.png" srcset="/img/banner.png" lazyload><br>此时滤波器带宽为 $（1+\alpha）B&#x3D;2B$。<br>在使用升余弦滚降滤波器进行脉冲成形时，要想实现无码间串扰，则脉冲信号之间的时间间隔必须为 $\frac{1}{2B}$，即码元速率为 $R_B&#x3D;2B$。<br>由于升余弦滚降滤波器会展宽带宽，因此在给定码元速率 $R_B$ 的情况下，基带信号的频谱带宽为 $(1+\alpha)\times \frac{R_B}{2}$。</p><h1 id="眼图"><a href="#眼图" class="headerlink" title="眼图"></a>眼图</h1><p>眼图可以用来评估一个系统的码间串扰情况。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FPGA中的电平标准</title>
    <link href="/2024/11/16/FPGA%E4%B8%AD%E7%9A%84%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/"/>
    <url>/2024/11/16/FPGA%E4%B8%AD%E7%9A%84%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/</url>
    
    <content type="html"><![CDATA[<p>FPGA 在与外界进行信息交换时，为了确保信息的正确性，发送和接收信息都要对信息有认定的标准。在数字电路中，我们常用电压高低来表示“0”和“1”，那么多高的电压才会被当作“1”呢，这个时候就需要一个标准，这个标准就是电平标准。 </p><h1 id="常见电平标准"><a href="#常见电平标准" class="headerlink" title="常见电平标准"></a>常见电平标准</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411141024162.png" srcset="/img/banner.png" lazyload></p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>TTL (Transistor - Transistor Logic，三极管 - 三极管逻辑电平) 是电平标准中的元老级成员。<br>在早期的数字电路中有广泛的应用，但是它有一些缺点，比如高电平的判决门限和供电电压之间的电压空间较大，容易造成信号的不稳定性；而且 5 V 的电压过于耗电。</p><h2 id="LVTTL"><a href="#LVTTL" class="headerlink" title="LVTTL"></a>LVTTL</h2><p>LVTTL（Low Voltage Transistor - Transistor Logic，低压 TTL 电平标准）改进了 TTL 的缺点，将供电电压改为了 $3.3V$，功耗也相应降低了，而且提升了信号稳定性。</p><h2 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h2><p>CMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体电平）的特点是功耗较低，可以根据电路的工作状态自动调整功耗。</p><h2 id="LVCMOS"><a href="#LVCMOS" class="headerlink" title="LVCMOS"></a>LVCMOS</h2><p>LVCMOS（Low Voltage Complementary Metal Oxide Semiconductor，低压 CMOS 电平标准）在 CMOS 的基础上进一步降低供电电压，降低功耗。LVCMOS 在低功耗、中低速数字电路中非常受欢迎。</p><h2 id="LVDS"><a href="#LVDS" class="headerlink" title="LVDS"></a>LVDS</h2><p>LVDS，全称是Low Voltage Differential Signaling，是一种利用低压差分信号传输高速信号的电平标准，有低压，低功耗，噪声抑制能力强的特点。LVDS 的输出电压摆幅极小，只有 $\pm 350mV$，电流只有 $3.5mA$ 左右。由于其超低功耗和超快数据传输速率，常用于高速数据传输。</p>]]></content>
    
    
    <categories>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路中的电平标准</title>
    <link href="/2024/11/16/%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/"/>
    <url>/2024/11/16/%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/</url>
    
    <content type="html"><![CDATA[<p>FPGA 在与外界进行信息交换时，为了确保信息的正确性，发送和接收信息都要对信息有认定的标准。在数字电路中，我们常用电压高低来表示“0”和“1”，那么多高的电压才会被当作“1”呢，这个时候就需要一个标准，这个标准就是电平标准。</p><h1 id="常见电平标准"><a href="#常见电平标准" class="headerlink" title="常见电平标准"></a>常见电平标准</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202411141024162.png" srcset="/img/banner.png" lazyload alt="2024after4202411141024162.png"></p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>TTL (Transistor - Transistor Logic，三极管 - 三极管逻辑电平) 是电平标准中的元老级成员。<br>在早期的数字电路中有广泛的应用，但是它有一些缺点，比如高电平的判决门限和供电电压之间的电压空间较大，容易造成信号的不稳定性；而且 5 V 的电压过于耗电。</p><h2 id="LVTTL"><a href="#LVTTL" class="headerlink" title="LVTTL"></a>LVTTL</h2><p>LVTTL（Low Voltage Transistor - Transistor Logic，低压 TTL 电平标准）改进了 TTL 的缺点，将供电电压改为了 $3.3V$，功耗也相应降低了，而且提升了信号稳定性。</p><h2 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h2><p>CMOS（Complementary Metal Oxide Semiconductor，互补金属氧化物半导体电平）的特点是功耗较低，可以根据电路的工作状态自动调整功耗。</p><h2 id="LVCMOS"><a href="#LVCMOS" class="headerlink" title="LVCMOS"></a>LVCMOS</h2><p>LVCMOS（Low Voltage Complementary Metal Oxide Semiconductor，低压 CMOS 电平标准）在 CMOS 的基础上进一步降低供电电压，降低功耗。LVCMOS 在低功耗、中低速数字电路中非常受欢迎。</p><h2 id="LVDS"><a href="#LVDS" class="headerlink" title="LVDS"></a>LVDS</h2><p>LVDS，全称是Low Voltage Differential Signaling，是一种利用低压差分信号传输高速信号的电平标准，有低压，低功耗，噪声抑制能力强的特点。LVDS 的输出电压摆幅极小，只有 $\pm 350mV$，电流只有 $3.5mA$ 左右。由于其超低功耗和超快数据传输速率，常用于高速数据传输。</p>]]></content>
    
    
    <categories>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab R2024b安装本地文档</title>
    <link href="/2024/10/28/Matlab%20R2024b%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0%E6%96%87%E6%A1%A3/"/>
    <url>/2024/10/28/Matlab%20R2024b%E5%AE%89%E8%A3%85%E6%9C%AC%E5%9C%B0%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<details><summary>安装包</summary><p>通过网盘分享的文件：MATLAB R2024b<br>链接: <a href="https://pan.baidu.com/s/1T8-V_guBJhSD-Yze0wEVmQ?pwd=9h5c">https://pan.baidu.com/s/1T8-V_guBJhSD-Yze0wEVmQ?pwd&#x3D;9h5c</a> 提取码: 9h5c<br>–来自百度网盘超级会员v2的分享</p></details><h1 id="挂载后导航到镜像中的安装包文件夹"><a href="#挂载后导航到镜像中的安装包文件夹" class="headerlink" title="挂载后导航到镜像中的安装包文件夹"></a>挂载后导航到镜像中的安装包文件夹</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">cd &lt;mountedDocImage&gt;/bin/&lt;arch&gt;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;mountedDocImage&gt;</code> 是装载的文档 ISO 或 DMG 镜像的根目录。</li><li><code>&lt;arch&gt;</code> 是 ISO 或 DMG 镜像的操作系统架构文件夹，例如 <code>win64</code>、<code>glnxa64</code>、<code>maci64</code> 或 <code>maca64</code></li></ul><h1 id="使用mpm-install-doc命令运行文档安装程序"><a href="#使用mpm-install-doc命令运行文档安装程序" class="headerlink" title="使用mpm install-doc命令运行文档安装程序"></a>使用mpm install-doc命令运行文档安装程序</h1><p>为了将文档安装到指定的位置，要使用**—destination<strong>命令，用</strong>—source**命令指定安装程序文件路径</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">.\mpm install-doc --matlabroot=&lt;matlabrootfolder&gt; --source=&lt;docinstallfolder&gt; <br>--destination=&lt;destinationfolder&gt;<br></code></pre></td></tr></table></figure><h1 id="配置MATLAB"><a href="#配置MATLAB" class="headerlink" title="配置MATLAB"></a>配置MATLAB</h1><ol><li>预设项中，将<strong>帮助</strong>中的文档位置选为<strong>本地</strong></li><li>在<a href="https://ww2.mathworks.cn/help/matlab/ref/userpath.html">userpath</a>中创建startup.m文件，使用<strong>docroot命令</strong> 指定帮助文档的路径</li></ol><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202410281935483.png" srcset="/img/banner.png" lazyload alt="2024after4202410281935483.png"></p><h1 id="验证本地安装"><a href="#验证本地安装" class="headerlink" title="验证本地安装"></a><strong>验证本地安装</strong></h1><p>验证文档是否在本地打开。在 MATLAB 命令提示符下，输入：<code>doc</code></p><p>在打开的浏览器页面中，检查 URL 的地址。</p><ul><li>如果 URL 指向本地 IP 地址和端口号（例如 <code>http://127.0.0.1:12345</code>），则 MATLAB 访问的是本地安装的文档。</li><li>如果 URL 指向 Web 地址（例如 <code>https://www.mathworks.com/help/...</code>），则 MATLAB 访问的仍然是 Web 文档。更新 MATLAB 以指向本地安装的文档，如<a href="https://ww2.mathworks.cn/help/install/ug/install-documentation-on-offline-machines.html#mw_41ca579b-3dfa-4d19-a041-9c6e95920ac6">配置 MATLAB 以使用安装的文档</a>中所述。</li></ul><p>$$</p><p>$$</p>]]></content>
    
    
    <categories>
      
      <category>杂类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DVB-S系统设计报告</title>
    <link href="/2024/10/20/DVB-S%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
    <url>/2024/10/20/DVB-S%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="DVB标准"><a href="#DVB标准" class="headerlink" title="DVB标准"></a>DVB标准</h1><p>Digital Video Broadcasting（数字视频广播）是一个完整的数字电视解决方案，其中包括DVB-C（数字电视有线传输标准），<br>DVB-T（数字电视地面传输标准），DVB-S（数字电视卫星传输标准），下面主要介绍DVB-S系统。</p><p>DVB-S为数字卫星广播标准，卫星传输具有覆盖面广、节目容量大等优点。信号采用RS(188，204)和卷积码的级联编码，调制方式为QPSK。</p><h1 id="DVB-S信道编码及调制的基本原理"><a href="#DVB-S信道编码及调制的基本原理" class="headerlink" title="DVB-S信道编码及调制的基本原理"></a>DVB-S信道编码及调制的基本原理</h1><h2 id="原理框图"><a href="#原理框图" class="headerlink" title="原理框图"></a>原理框图</h2><p>根据ETSI的DVB-S标准，原理框图如下所示</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717241147381.png" srcset="/img/banner.png" lazyload alt="1717241147381.png"></p><p>由于卫星提供的DTH服务特别受功率限制的影响，因此主要的设计目的应该为抗噪声和干扰，而不是频谱效率。为了在不过度损害频谱效率的前提下实现很高的能量效率，系统应使用QPSK调制和卷积码和RS码的级联。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406012140085.png" srcset="/img/banner.png" lazyload alt="2024after4202406012140085.png"></p><h2 id="信道编码"><a href="#信道编码" class="headerlink" title="信道编码"></a>信道编码</h2><h2 id="TS流适配单元（adaptation）"><a href="#TS流适配单元（adaptation）" class="headerlink" title="TS流适配单元（adaptation）"></a>TS流适配单元（adaptation）</h2><p>输入的TS流根据MPEG-2格式按照固定的长度打包，数据包的长度为188，帧头为同步字 $47_{hex}$。DVB-S标准中要求每8个TS数据包组成一个超帧，将超帧中的8个同步头进行反转，变为$b8_{hex}$，其余的同步头不变。同时还要自动插入空包，在数据包后插入16个0，将长度为188的数据包包补充成长度为204的数据包，与后续的信道编码模块建立时钟匹配和接口连接。</p><h2 id="扰码单元（energy-dispersal）"><a href="#扰码单元（energy-dispersal）" class="headerlink" title="扰码单元（energy dispersal）"></a>扰码单元（energy dispersal）</h2><p>基带信号中含有很多连“1”或者连“0”的现象，会导致基带信号的频谱中含有较多的低频成分，既不利于信号在信道的传输，也不利于在接收端提取时钟信号。因此采用扰码，将TS流转化成伪随机序列。DVB-S标准中的随机化的原理图如下：</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406012158761.png" srcset="/img/banner.png" lazyload alt="2024after4202406012158761.png"></p><p>伪随机二进制序列的生成多项式如下：</p><p>$$<br>1 + x^{14} + x^{15}<br>$$</p><p>扰码以8个数据包组成的超帧为单位进行处理，在每一个单元开始处理时，将序列”100101010000000“装入寄存器，对其进行扰码处理。数据包的同步字不进行扰码处理。</p><h2 id="RS编码"><a href="#RS编码" class="headerlink" title="RS编码"></a>RS编码</h2><p>外码采用RS编码，其具有同时纠正随机错误和突发错误的能力，并且纠正突发错误更有效。DVB-S采用的编码格式为RS(239,255)截断而得到的RS(188,204)编码，最大可纠错长度为8个字节，编码从同步字$47_{hex}$<em>或</em>$b8_{hex}$开始。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406021124574.png" srcset="/img/banner.png" lazyload alt="2024after4202406021124574.png"></p><h2 id="编码原理简述"><a href="#编码原理简述" class="headerlink" title="编码原理简述"></a>编码原理简述</h2><p>假设信息多项式为</p><p>$$<br>m(x)&#x3D;m_{187}x^{187}+m_{186}x^{186}+\cdots+m_1x^1+m_0<br>$$</p><p>码生成多项式为</p><p>$$<br>g(x)&#x3D;(x+a^0)(x+a^1)(x+a^2)\cdots(x+a^{14})(x+a^{15})<br>$$</p><p>其中的_a_ &#x3D; 02_hex_，则生成多项式的展开式为</p><p>$$<br>g(x)&#x3D;x^{16}+59x^{15}+13x^{14}+104x^{13}+189x^{12}+68x^{11}+209x^{10}\\+30x^{9}+8x^8+163x^7+65x^6+41x^5+229x^4+98x^3+50x^2+36x+59<br>$$</p><p>将$x^{16}\cdot m(x)$除以$g(x)$后，余式为关于x的15次多项式，其16个系数即为生成的16个校验字节，将其添加到188长度的数据包后即可完成RS(188,204)的编码。</p><h2 id="卷积交织"><a href="#卷积交织" class="headerlink" title="卷积交织"></a>卷积交织</h2><p>在数字信号传输过程中，由于一些突发性干扰，会导致一连串的数据错误，很有可能超出RS码的纠错范围。而卷积交织可以将错误的字符分散开，使得信道变成近似无记忆信道。DVB-S中采用的是交织深度为12的卷积交织。交织和解交织的框图如下：</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406021621696.png" srcset="/img/banner.png" lazyload alt="2024after4202406021621696.png"></p><h2 id="卷积编码"><a href="#卷积编码" class="headerlink" title="卷积编码"></a>卷积编码</h2><p>内码采用的是(2,1,7)型的卷积码，编码效率为$\frac{k}{n}&#x3D;\frac{1}{2}$，由6个移位寄存器和2个模二加加法器构成，1个bit信号生成2个bit的编码信号，约束长度为7。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406021629604.png" srcset="/img/banner.png" lazyload alt="2024after4202406021629604.png"></p><p>当信道质量较好时可以对编码信号进行删余，提高信道利用率。</p><h1 id="Matlab仿真"><a href="#Matlab仿真" class="headerlink" title="Matlab仿真"></a>Matlab仿真</h1><h2 id="TS流适配及扰码模块"><a href="#TS流适配及扰码模块" class="headerlink" title="TS流适配及扰码模块"></a>TS流适配及扰码模块</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406052140904.png" srcset="/img/banner.png" lazyload alt="2024after4202406052140904.png"></p><h3 id="CLKdivide"><a href="#CLKdivide" class="headerlink" title="CLKdivide"></a>CLKdivide</h3><p>一路高清电视信号的码率为$8Mbps$，因此二进制信号的速率为$8Mbps$，输入的数据为$uint8$类型，所以输入的信号速率为$1M$。所以CLKdivide模块将$200MHz$的时钟分频到$1MHz和8MHz$。</p><h3 id="sigSource"><a href="#sigSource" class="headerlink" title="sigSource"></a>sigSource</h3><p>此模块产生输入的TS流信号，并且生成RS编码的开始、结束和使能信号。由于每输出一个188字节长度的数据包后要暂停输出TS流插入空包，所以采用使能系统，每计数188次后拉低使能插入空包。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717680505998.png" srcset="/img/banner.png" lazyload alt="1717680505998.png"></p><h3 id="HeaderProcess"><a href="#HeaderProcess" class="headerlink" title="HeaderProcess"></a>HeaderProcess</h3><p>此模块对输入的TS流进行速率转换和组超帧，每八个数据包组合为一个超帧，并反转第一个同步字，由$0x47$转为$0xb8$，并生成使能sigSource的信号。同时生成扰码模块的控制信号。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717595838765.png" srcset="/img/banner.png" lazyload alt="1717595838765.png"></p><p>第一个Multiport Switch用来进行插入空包，第二个Multiport Switch用来反转超帧的第一个同步字。</p><h3 id="myScrambler"><a href="#myScrambler" class="headerlink" title="myScrambler"></a>myScrambler</h3><p>根据扰码的生成多项式进行设计。HeaderProcess生成的扰码使能信号正好在输入同步字时拉低，不进行扰码处理，扰码复位信号在输入了一个超帧后重新装入初始序列”100101010000000“。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717596010781.png" srcset="/img/banner.png" lazyload alt="1717596010781.png"></p><h3 id="仿真数据"><a href="#仿真数据" class="headerlink" title="仿真数据"></a>仿真数据</h3><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717596346825.png" srcset="/img/banner.png" lazyload alt="1717596346825.png"></p><h2 id="RS编码模块"><a href="#RS编码模块" class="headerlink" title="RS编码模块"></a>RS编码模块</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717660503082.png" srcset="/img/banner.png" lazyload alt="1717660503082.png"></p><p>使用HDL Coder中的模块，由于时钟速率为200 $MHz$，因此需要加入一个触发模块，保证RS编码是按照码元速率$R_B$进行编码</p><h2 id="卷积交织-1"><a href="#卷积交织-1" class="headerlink" title="卷积交织"></a>卷积交织</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717678715013.png" srcset="/img/banner.png" lazyload alt="1717678715013.png"></p><p>同样加入触发模块，保证交织的速度为码元速率$R_B$。</p><h2 id="uint8转binary模块"><a href="#uint8转binary模块" class="headerlink" title="uint8转binary模块"></a>uint8转binary模块</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717679814804.png" srcset="/img/banner.png" lazyload alt="1717679814804.png"></p><p>首先对输入的数据按位相与，取出每一位的数据后使用Multiport Switch逐位输出，计数器的使能速率为码元速率$R_B$的8倍。</p><h2 id="卷积编码-1"><a href="#卷积编码-1" class="headerlink" title="卷积编码"></a>卷积编码</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717680106902.png" srcset="/img/banner.png" lazyload alt="1717680106902.png"></p><p>不进行删余的话，编码效率为$\frac{1}{2}$。也可以进行删余，可以得到$\frac{2}{3}、\frac{3}{4}、\frac{5}{6}、\frac{7}{8}$的编码效率。在一定带宽内，编码效率越大传输效率越大，同时纠错能力越差。</p><h1 id="Vivado实现"><a href="#Vivado实现" class="headerlink" title="Vivado实现"></a>Vivado实现</h1><p>Vivado的代码大部分都由HDL Coder生成，或者由Matlab生成系数文件，再导入到Vivado的IP核中。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202407102025567.svg" srcset="/img/banner.png" lazyload alt="2024after4202407102025567.svg"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717682059758.png" srcset="/img/banner.png" lazyload alt="1717682059758.png"></p><h2 id="DataSource-Scrambler"><a href="#DataSource-Scrambler" class="headerlink" title="DataSource_Scrambler"></a>DataSource_Scrambler</h2><p>直接生成hdl代码的话，DataSource_Scrambler模块中的sigSource模块在200 $MHz$的频率下建立时间的裕量不满足时序，因此在生成HDL之前进行如下配置：</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406062201977.png" srcset="/img/banner.png" lazyload alt="2024after4202406062201977.png"></p><p>在输出端加入一级流水线后，综合布线后时序即可通过。同时在这个模块的输出信号处全部加上一个delay模块组成流水线。</p><h3 id="扰码模块"><a href="#扰码模块" class="headerlink" title="扰码模块"></a>扰码模块</h3><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717850077215.png" srcset="/img/banner.png" lazyload alt="1717850077215.png"></p><p>可以看到每输入8个数据包后，扰码内部的D触发器的初值得到重置，同时反转后的同步字$0xb8$没有被扰码处理。</p><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>在仿真过程中，发现同步字$0xb8$和RS编码的使能信号没有对齐，因此添加如下模块：</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717914876682.png" srcset="/img/banner.png" lazyload alt="1717914876682.png"></p><p>在将输出的使能信号延后一个数据周期，即可保证信号的同步。</p><h2 id="RS编码-1"><a href="#RS编码-1" class="headerlink" title="RS编码"></a>RS编码</h2><p>将modelsim的数据导入到matlab进行解码，可以看到将188个数据包完整的解了出来。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717915096882.png" srcset="/img/banner.png" lazyload alt="1717915096882.png"></p><h2 id="升余弦滚降滤波器"><a href="#升余弦滚降滤波器" class="headerlink" title="升余弦滚降滤波器"></a>升余弦滚降滤波器</h2><h3 id="Matlab滤波器设计"><a href="#Matlab滤波器设计" class="headerlink" title="Matlab滤波器设计"></a>Matlab滤波器设计</h3><p>根据DVB-S标准的要求，升余弦滚降系数为$0.35$，使用Matlab的filterDesigner工具设计滤波器系数。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717726664610.png" srcset="/img/banner.png" lazyload alt="1717726664610.png"></p><p>在FPGA中要对滤波器系数进行定点化处理。</p><p>对系数进行32位量化后幅值响应如下：</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717726986681.png" srcset="/img/banner.png" lazyload alt="1717726986681.png"></p><p>对系数进行16位量化后幅值响应如下：</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1721734678137.png" srcset="/img/banner.png" lazyload alt="1721734678137.png"></p><p>可以看出16位量化的幅值响应和32位量化的响应几乎一样，为了节省空间，因此使用16位量化。</p><p>量化结束后点击目标→Xilinx系数文件 生成coe文件。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717727667745.png" srcset="/img/banner.png" lazyload alt="1717727667745.png"></p><h3 id="Vivado-Fir滤波器设计"><a href="#Vivado-Fir滤波器设计" class="headerlink" title="Vivado Fir滤波器设计"></a>Vivado Fir滤波器设计</h3><p>选择 Source为COE FIle</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406071040715.png" srcset="/img/banner.png" lazyload alt="2024after4202406071040715.png"></p><p>输入的采样频率要和时钟频率相等，不进行过采样。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406071042659.png" srcset="/img/banner.png" lazyload alt="2024after4202406071042659.png"></p><p>在Implementation中将系数类型选择为有符号数，位宽设置为16。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406071044904.png" srcset="/img/banner.png" lazyload alt="2024after4202406071044904.png"></p><p>输入的信号为正负1，所以输入的位宽为2，第一位为符号位。输出模式设置为全精度。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717728524290.png" srcset="/img/banner.png" lazyload alt="1717728524290.png"></p><h3 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h3><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1717728686099.png" srcset="/img/banner.png" lazyload alt="1717728686099.png"></p><h1 id="使用XDMA进行数据的输入和输出采集"><a href="#使用XDMA进行数据的输入和输出采集" class="headerlink" title="使用XDMA进行数据的输入和输出采集"></a>使用XDMA进行数据的输入和输出采集</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202407102121277.png" srcset="/img/banner.png" lazyload alt="2024after4202407102121277.png"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202407102121462.png" srcset="/img/banner.png" lazyload alt="2024after4202407102121462.png"></p><p>结构框图如上。</p><p>工程的总体结构如上所示，数据通过XDMA的M_AXIS_H2C接口写入数据。由于写入数据的位宽为128bit，工程中信号处理部分的输入位宽为8bit，因此加入AXISDataWidthConverter模块将位宽从16BYTE转为1BYTE，并写入FIFO，使用AXIGPIO模块读取FIFO的almost full信号，如果FIFO被写满，almost full被拉高，就停止写入数据。读取DVB-S生成的QPSK信号时，由于经过了升余弦滚降滤波和调制，信号的位宽已经较大，为了降低复杂度选择将调制信号高位补零至128bit后经M_AXIS_C2H接口输出到Host主机。</p><p>调试过程见</p><p><a href="13496f31-fcb9-81f6-a26b-ca465fecb2cf">link_to_page</a></p>]]></content>
    
    
    <categories>
      
      <category>数字通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Report</tag>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZYNQ</title>
    <link href="/2024/09/27/ZYNQ/"/>
    <url>/2024/09/27/ZYNQ/</url>
    
    <content type="html"><![CDATA[<h1 id="ZYNQ体系结构"><a href="#ZYNQ体系结构" class="headerlink" title="ZYNQ体系结构"></a>ZYNQ体系结构</h1><p>Zynq的总体架构包含两个部分：PS（处理器系统）和PL（可编程逻辑）。这两部分的供电电路上相互独立的，因此PS和PL可以单独使用，不被使用的部分可以断电以降低功耗。不过Zynq最有价值的模式上两个组成部分结合起来使用。</p><h1 id="PS（处理器系统）"><a href="#PS（处理器系统）" class="headerlink" title="PS（处理器系统）"></a>PS（处理器系统）</h1><p>作为处理器系统的基础，所有芯片都包含一颗双核的ARM Cortex- A9芯片。这是一颗硬处理器，是芯片上专门且优化过的硅片元件。</p><p>除了“硬”处理器，还有另外一种方案，像是MicroBlaze这样的“软”处理器，这是由PL端端单元组合成的，即和PL端的IP是等价的。相比之下，“硬”处理器可以获得相对较高的性能，“软”处理器的数量和精确实现是灵活的。</p><p>值得一提的是，可以在zynq的PL端分配一个或多个MicroBlaze软处理器，用于和硬核协同工作。比如可以让软核负责协调特定的底层功能和系统之间的配合，将要求不高的任务从硬核上脱离出来，提高整体性能。</p><p><img src="https://s2.loli.net/2024/10/15/b5KAyTow21a3NXv.png" srcset="/img/banner.png" lazyload alt="b5KAyTow21a3NXv.png"></p><p>zynq的PS端里面并非只有ARM处理器，还有一组相关的处理资源，构成一个应用处理器单元（Application Processing Uint，APU），另外还有扩展外设接口、cache存储器、存储器接口、互联接口和时钟发生电路。</p><p><img src="https://s2.loli.net/2024/10/15/U2hAxkw1QgKJD7t.png" srcset="/img/banner.png" lazyload alt="U2hAxkw1QgKJD7t.png"></p><h1 id="PL（可编程逻辑）"><a href="#PL（可编程逻辑）" class="headerlink" title="PL（可编程逻辑）"></a>PL（可编程逻辑）</h1><p>zynq中的逻辑部分是基于Artix7和Kintex7的fpga组件。</p><h1 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h1><p><img src="https://s2.loli.net/2024/10/15/yNq72JCTcwIVxbX.png" srcset="/img/banner.png" lazyload alt="yNq72JCTcwIVxbX.png"></p><ul><li>可配置逻辑块（CLB）—— CLB是逻辑单元的小规模、普通编组，在PL中排列为一个二维阵列，通过可编程互联连接到其他类似的资源。每个CLB内都含有两个逻辑片，并紧邻一个开关矩阵。</li><li>片（Slice）—— CLB里的子单元，里面有实现组合和时序逻辑电路的资源。</li></ul><p><img src="https://s2.loli.net/2024/10/15/EaAknYzH7fUXWRl.png" srcset="/img/banner.png" lazyload alt="EaAknYzH7fUXWRl.png"></p><ul><li><p>查找表（Lookup Table，LUT）—— 一个灵活的资源，可以实现</p><ol><li>至多6个输入的逻辑函数</li><li>一小片只读存储器（ROM）</li><li>一小片随机访问存储器（RAM）</li><li>一个移位寄存器</li></ol><p>  LUT可以按需组合形成一个更大的逻辑函数、存储器或移位寄存器。</p></li><li><p>触发器（Flip-flop，FF）—— 一个实现一位寄存的时序电路，带有复位功能。其中一个用处是实现锁存。</p></li><li><p>开关矩阵（Switch Matrix）—— 每个CLB旁边都有一个开关矩阵，实现灵活的布线功能来连接CLB内的单元，或把CLB与PL内的其他资源连接起来。</p></li><li><p>进位逻辑（Carry Logic）—— 算术电路需要在相邻的片之间传递信号，这就是通过进位逻辑来实现的。</p></li><li><p>输入&#x2F;输出块（IOB）—— IOB实现了PL逻辑资源之间的对接，并提供物理设备“焊盘”来连接外部电路。每个IOB可以处理一位的输入或输出信号，IOB一般位于芯片的周边。</p></li></ul><h1 id="特殊资源：DSP48E1和BRAM"><a href="#特殊资源：DSP48E1和BRAM" class="headerlink" title="特殊资源：DSP48E1和BRAM"></a>特殊资源：DSP48E1和BRAM</h1><p>这两个资源都按列排列集成在逻辑阵列中，嵌入在逻辑部分中，而且彼此靠近，原因是密集计算和给内存中存储数据往往是紧密联系的运算。</p><p><img src="https://s2.loli.net/2024/10/15/4rAX3bdykQPplz1.png" srcset="/img/banner.png" lazyload alt="4rAX3bdykQPplz1.png"></p><h2 id="BRAM"><a href="#BRAM" class="headerlink" title="BRAM"></a>BRAM</h2><p>zynq-7000的BRAM和其他Xilinx 7系列FPGA里的BRAM是相同的，都可以实现RAM、ROM、FIFO，同时还支持纠错编码。</p><p>每个BRAM里最多可以存储36KB的信息，可以被配置为一个36KB的RAM或者两个独立的18KB的RAM。还可以被“重塑”来包含更多的更小的单元，或者组合起来组成更大容量大RAM。</p><p>使用BRAM意味着能在芯片内部优化的专用存储单元内，用很小的物理空间存储大量的数据。另一种方法是分布式RAM（Distributed RAM），DRAM是用逻辑部分里的LUT来搭建的，想要构成和BRAM大小相当的的存储器，需要用到大量的LUT，而且实现的结果还受到剧增的逻辑和布线延迟所造成的时序性能受限的影响。另一方面，用DRAM实现小存储器是有优势的，这样资源利用率高，并且布局更灵活。BRAM往往能工作在芯片支持的最高时钟频率下。</p><h2 id="DSP48E1"><a href="#DSP48E1" class="headerlink" title="DSP48E1"></a>DSP48E1</h2><p>逻辑部分的LUT可以用来实现任意长度的算术运算，但由于长字长的算术电路会在逻辑片内占据较大的空间，这样的布局和布线会导致时钟频率是次优的，因此最好拿LUT做短字长的运算。</p><p>DSP48E1是专门用于实现对长字长信号的高速算术运算的逻辑片，是专用的硅片资源，并且在逻辑单元内部包含了预加法器&#x2F;减法器、乘法器和后加法器&#x2F;减法器。</p><p><img src="https://s2.loli.net/2024/10/15/vCgbeN8i9Xtq7Eo.png" srcset="/img/banner.png" lazyload alt="vCgbeN8i9Xtq7Eo.png"></p><p>后加法器还可以用作逻辑单元，此时它可以做逻辑运算，支持所有的基础布尔运算。</p><p>如果需要更大字长的运算，可以将多个DSP组合起来做扩展。</p><h1 id="通用输入-输出"><a href="#通用输入-输出" class="headerlink" title="通用输入&#x2F;输出"></a>通用输入&#x2F;输出</h1><p>zynq上的通用输入&#x2F;输出功能合起来被成为SelectIO资源，它们被组成50个IOB一组，每个IOB都有一个焊盘，与外部世界连接。</p><p>I&#x2F;O组分为高性能（High Preformance，HP）或高范围（High Range，HR）。HP接口的电压最高为1.8V，通常用作连接存储器和其他芯片的高速接口；HR接口允许3.3V的电压，适合做各种IO标准的连接。两种接口都支持单端和差分信号。</p><p>每个IOB还包含一个IOSERDES资源，可以做并行和串行的可编程转换，数据位宽是2～8位。</p><h1 id="通信接口"><a href="#通信接口" class="headerlink" title="通信接口"></a>通信接口</h1><p>zynq内部含有嵌入在逻辑部分里的GTX收发器和高速通信接口块。</p><h1 id="其他可编程逻辑扩展接口"><a href="#其他可编程逻辑扩展接口" class="headerlink" title="其他可编程逻辑扩展接口"></a>其他可编程逻辑扩展接口</h1><ul><li>ADC—— XADC，具有两个独立的12位ADC，每个采样率为1Msps。</li><li>时钟—— PL接收来自PS的四个独立的时钟输入，另外还能产生和分发它自己的与PS无关的时钟。</li><li>JTAG调试接口</li></ul><h1 id="PS与PL之间的接口"><a href="#PS与PL之间的接口" class="headerlink" title="PS与PL之间的接口"></a>PS与PL之间的接口</h1><p>如前所述，Zynq 的表现不仅仅依赖于它的两个组成部分 PS 和 PL 的特性，还在于能把两者协同起来形成完整、集成的系统的能力。这其中起关键作用的，是一组高度定制的 AXI 互联和接口用来在两个部分之间形成桥梁。另外，在 PS 和 PL 之间还有一些其他类型的连接，特别是 EMIO。</p><h2 id="AXI"><a href="#AXI" class="headerlink" title="AXI"></a>AXI</h2><p>高级可扩展接口（Advanced eXtensible Interface）。当前版本为第四代AXI4 。</p><h3 id="AXI4"><a href="#AXI4" class="headerlink" title="AXI4"></a>AXI4</h3><p>用于存储映射连接，支持最高的性能，通过一簇高达256个数据字的传输来给定一个地址。</p><h3 id="AXI4-Lite"><a href="#AXI4-Lite" class="headerlink" title="AXI4-Lite"></a>AXI4-Lite</h3><p>简化的连接，只支持每次传输一个数据。AXI4Lite也是存储映射的，每次传输一个地址和单个数据。</p><h3 id="AXI4-Stream"><a href="#AXI4-Stream" class="headerlink" title="AXI4-Stream"></a>AXI4-Stream</h3><p>用于高速流式数据，支持批量传输无线大小的数据。没有地址机制，适合源与目的之间的直接数据流。</p><h2 id="EMIO接口"><a href="#EMIO接口" class="headerlink" title="EMIO接口"></a>EMIO接口</h2><p>EMIO涉及两个域之间的传输，是由一组简单的导线连接实现的。</p><p><img src="https://s2.loli.net/2024/10/15/s318l2SCX6zYIqE.png" srcset="/img/banner.png" lazyload alt="s318l2SCX6zYIqE.png"></p><h2 id="EBAZ4205矿板资料汇总"><a href="#EBAZ4205矿板资料汇总" class="headerlink" title="EBAZ4205矿板资料汇总"></a>EBAZ4205矿板资料汇总</h2><h1 id="扩展版"><a href="#扩展版" class="headerlink" title="扩展版"></a>扩展版</h1><p><a href="https://oshwhub.com/zefff/ebaz4205-ta-zhan-ban">ebaz4205拓展板 - 立创开源硬件平台 (oshwhub.com)</a></p><h1 id="开发板补全"><a href="#开发板补全" class="headerlink" title="开发板补全"></a>开发板补全</h1><p><a href="https://blog.csdn.net/Turix/article/details/109738107">从零开始的ZYNQ学习（基于矿卡EBAZ4205）（一）-CSDN博客</a></p><h1 id="原理图相关"><a href="#原理图相关" class="headerlink" title="原理图相关"></a>原理图相关</h1><p>矿板原理图</p><p><a href="https://github.com/Elrori/EBAZ4205">Elrori&#x2F;EBAZ4205: EBAZ4205 BOARD (github.com)</a></p><p>PCB</p><p><a href="https://prod-files-secure.s3.us-west-2.amazonaws.com/628159ee-386f-4c0d-9380-ce0eb31c8e54/3fc2ec3c-dfeb-4b1b-92ac-f2f7b591cefe/EBAZ4205-master.zip?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45GO43JXI4/20241118/us-west-2/s3/aws4_request&X-Amz-Date=20241118T065723Z&X-Amz-Expires=3600&X-Amz-Signature=77cdf20c2d653988a00ad61644e5762dc52cebbc934cf509509ae43b5ad7c2fc&X-Amz-SignedHeaders=host&x-id=GetObject">EBAZ4205-master.zip</a></p><p><a href="https://zhuanlan.zhihu.com/p/627427014">bookmark</a></p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDL coder使用手册</title>
    <link href="/2024/09/21/HDL%20coder%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2024/09/21/HDL%20coder%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>💡 由于本科毕设女朋友准备使用FPGA完成，因此写这篇文章帮助她快速上手HDL coder的使用，降低前期入门的难度。</p></blockquote><h1 id="支持生成HDL代码的simulink库"><a href="#支持生成HDL代码的simulink库" class="headerlink" title="支持生成HDL代码的simulink库"></a>支持生成HDL代码的simulink库</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211041121.png" srcset="/img/banner.png" lazyload alt="2024after4202409211041121.png"></p><p>名字中含有HDL的库中的模块一般都可以用来生成HDL代码。直接搜索模块名称，比如搜索fir，</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211050982.png" srcset="/img/banner.png" lazyload alt="2024after4202409211050982.png"></p><p>可以看到旁边会显示位于哪个库中，模块有可能位于多个库，只要有一个库的名字里面有HDL，就代表这个模块可以用来生成HDL代码。</p><h1 id="一些常用操作"><a href="#一些常用操作" class="headerlink" title="一些常用操作"></a>一些常用操作</h1><h2 id="创建子系统"><a href="#创建子系统" class="headerlink" title="创建子系统"></a>创建子系统</h2><p>将库中的模块拖到主界面组合好后，可能会占据很大的空间，如果工程较大，模块越连越多就特别臃肿，因此当我们完成某个功能以后，就可以将这部分的模块全部选中，此时右下角会出现三个点，将鼠标移到上面后会展开，出现很多不同的功能。下图是一个AM调制的过程，可以看到选中所有相关的模块后点击创建子系统，即可得到右图的子系统。刚生成的子系统的命名为subsystem，可以将命名改为更清晰易懂的名字。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211056583.png" srcset="/img/banner.png" lazyload alt="2024after4202409211056583.png"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1726887497741.png" srcset="/img/banner.png" lazyload alt="1726887497741.png"></p><h2 id="观察节点的信号波形"><a href="#观察节点的信号波形" class="headerlink" title="观察节点的信号波形"></a>观察节点的信号波形</h2><p>当选中某根连线时，同样会出现三个点，鼠标移动到上面后会展开，选择WiFi形状的选项即可记录该连线上的信号。运行仿真后再次点击WiFi图标即可打开逻辑分析仪，即可查看该连线上的信号。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1726888515922.png" srcset="/img/banner.png" lazyload alt="1726888515922.png"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1726889009858.png" srcset="/img/banner.png" lazyload alt="1726889009858.png"></p><p>逻辑分析仪内部选中某个信号后即可在波形中调节数制、高度等设置。</p><blockquote><p>也可以使用scope模板看节点信号。</p></blockquote><h2 id="频谱分析"><a href="#频谱分析" class="headerlink" title="频谱分析"></a>频谱分析</h2><p>使用Spectrum Analyzer模块进行频谱分析。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211127829.png" srcset="/img/banner.png" lazyload alt="2024after4202409211127829.png"></p><p>当样点比较少的时候可以将估计方法改为welch。</p><h2 id="信号数据格式显示"><a href="#信号数据格式显示" class="headerlink" title="信号数据格式显示"></a>信号数据格式显示</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211131120.png" srcset="/img/banner.png" lazyload alt="2024after4202409211131120.png"></p><p>可以显示模块输入输出信号的数据类型和小数位数。</p><blockquote><p>采样时间一栏中的时间图例选中以后，会用不同的颜色显示不同采样速率的模块，在多速率系统设计中有很大的用处。</p></blockquote><h1 id="生成HDL代码"><a href="#生成HDL代码" class="headerlink" title="生成HDL代码"></a>生成HDL代码</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="设置诊断类型"><a href="#设置诊断类型" class="headerlink" title="设置诊断类型"></a>设置诊断类型</h3><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211138607.png" srcset="/img/banner.png" lazyload alt="2024after4202409211138607.png"></p><p>模型设置中选择诊断&#x2F;采样时间</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211139629.png" srcset="/img/banner.png" lazyload alt="2024after4202409211139629.png"></p><p>单任务和多任务数据传输必须设置成错误。</p><h3 id="兼容性检测"><a href="#兼容性检测" class="headerlink" title="兼容性检测"></a>兼容性检测</h3><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211145908.png" srcset="/img/banner.png" lazyload alt="2024after4202409211145908.png"></p><p>选择代码生成的目标文件夹，运行兼容性检查器，如果工程没有问题的话会出现如下界面</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1726890374067.png" srcset="/img/banner.png" lazyload alt="1726890374067.png"></p><h3 id="目标平台选择"><a href="#目标平台选择" class="headerlink" title="目标平台选择"></a>目标平台选择</h3><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211148557.png" srcset="/img/banner.png" lazyload alt="2024after4202409211148557.png"></p><p>根据使用的FPGA选择综合工具和FPGA的系列。</p><h3 id="模块设置"><a href="#模块设置" class="headerlink" title="模块设置"></a>模块设置</h3><p>在要生成代码的子系统上右键，选择HDL模块属性：</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211151201.png" srcset="/img/banner.png" lazyload alt="2024after4202409211151201.png"></p><p>可以对流水线、乘法器等参数进行设置</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1726890814415.png" srcset="/img/banner.png" lazyload alt="1726890814415.png"></p><blockquote><p>如果生成的代码在EDA工具中编译以后无法满足时序约束，可以加输入和输出的流水线</p></blockquote><blockquote><p>💡 如果模块的输出对前面的模块有反馈信号的话不能添加流水线，详细见<br><a href="https://blog.sawenmoerjie.top/article/ec96aebc-b5a5-4059-bbef-02f0003e7a45">bookmark</a></p></blockquote><pre><code class="hljs">[bookmark](https://blog.sawenmoerjie.top/article/ec96aebc-b5a5-4059-bbef-02f0003e7a45)</code></pre><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211154140.png" srcset="/img/banner.png" lazyload alt="2024after4202409211154140.png"></p><p>点击为子系统生成HDL代码后会自动进行一次编译，命令行窗口会出现如下信息</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1726891451673.png" srcset="/img/banner.png" lazyload alt="1726891451673.png"></p><p>同时会生成一个report</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211206344.png" srcset="/img/banner.png" lazyload alt="2024after4202409211206344.png"></p><p>没有报错的话即可在上面选择的文件夹里面看到生成的Verilog代码文件</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409211207218.png" srcset="/img/banner.png" lazyload alt="2024after4202409211207218.png"></p><p>将这些文件导入到EDA工具中即可直接例化使用。</p><blockquote><p>💡 所有文件都要导入，不能只导入需要的某个名字的模块！</p></blockquote><blockquote><p>💡 一定要看EDA软件编译后的报告，尤其是大型设计，很容易不满足时序要求，这个时候就要回去simulink里面优化设计，如果时序报告里面是A模块的某个地方时序满足不了要求，那么就要在simulink中在A模块中添加流水线。（注：Quartus中我没有遇见过时序报错的，可能是没有在Quartus中开发大工程）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多速率信号处理-Nobel恒等式</title>
    <link href="/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-Nobel%E6%81%92%E7%AD%89%E5%BC%8F/"/>
    <url>/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-Nobel%E6%81%92%E7%AD%89%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>典型的插值器的结构，滤波器位于插值操作后，意味着滤波器工作在较高的采样率下，对滤波器的设计带来压力。可以通过恒等变换将插值操作后置，滤波器前置，简化系统的设计。</p><h1 id="第一恒等式"><a href="#第一恒等式" class="headerlink" title="第一恒等式"></a>第一恒等式</h1><p>表明抽取操作位于乘加操作之后和抽取操作位于乘加之前是等效的。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725451305235.png" srcset="/img/banner.png" lazyload alt="1725451305235.png"></p><h1 id="第二恒等式"><a href="#第二恒等式" class="headerlink" title="第二恒等式"></a>第二恒等式</h1><p>M个延迟之后再进行M抽取和M抽取之后再进行1个延迟是等效的。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725451336136.png" srcset="/img/banner.png" lazyload alt="1725451336136.png"></p><h1 id="第三恒等式"><a href="#第三恒等式" class="headerlink" title="第三恒等式"></a>第三恒等式</h1><p>信号通过滤波器H（zM ）并经M抽取后与信号通过M抽取并经滤波器H（z）是等效的</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725451644008.png" srcset="/img/banner.png" lazyload alt="1725451644008.png"></p><h1 id="第四恒等式"><a href="#第四恒等式" class="headerlink" title="第四恒等式"></a>第四恒等式</h1><p>插值操作位于乘加之前与插值操作位于乘加之后是等效的</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725451694340.png" srcset="/img/banner.png" lazyload alt="1725451694340.png"></p><h1 id="第五恒等式"><a href="#第五恒等式" class="headerlink" title="第五恒等式"></a>第五恒等式</h1><p>信号先经1个延迟再做L插值与先经L插值再做L个延迟是等效的</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725451772371.png" srcset="/img/banner.png" lazyload alt="1725451772371.png"></p><h1 id="第六恒等式"><a href="#第六恒等式" class="headerlink" title="第六恒等式"></a>第六恒等式</h1><p>信号先经滤波器$H(z)$再做L插值与信号先做L插值再经滤波器$H(z^L)$是等效的</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725451845464.png" srcset="/img/banner.png" lazyload alt="1725451845464.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多速率信号处理-半带滤波器</title>
    <link href="/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8D%8A%E5%B8%A6%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8D%8A%E5%B8%A6%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>半带滤波器本质上是FIR滤波器，但是有近一半的系数为0，因此运算量降至普通FIR滤波器运算量的一半。</p><p>半带滤波器具有如下特性：</p><ol><li><p>半带滤波器的通带宽度$w_p（通带截止频率）$与阻带宽度$\pi-w_s（w_s为阻带起始频率）$相等，通带纹波和阻带纹波页相等</p></li><li><p>半带滤波器的频率响应满足</p><p> $$<br> H(\mathrm{e}^{\mathrm{j}w})+H(\mathrm{e}^{\mathrm{j}(\pi-w)})&#x3D;1<br> $$</p><pre><code class="hljs"> 单位冲激响应满足</code></pre></li></ol><p>$$<br>h(n)&#x3D;\begin{cases}0&amp;\text{当}n-\frac{N-1}{2}\text{为偶数时}\\frac{1}{2}&amp;\text{当}n&#x3D;\frac{N-1}{2}\text{时}\end{cases}<br>$$</p><p>N为滤波器长度，必须为奇数</p>]]></content>
    
    
    <categories>
      
      <category>数字通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多速率信号处理-插值和插值滤波器</title>
    <link href="/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E6%8F%92%E5%80%BC%E5%92%8C%E6%8F%92%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E6%8F%92%E5%80%BC%E5%92%8C%E6%8F%92%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>插值意味着提高采样率，故而被称为上采样（Up Sample）。设原始序列为$x(n)$，采样率为$f_x$，插值因子为$L$，则插值的过程为原始序列每相邻两个样点之间插入$L-1$个$0$构成一个新序列，数学表达式为</p><p>$$<br>y(m)&#x3D;\begin{cases}x(m&#x2F;L)&amp;m&#x3D;0,\pm L,\pm2L,\cdots\0&amp;\text{其他}\end{cases}<br>$$</p><p>以$f_y$表示$y(m)$的采样率，则采样率之间的关系为</p><p>$$<br>f_y&#x3D;L\times f_x<br>$$</p><p>图示如下：</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202409012121424.png" srcset="/img/banner.png" lazyload alt="2024after4202409012121424.png"></p><p>从频域角度看， 原始序列的频谱以$f_x$为周期做周期延拓。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725447693456.png" srcset="/img/banner.png" lazyload alt="1725447693456.png"></p><p>插值后的新序列以新的采样率$f_y$做周期延拓。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725447757213.png" srcset="/img/banner.png" lazyload alt="1725447757213.png"></p><p>可以看到插值前后频谱成分不变，但是在$f_x$的整数倍频点处的频谱称为镜像成分。所以插值后要加入一个低通滤波器滤除镜频。典型的插值器就是由上采样器和抗镜像滤波器共同完成的。</p><p>由于插值是在原始序列中插入零值，即某些采样点处的信号幅度为0，会改变信号的幅度，因此插值会造成信号幅度的损失。要保证插值前后信号幅度的统一，可在插值滤波器后设置一个增益因子L。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1725448598642.png" srcset="/img/banner.png" lazyload alt="1725448598642.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多速率信号处理</title>
    <link href="/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    <url>/2024/09/10/%E5%A4%9A%E9%80%9F%E7%8E%87%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>随着芯片技术的发展，ADC的采样率越来越高，导致数字化越来越靠近系统前端。目前，工程上采用较多的是中频采样技术，即在中频时就对模拟信号数字化，此时ADC的采样率低于奈奎斯特采样定律的最低采样率（2倍的信号带宽），为过采样。过采样可以将采样过程的固有的量化噪声均匀地分散在更大的带宽上，降低目标信号带宽上的噪声功率，随后通过滤波器滤除带外噪声，即可产生比临界采样信号更优的信噪比。</p><p>当信号被ADC采样并传输到FPGA时，信号就进入了数字域。然而过高的采样率会对后续的信号处理带来较大压力，为了缓解压力，就需要降低信号的采样率，即为抽取。抽取后的信号数据率相对较低，因而有效地降低了对FPGA资源的占用，同时有助于简化系统的时序收敛。</p><p>当驱动高速率DAC时，需要提高信号的采样率，即为内插。因为DAC的采样率越高，输出端的频谱的频域分离度就越高，可以简化DAC后的模拟滤波器的工作，从而提高信噪比。</p><p>多速率信号处理的典型应用即为数字上变频DUC（Digital Up Conversion）和数字下变频DDC（Digital Down Conversion）。</p><p><a href="13496f31-fcb9-816d-8cc0-e05c66331471">link_to_page</a></p><p><a href="13496f31-fcb9-8186-bf94-fe31291c933e">link_to_page</a></p><p><a href="13496f31-fcb9-8163-9dcf-c0bd2949f836">link_to_page</a></p><p><a href="13496f31-fcb9-81bf-b0ab-f0d52ec89d45">link_to_page</a></p><p><a href="13496f31-fcb9-81ab-9196-ed1f3f531a35">link_to_page</a></p>]]></content>
    
    
    <categories>
      
      <category>数字通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab的4个取整函数</title>
    <link href="/2024/09/03/Matlab%E7%9A%844%E4%B8%AA%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0/"/>
    <url>/2024/09/03/Matlab%E7%9A%844%E4%B8%AA%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Round"><a href="#Round" class="headerlink" title="Round"></a>Round</h1><p>舍入至最近的小数或整数</p><p><code>Y = round(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-X"><code>X</code></a><code>)</code> 将 <code>X</code> 的每个元素四舍五入为最近的整数。在舍入机会均等的情况下，即有元素的十进制小数部分为 <code>0.5</code>（在舍入误差内）时，<code>round</code> 函数会偏离零四舍五入到最接近的具有更大幅值的整数。</p><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftps_-1">示例</a></p><p><code>Y = round(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-X"><code>X</code></a><code>,</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-N"><code>N</code></a><code>)</code> 四舍五入到 <code>N</code> 位数：</p><ul><li><code>N &gt; 0</code>：舍入到小数点_右侧_的第 <code>N</code> 位数。</li><li><code>N = 0</code>：四舍五入到最接近的整数。</li><li><code>N &lt; 0</code>：舍入到小数点_左侧_的第 <code>N</code> 位数。</li></ul><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftptb-1">示例</a></p><p><code>Y = round(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-X"><code>X</code></a><code>,</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-N"><code>N</code></a><code>,</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-type"><code>type</code></a><code>)</code> 指定四舍五入的类型。指定 <code>&quot;significant&quot;</code> 以四舍五入为 <code>N</code> 位有效数（从最左位数开始计数）。在此情况下，<code>N</code> 必须为正整数。</p><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#mw_738f260a-a713-40d4-930e-ffe155a9db88">示例</a></p><p><code>Y = round(</code><strong><code>___</code></strong><code>,TieBreaker=</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#mw_e51282fd-7461-4bab-9f38-6106551bb8b2"><code>direction</code></a><code>)</code> 按照 <code>direction</code> 指定的方向对结值进行舍入。在上述语法中的任何输入参数组合后使用此参数。</p><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#bug2v_r-6">示例</a></p><p><code>Y = round(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-t"><code>t</code></a><code>)</code> 将 <code>duration</code> 数组 <code>t</code> 的每个元素四舍五入到最接近的秒数。</p><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#bug2v_r-6">示例</a></p><p><code>Y = round(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-t"><code>t</code></a><code>,</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/round.html#buftmpz-unit"><code>unit</code></a><code>)</code> 将 <code>t</code> 的每个元素四舍五入到指定单位时间的最接近的数。</p><h1 id="Ceil"><a href="#Ceil" class="headerlink" title="Ceil"></a>Ceil</h1><p>向正无穷舍入</p><p><code>Y = ceil(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/ceil.html#bug2ukg-1-X"><code>X</code></a><code>)</code> 将 <code>X</code> 的每个元素四舍五入到大于或等于该元素的最接近整数。</p><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/ceil.html#bug2um5-1">示例</a></p><p><code>Y = ceil(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/ceil.html#bug2ukg-1-t"><code>t</code></a><code>)</code> 将 <code>duration</code> 数组 <code>t</code> 的每个元素四舍五入到大于或等于此元素的最接近的秒数。</p><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/ceil.html#bug2um5-1">示例</a></p><p><code>Y = ceil(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/ceil.html#bug2ukg-1-t"><code>t</code></a><code>,</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/ceil.html#bug2ukg-1-unit"><code>unit</code></a><code>)</code> 将 <code>t</code> 的每个元素四舍五入到大于或等于此元素的最接近的数（使用指定的时间单位）。</p><h1 id="Floor"><a href="#Floor" class="headerlink" title="Floor"></a>Floor</h1><p>向负无穷舍入</p><p><code>Y = floor(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/floor.html#bug_5mn-1-X"><code>X</code></a><code>)</code> 将 <code>X</code> 的每个元素四舍五入到小于或等于该元素的最接近整数。</p><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/floor.html#bug_5mn-8">示例</a></p><p><code>Y = floor(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/floor.html#bug_5mn-1-t"><code>t</code></a><code>)</code> 将 <code>duration</code> 数组 <code>t</code> 的每个元素四舍五入到小于或等于此元素的最接近的秒数。</p><p><a href="https://127.0.0.1:31516/static/help/matlab/ref/floor.html#bug_5mn-8">示例</a></p><p><code>Y = floor(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/floor.html#bug_5mn-1-t"><code>t</code></a><code>,</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/floor.html#bug_5mn-1-unit"><code>unit</code></a><code>)</code> 将 <code>t</code> 的每个元素四舍五入到小于或等于该元素的最接近数（使用指定的时间单位）。</p><h1 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h1><p>向零舍入</p><p><code>Y = fix(</code><a href="https://127.0.0.1:31516/static/help/matlab/ref/fix.html#bul3slv-X"><code>X</code></a><code>)</code> 将 <code>X</code> 的每个元素朝零方向四舍五入为最近的整数。此操作实际上是通过删除 <code>X</code> 中每个数的小数部分，将它们截断为整数：</p><ul><li>对于正数，<code>fix</code> 的行为与 <code>floor</code> 相同。</li><li>对于负数，<code>fix</code> 的行为与 <code>ceil</code> 相同。</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年全国赛C题《 电容电感测量装置》设计报告</title>
    <link href="/2024/08/19/2023%E5%B9%B4%E5%85%A8%E5%9B%BD%E8%B5%9BC%E9%A2%98%E3%80%8A%20%E7%94%B5%E5%AE%B9%E7%94%B5%E6%84%9F%E6%B5%8B%E9%87%8F%E8%A3%85%E7%BD%AE%E3%80%8B%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
    <url>/2024/08/19/2023%E5%B9%B4%E5%85%A8%E5%9B%BD%E8%B5%9BC%E9%A2%98%E3%80%8A%20%E7%94%B5%E5%AE%B9%E7%94%B5%E6%84%9F%E6%B5%8B%E9%87%8F%E8%A3%85%E7%BD%AE%E3%80%8B%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="测量原理"><a href="#测量原理" class="headerlink" title="测量原理"></a>测量原理</h1><p>参考下面网站的方案</p><p><a href="https://bbs.eeworld.com.cn/thread-1265314-1-1.html">bookmark</a></p><p>参考LCR测试仪，基本工作原理为给DUT加上正弦激励信号，然后测得该DUT两端的电压和流过DUT的电流，即可通过计算得到DUT的性质和参数。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1720858696834.png" srcset="/img/banner.png" lazyload alt="1720858696834.png"></p><p>对于一个理想电容，电流相位应该超前电容两端电压90°。然而实际的电容存在损耗，可以等效为一个理想电容$C_p$和一个理想电阻$R_p$的并联，因此电流超前电压的相位将小于90°，这个角度差即为损耗角。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202407131621163.png" srcset="/img/banner.png" lazyload alt="2024after4202407131621163.png"></p><p>假设DUT两端电压$\dot{V}&#x3D;V\cos(\omega t)$，流过DUT的电流为$\dot{I}&#x3D;I sin(\omega t - \varphi)$，电流在虚轴上的投影为流过理想电容的电流，在实轴上的投影为流过损耗电阻的电流。</p><p>因此可以计算出并联电容的容抗为$X_{Cp}&#x3D;\frac{V}{I cos\varphi}$，容值$C_P&#x3D;\frac{1}{\omega X_{Cp}}&#x3D;\frac{I cos \varphi}{\omega V}$。</p><p>损耗电阻的值为$R_p&#x3D;\frac{V}{Isin\varphi}$。</p><p>定义元件消耗的无功功率和有功功率之比为元件的Q值，Q值的倒数为D值（损耗角正切）</p><p>$$<br>Q&#x3D;\frac{R_P}{X_{Cp}}&#x3D;cot \varphi, D&#x3D;\frac{1}{Q}&#x3D;tan \varphi<br>$$</p><p>上述需要的参数可以借助正交算法求得：</p><p>$$<br>\begin{align}I\sin(\omega t-\varphi)\cdot V\cos(\omega t) &amp; &#x3D; \frac12VI\sin(2\omega t-\varphi)-\frac12VI\sin\varphi\I\sin(\omega t-\varphi)\cdot V\sin(\omega t) &amp; &#x3D; -\frac12VI\cos(2\omega t-\varphi)+\frac12VI\cos\varphi \end{align}<br>$$</p><p>相乘以后经过低通滤波器后即可得到直流成分$-\frac{1}{2} VI sin\varphi 和\frac{1}{2} VI cos\varphi$，即可求得题目要求的损耗角正切</p><p>$$<br>tan\varphi &#x3D; \frac{VI sin \varphi}{VI cos \varphi}<br>$$</p><p>同时可求得以下参数</p><p>$$<br>\text{并联形式的理想电容的容抗 }X_{cp}&#x3D;\frac V{I\cos\varphi}&#x3D;\frac{V^2}{VI\cos\varphi} \text{,电容为 }C_p&#x3D;\frac1{\omega X_{cp}},\text{并联形式的损耗电阻}\R_{p}&#x3D;\frac V{I\sin\varphi}&#x3D;\frac{V^2}{VI\sin\varphi}\text{。其中 }V^2\text{可以通过电压自乘后滤除高频成分后得到。}<br>$$</p><h1 id="参数仿真"><a href="#参数仿真" class="headerlink" title="参数仿真"></a>参数仿真</h1><p>现有的ADC的输入电压范围为0~2V，输入偏置为1V；DAC的输出电压范围为1V峰峰值，同时可以加偏置，</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1721052590800.png" srcset="/img/banner.png" lazyload alt="1721052590800.png"></p><p>电容容值为1nF-100nF，检流电阻为0.33Ω时，输出电压峰峰值为4-200mv。测量电感时频率为1MHz，电感感值为10uF-100uF时，输出电压峰峰值为15-150mv。由于ADC模块的输入范围为0~2V，因此对信号进行9倍放大，峰峰值放大到1.8V左右。</p><h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><p>DAC输出的信号和LC滤波器阻抗不匹配，导致LC滤波器的输入端信号幅值较低</p><p>待测元件检测电路上电后输入端有-500mv的偏置</p><p>LC滤波器设计如下，DAC输出1MHz的信号时高次谐波较为严重，因此设计一个通带为1.2MHz的LC低通滤波器滤除高次杂波。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1721448168186.png" srcset="/img/banner.png" lazyload alt="1721448168186.png"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1721448231710.png" srcset="/img/banner.png" lazyload alt="1721448231710.png"></p><h1 id="PCB设计"><a href="#PCB设计" class="headerlink" title="PCB设计"></a>PCB设计</h1><h2 id="初代"><a href="#初代" class="headerlink" title="初代"></a>初代</h2><p>其中R8是用来连接测试夹具的，激励信号从P1输入，经过R8上的待测电容或电感后电流经过C5流入后级电流检测电路，</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202407211655761.svg" srcset="/img/banner.png" lazyload alt="2024after4202407211655761.svg"></p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1721560509597.png" srcset="/img/banner.png" lazyload alt="1721560509597.png"></p><p>这样设计的话，电路的输入阻抗为测量夹具上的待测元件的在特定频率下的阻抗值，而前级放大器的输出阻抗为50Ω，会导致输入信号的幅值不是期望的幅值。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>将前级放大器的输出端用于阻抗匹配的50Ω电阻拆掉，利用运放输出阻抗很低的特性，使得输出的信号的电压全都加在上面电路的输入端。</p><p>这样改进的原因是运放后级不带容性负载、LC滤波器、长同轴电缆的话输出端不需要接匹配电阻。</p><h1 id="FPGA程序设计"><a href="#FPGA程序设计" class="headerlink" title="FPGA程序设计"></a>FPGA程序设计</h1><p>根据上面的原理，需要两个ADC采集电流和电压信号，1个DAC生成激励信号。因此选择DE0nano，有两个扩展的40pin排针，可以接入两个ADDA模块。</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202407231614021.bmp" srcset="/img/banner.png" lazyload alt="2024after4202407231614021.bmp"></p><p>FPGA的晶振频率为50MHz，通过PLL分频出20MHz和80MHz，其中ADC的时钟为20M，DAC的时钟为80M。然后分别连接到ADC_Interface和DAC_Interface。</p><p>ADC部分采集到的信号位宽为10，舍弃低两位以便于后续对信号的处理，同时每采1024个样点后暂停0.5秒，然后再进行下次采集。</p><p>DAC部分采用一个NCO生成正弦波信号，通过拨码开关切换频率字，输出到DAC_interface后左移1位后输出，再通过一个同相放大器放大2倍，增强信号的驱动能力。</p><p>ADC采集到的电流和电压的数据存放到RAM中，通过改变起始的取地址来实现移相。使用的ADC的采样率为20M，采集100K的信号时，每个周期采集200个点，因此想要移相$\frac{\pi}{2}$时，只需要从50开始读取RAM里的数据，读出的信号即为从0开始读取的RAM的读出的信号进行$\frac{\pi}{2}$移相后的信号。</p><p>经ADC采集的数据为无符号数，做乘法滤波会和计算结果不匹配，因此再加入一级无符号转有符号数的module，转成有符号数后做乘法，再送入低通滤波器后即可获得需要的数值。对低通滤波器的输出进行截断，只保留高16位的数据，降低抖动的直流信号对结果的影响。  </p><h1 id="测量结果"><a href="#测量结果" class="headerlink" title="测量结果"></a>测量结果</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1721657082949.png" srcset="/img/banner.png" lazyload alt="1721657082949.png"></p><p>第一个Lowpass的输出为$VIcos\phi$，第二个Lowpass的输出为$\frac{1}{2}VIcos \varphi$，第三个Lowpass的输出为$V^2$，容抗的计算过程如下:</p><p>根据仿真的输入电流和输出电压的拟合关系可得，在输出采集的电压的幅值等于电流÷0.305，因此容抗为 第三个输出÷2÷第一个输出÷0.305</p><h2 id="电路展示"><a href="#电路展示" class="headerlink" title="电路展示"></a>电路展示</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202407231606426.jpg" srcset="/img/banner.png" lazyload alt="2024after4202407231606426.jpg"></p><h1 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h1><p>加入spi通信，将采样计算出的数据传输到TI的开发板上进行进一步计算和显示。</p>]]></content>
    
    
    <categories>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
      <tag>Report</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C标准库读写文件</title>
    <link href="/2024/06/20/C%E6%A0%87%E5%87%86%E5%BA%93%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/"/>
    <url>/2024/06/20/C%E6%A0%87%E5%87%86%E5%BA%93%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h1><h2 id="库变量"><a href="#库变量" class="headerlink" title="库变量"></a>库变量</h2><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>size_t</td><td>无符号整数类型，是sizeof关键字的结果，表示对象大小</td></tr><tr><td>FILE</td><td>文件流类型，适合存储文件流信息的对象类型</td></tr></tbody></table><h2 id="库宏"><a href="#库宏" class="headerlink" title="库宏"></a>库宏</h2><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td>NULL</td><td>空指针常量</td></tr><tr><td>EOF</td><td>表示已经到达文件结束的负整数</td></tr><tr><td>stderr、stdin、stdout</td><td>指向FILE类型的指针，分别对应标准错误、标准输入和标准输出流</td></tr></tbody></table><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span> <br><span class="hljs-comment">//以给定的模式mode打开filename指向的文件</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>mode</th><th>描述</th></tr></thead><tbody><tr><td>“r“</td><td>打开一个用于读取的文件，文件必须存在</td></tr><tr><td>”w“</td><td>创建一个用于写入的空文件。若存在同名文件，则删除旧文件的内容</td></tr><tr><td>”a“</td><td>追加到一个文件，写操作向文件末尾追加数据，文件不存在就创建文件</td></tr><tr><td>”r+“</td><td>打开一个用于更新的文件，可读取也可写入。该文件必须存在</td></tr><tr><td>”w+“</td><td>创建一个用于读写的空文件</td></tr><tr><td>“a+”</td><td>打开一个用于读取和追加的文件</td></tr></tbody></table><p>函数返回一个FILE指针，否则返回NULL</p><h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><p>声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span><br><span class="hljs-comment">//ptr：指向带有最小尺寸 size*nmemb 字节的内存块的指针</span><br><span class="hljs-comment">//size：读取的每个元素的大小，以字节为单位</span><br><span class="hljs-comment">//nmemb：元素的个数</span><br><span class="hljs-comment">//stream：指向FILE对象的指针，指定了一个输入流</span><br></code></pre></td></tr></table></figure><p>成功读取的元素会以size_t对象返回</p><h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span><br><span class="hljs-comment">//ptr：指向被写入元素数组的指针</span><br><span class="hljs-comment">//size：读取的每个元素的大小，以字节为单位</span><br><span class="hljs-comment">//nmemb：元素的个数</span><br><span class="hljs-comment">//stream：指向FILE对象的指针，指定了一个输出流</span><br></code></pre></td></tr></table></figure><h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span><br><span class="hljs-comment">//stream：指向FILE对象的指针</span><br><span class="hljs-comment">//offset：相对whence的偏移量，以字节为单位</span><br><span class="hljs-comment">//whence：表示开始添加偏移的位置</span><br></code></pre></td></tr></table></figure><p>whence一般为下面三个常量</p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件开头</td></tr><tr><td>SEEK_CUR</td><td>文件指针的当前位置</td></tr><tr><td>SEEK_END</td><td>文件的末尾</td></tr></tbody></table><p>返回从whence位置开始查找的字节数</p><h3 id="ftell"><a href="#ftell" class="headerlink" title="ftell"></a>ftell</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span><br></code></pre></td></tr></table></figure><p>返回位置标识符的当前值</p><h1 id="使用C标准库读取TS文件并写入txt"><a href="#使用C标准库读取TS文件并写入txt" class="headerlink" title="使用C标准库读取TS文件并写入txt"></a>使用C标准库读取TS文件并写入txt</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *fileInput, *fileOutput;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">188</span>];  <span class="hljs-comment">// TS流的标准包大小为188字节</span><br>    <span class="hljs-type">size_t</span> bytesRead;<br><br>    <span class="hljs-comment">// 打开TS文件</span><br>    fileInput = fopen(<span class="hljs-string">&quot;/home/sawen/my_test_pcie/test.ts&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!fileInput) &#123;<br>        perror(<span class="hljs-string">&quot;Failed to open input file&quot;</span>);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input file opened successfully.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查文件大小</span><br>    fseek(fileInput, <span class="hljs-number">0</span>, SEEK_END);<br>    <span class="hljs-type">long</span> fileSize = ftell(fileInput);<br>    rewind(fileInput);<br>    <span class="hljs-keyword">if</span> (fileSize == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input file is empty.\n&quot;</span>);<br>        fclose(fileInput);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input file size: %ld bytes.\n&quot;</span>, fileSize);<br>    &#125;<br><br>    <span class="hljs-comment">// 打开TXT文件</span><br>    fileOutput = fopen(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!fileOutput) &#123;<br>        perror(<span class="hljs-string">&quot;Failed to open output file&quot;</span>);<br>        fclose(fileInput);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Output file opened successfully.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 读取数据并写入到TXT文件</span><br>    <span class="hljs-type">int</span> packetCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((bytesRead = fread(buffer, <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(buffer), fileInput)) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; bytesRead; ++i) &#123;<br>            <span class="hljs-built_in">fprintf</span>(fileOutput, <span class="hljs-string">&quot;%02x &quot;</span>, buffer[i]); <span class="hljs-comment">// 将字节以十六进制格式写入</span><br>        &#125;<br>        <span class="hljs-built_in">fprintf</span>(fileOutput, <span class="hljs-string">&quot;\n&quot;</span>);  <span class="hljs-comment">// 每个TS包后换行</span><br>        packetCount++;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否有数据被读取</span><br>    <span class="hljs-keyword">if</span> (packetCount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No data read from file.\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Processed %d TS packets.\n&quot;</span>, packetCount);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    fclose(fileInput);<br>    fclose(fileOutput);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data transfer complete.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1718891286912.png" srcset="/img/banner.png" lazyload alt="1718891286912.png"></p><p>可以看到以188个字节为一行写入txt</p>]]></content>
    
    
    <categories>
      
      <category>杂类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MATLAB中使用HDL Coder生成HDL代码时的报错集合</title>
    <link href="/2024/06/13/MATLAB%E4%B8%AD%E4%BD%BF%E7%94%A8HDL%20Coder%E7%94%9F%E6%88%90HDL%E4%BB%A3%E7%A0%81%E6%97%B6%E7%9A%84%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/"/>
    <url>/2024/06/13/MATLAB%E4%B8%AD%E4%BD%BF%E7%94%A8HDL%20Coder%E7%94%9F%E6%88%90HDL%E4%BB%A3%E7%A0%81%E6%97%B6%E7%9A%84%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Delay-balancing-unsuccessful-because-an-extra-4-cycles-of-latency-introduced-by-optimizations-in-the-feedback-loop-cannot-be-offset-using-design-delays-for-the-loop-latency-budget"><a href="#Delay-balancing-unsuccessful-because-an-extra-4-cycles-of-latency-introduced-by-optimizations-in-the-feedback-loop-cannot-be-offset-using-design-delays-for-the-loop-latency-budget" class="headerlink" title="Delay balancing unsuccessful because an extra 4 cycles of latency introduced by optimizations in the feedback loop cannot be offset using design delays for the loop latency budget."></a>Delay balancing unsuccessful because an extra 4 cycles of latency introduced by optimizations in the feedback loop cannot be offset using design delays for the loop latency budget.</h1><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202406132008890.png" srcset="/img/banner.png" lazyload alt="2024after4202406132008890.png"></p><p>由于时序考虑，在每个模块的输出端添加了1到2级的输入输出流水线，但是在这种带反馈的结构上添加输入输出流水线后，会产生如下的报错</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1718280602962.png" srcset="/img/banner.png" lazyload alt="1718280602962.png"></p><p>可以看出加入的输入输出流水线会导致额外的时钟延时，使得延时平衡失败。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在保证时序的前提下将带有反馈回路的模块输入输出流水线设置为0，也可以在同级输出端口加入delay手动添加流水线。</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modelsim中使用tcl命令导出仿真数据到txt文件</title>
    <link href="/2024/06/09/Modelsim%E4%B8%AD%E4%BD%BF%E7%94%A8tcl%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BA%E4%BB%BF%E7%9C%9F%E6%95%B0%E6%8D%AE%E5%88%B0txt%E6%96%87%E4%BB%B6/"/>
    <url>/2024/06/09/Modelsim%E4%B8%AD%E4%BD%BF%E7%94%A8tcl%E5%91%BD%E4%BB%A4%E5%AF%BC%E5%87%BA%E4%BB%BF%E7%9C%9F%E6%95%B0%E6%8D%AE%E5%88%B0txt%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>参考下面的CSDN博客</p><p><a href="https://blog.csdn.net/lum250/article/details/121237146">bookmark</a></p><h1 id="Tcl命令"><a href="#Tcl命令" class="headerlink" title="Tcl命令"></a>Tcl命令</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog">proc write_sim_data &#123;env name radix cycle file&#125; &#123;<br>    set fid [open $file w]<br>    <span class="hljs-keyword">for</span> &#123;set i <span class="hljs-number">0</span>&#125; &#123;$i &lt;= $::now&#125; &#123;incr i [expr $cycle * <span class="hljs-number">1000</span>]&#125; &#123;<br>        set str [exa -env $env -radix $radix -<span class="hljs-keyword">time</span> $&#123;i&#125;ps &#123;*&#125;$name]<br>        puts $fid $str<br>    &#125;<br>    close $fid <br>&#125;  <br><br><br></code></pre></td></tr></table></figure><ul><li><p>Line1：定义一个名为write_sim_data的过程，参数列表为：{env name radix cycle file}</p><p>  env：指定查找对象名称的路径。如top_tb&#x2F;top_u<br>  name：需要导出的变量列表。如{I_reset_n R_data_cnt}<br>  radix：进制。可选：ascii,binary, decimal,hexadecimal,unsigned等<br>  cycle：时钟周期，单位ns<br>  file：输出文件。如.&#x2F;1.txt</p></li><li><p>Line2：打开一个文档，返回文件描述符</p></li><li><p>Line3：分别获得从0到仿真结尾时间，按时钟周期间隔对数据进行取样输出</p></li><li><p>Line4：获得具体数据</p></li><li><p>Line5：将数据写入文件</p></li><li><p>Line7：关闭文件</p></li></ul><p>示例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">write_sim_data sim:/top_tb/u_top_wrapper/top_i/RS_Enc_0 &#123;RS_Out Trigger&#125; <span class="hljs-keyword">unsigned</span> <span class="hljs-number">1000</span> data<span class="hljs-variable">.txt</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xilinx FPGA中的BUFFER</title>
    <link href="/2024/05/29/Xilinx%20FPGA%E4%B8%AD%E7%9A%84BUFFER/"/>
    <url>/2024/05/29/Xilinx%20FPGA%E4%B8%AD%E7%9A%84BUFFER/</url>
    
    <content type="html"><![CDATA[<p>FPGA大型设计中推荐使用同步时序电路，同步时序电路基于时钟触发沿设计，对时钟的周期、占空比、延时和抖动有更高的要求。为满足时序的要求，一般采用全局时钟资源驱动设计的主时钟，FPGA的主时钟一般使用全铜层工艺实现，并设计了专用时钟缓冲与驱动结构。</p><h1 id="缓冲和驱动"><a href="#缓冲和驱动" class="headerlink" title="缓冲和驱动"></a>缓冲和驱动</h1><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>输入输出缓冲，主要用于片外输入时钟或者片外差分输入的信号。</p><p>差分信号和差分时钟进入片内后如果不经过IBUFGDS、IBUFDS缓冲就无法直接处理</p><h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p>当信号扇出过大时可以通过加BUFG增加信号稳定性</p><p>过一次BUFG有10ns左右的延时，但是通过BUFG后输出到片上所有单元的延时都可以忽略不记</p><h1 id="Buffer的类别和作用"><a href="#Buffer的类别和作用" class="headerlink" title="Buffer的类别和作用"></a>Buffer的类别和作用</h1><h2 id="BUFG"><a href="#BUFG" class="headerlink" title="BUFG"></a>BUFG</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1716954745330.png" srcset="/img/banner.png" lazyload alt="1716954745330.png"></p><p>BUFG是一个高扇出缓冲器，将信号连接到全局布线资源上，使得信号的延时和抖动最小</p><p>通常用于时钟网络以及其他高扇出网络，比如复位和使能信号</p><h2 id="BUFGCE"><a href="#BUFGCE" class="headerlink" title="BUFGCE"></a>BUFGCE</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1716954943324.png" srcset="/img/banner.png" lazyload alt="1716954943324.png"></p><p>BUFGCE具有单门控输入的全局时钟缓冲器，CE高电平有效</p><p>当CE为低电平时 O 端口输出0</p><h2 id="BUFH"><a href="#BUFH" class="headerlink" title="BUFH"></a>BUFH</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1716962343955.png" srcset="/img/banner.png" lazyload alt="1716962343955.png"></p><p>BUFH原语允许直接访问BUFG的时钟区域入口，允许访问全局时钟网络中未使用的部分，作为高速低偏移的本地路由资源（单时钟区域）</p><h2 id="IBUFDS"><a href="#IBUFDS" class="headerlink" title="IBUFDS"></a>IBUFDS</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1716963068218.png" srcset="/img/banner.png" lazyload alt="1716963068218.png"></p><p>支持低压差分信号输入的缓冲器，有两个输入的端口，一个为主端口一个为从端口，输入的信号相位相反</p><h2 id="IBUFDS-GTE2"><a href="#IBUFDS-GTE2" class="headerlink" title="IBUFDS_GTE2"></a>IBUFDS_GTE2</h2><p>7系列器件中的Gbit 收发器输入缓冲，REFCLK应连接到串行收发器的专用参考时钟输入引脚</p><h2 id="OBUFDS"><a href="#OBUFDS" class="headerlink" title="OBUFDS"></a>OBUFDS</h2><p>差分信号输出缓冲器</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NCO模块的各项参数</title>
    <link href="/2024/05/19/NCO%E6%A8%A1%E5%9D%97%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0/"/>
    <url>/2024/05/19/NCO%E6%A8%A1%E5%9D%97%E7%9A%84%E5%90%84%E9%A1%B9%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>NCO模块可以生成实数或者复数正弦信号，同时提供硬件友好的控制信号</p><h1 id="Accumulator累加器位数"><a href="#Accumulator累加器位数" class="headerlink" title="Accumulator累加器位数"></a>Accumulator累加器位数</h1><p>正弦波的频率分辨率取决于累加器的位数的大小，根据频率分辨率可以计算出累加器的位数，根据此位数设置累加器的数据类型字长</p><p>计算公式为</p><p>$$<br>N&#x3D;ceil(log_2(\frac{F_s}{\Delta f}))<br>$$</p><h1 id="量化位数"><a href="#量化位数" class="headerlink" title="量化位数"></a>量化位数</h1><p>量化累加器的输出可以在不增加查找表的大小的情况下提高频率分辨率</p><p>要根据无杂散动态范围来计算量化位数，计算公式为</p><p>$$<br>Q&#x3D;ceil(\frac{SFDR-12}{6})<br>$$</p><h1 id="相位增量"><a href="#相位增量" class="headerlink" title="相位增量"></a>相位增量</h1><p>$$<br>phInc&#x3D;round(\frac{f\times 2^N}{F_s})<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数字通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字通信</tag>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运放的同相与反相放大</title>
    <link href="/2024/05/05/%E8%BF%90%E6%94%BE%E7%9A%84%E5%90%8C%E7%9B%B8%E4%B8%8E%E5%8F%8D%E7%9B%B8%E6%94%BE%E5%A4%A7/"/>
    <url>/2024/05/05/%E8%BF%90%E6%94%BE%E7%9A%84%E5%90%8C%E7%9B%B8%E4%B8%8E%E5%8F%8D%E7%9B%B8%E6%94%BE%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="反相放大器"><a href="#反相放大器" class="headerlink" title="反相放大器"></a>反相放大器</h1><p>同相端接地，电压为 0，反相端和同相端虚短，因此也是 0 V 的电压，同时由于虚断，几乎没有电流注入，所以R 1 和R 2 相当于串联，电阻上的电流相等</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202405051202106.png" srcset="/img/banner.png" lazyload alt="2024after4202405051202106.png"></p><p>因此可以求出输入输出关系式为</p><p>$$<br>V_{out}&#x3D;-\frac{R_2}{R_1}\times V_i<br>$$</p><h1 id="同相放大器"><a href="#同相放大器" class="headerlink" title="同相放大器"></a>同相放大器</h1><p>同样根据虚断和虚短可以求得输入输出关系式为</p><p>$$<br>V_{out}&#x3D;\frac{R_1+R_2}{R_2}\times V_i <br>$$</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202405051206856.png" srcset="/img/banner.png" lazyload alt="2024after4202405051206856.png"></p><h1 id="同相放大器和反相放大器的优缺点"><a href="#同相放大器和反相放大器的优缺点" class="headerlink" title="同相放大器和反相放大器的优缺点"></a>同相放大器和反相放大器的优缺点</h1><h2 id="反相放大器-1"><a href="#反相放大器-1" class="headerlink" title="反相放大器"></a>反相放大器</h2><ul><li>优点：两个输入端电位始终近似为 0，只有差模信号，抗干扰能力强</li><li>缺点：输入阻抗小，等于信号到输入端的串联电阻阻值</li></ul><h2 id="同相放大器-1"><a href="#同相放大器-1" class="headerlink" title="同相放大器"></a>同相放大器</h2><ul><li>优点：输入阻抗接近无穷大</li><li>缺点：放大电路没有虚地，有较大共模电压，抗干扰能力差，使用时要求运放有较高的共模抑制比</li></ul><p>如果要求输入阻抗不高且相位无要求时，首选反相放大，因为反相放大只存在差模信号，抗干扰能力强，可以得到更大的输入信号范围</p><p>在设计中要求放大倍数相同的情况下尽量选择数值小的电阻配合，这样可以减小输入偏置电流的影响和分布电容的影响</p>]]></content>
    
    
    <categories>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vivado报错集合</title>
    <link href="/2024/05/01/Vivado%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/"/>
    <url>/2024/05/01/Vivado%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Synth-8-5535"><a href="#Synth-8-5535" class="headerlink" title="Synth 8-5535"></a><strong>Synth 8-5535</strong></h1><p>报错代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog">[Synth <span class="hljs-number">8</span>-<span class="hljs-number">5535</span>] port &lt;clk_0&gt; has illegal connections. It is illegal to have a port connected to an <span class="hljs-keyword">input</span> buffer <span class="hljs-keyword">and</span> other components. The following are the port connections :<br>Input Buffer:<br>Port I of <span class="hljs-keyword">instance</span> clkin1_ibufg(IBUF) in <span class="hljs-keyword">module</span> &lt;top_clk_wiz_0_1_clk_wiz&gt;<br>Other Components:<br><br></code></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>普通IO输入的时钟信号必须要经过buffer才能驱动PLL</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>将clocking wizard中的输入信号配置为 No Buffer</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202405011507953.png" srcset="/img/banner.png" lazyload alt="2024after4202405011507953.png"></p><h1 id="Warning：filegmt-56-199"><a href="#Warning：filegmt-56-199" class="headerlink" title="Warning：filegmt 56-199"></a>Warning：filegmt 56-199</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1715671392034.png" srcset="/img/banner.png" lazyload alt="1715671392034.png"></p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>在Sources栏右键选择refresh hierarchy即可</p><h1 id="Warning：CRITICAL-WARNING-filemgmt-56-176-Module-references-are-not-supported-in-manual-compile-order-mode-and-will-be-ignored"><a href="#Warning：CRITICAL-WARNING-filemgmt-56-176-Module-references-are-not-supported-in-manual-compile-order-mode-and-will-be-ignored" class="headerlink" title="Warning：CRITICAL WARNING: [filemgmt 56-176] Module references are not supported in manual compile order mode and will be ignored."></a>Warning：CRITICAL WARNING: [filemgmt 56-176] Module references are not supported in manual compile order mode and will be ignored.</h1><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202405152050816.png" srcset="/img/banner.png" lazyload alt="2024after4202405152050816.png"></p><p>将刷新层次结构的模式设置为自动更新和编译即可</p><h1 id="BD-41-237-Bus-Interface-property-FREQ-HZ-does-not-match-between-M-AXIS-DATA-0-100000000-and-dds-compiler-0-M-AXIS-DATA-200000000"><a href="#BD-41-237-Bus-Interface-property-FREQ-HZ-does-not-match-between-M-AXIS-DATA-0-100000000-and-dds-compiler-0-M-AXIS-DATA-200000000" class="headerlink" title="[BD 41-237] Bus Interface property FREQ_HZ does not match between &#x2F;M_AXIS_DATA_0(100000000) and &#x2F;dds_compiler_0&#x2F;M_AXIS_DATA(200000000)"></a>[BD 41-237] Bus Interface property FREQ_HZ does not match between &#x2F;M_AXIS_DATA_0(100000000) and &#x2F;dds_compiler_0&#x2F;M_AXIS_DATA(200000000)</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1716115542445.png" srcset="/img/banner.png" lazyload alt="1716115542445.png"></p><p>引发这个报错的原因是IP核的时钟频率为200M，但是AXI4s的端口的频率为100M，因此将端口的频率设置为和IP核匹配的频率即可</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/2024after4202405191846838.png" srcset="/img/banner.png" lazyload alt="2024after4202405191846838.png"></p><h1 id="vivado的各种设置无法保存"><a href="#vivado的各种设置无法保存" class="headerlink" title="vivado的各种设置无法保存"></a>vivado的各种设置无法保存</h1><h2 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h2><p>“C:\Users\31651\AppData\Roaming\Xilinx\Vivado\2023.2\vivado.xml”这个文件里面存放了vivado的设置，例如最近打开的文件等</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1716627301329.png" srcset="/img/banner.png" lazyload alt="1716627301329.png"></p><p>如果这些路径中有中文字符或其他vivado无法识别的字符，那么每次启动时vivado无法正常读取这些配置，就会重置这个文件，表现为重启vivado后所有配置全部丢失</p><h2 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h2><p>将含有中文字符的文件路径删除或者改成英语命名</p><h1 id="Common-17-180-Spawn-failed-No-error"><a href="#Common-17-180-Spawn-failed-No-error" class="headerlink" title="[Common 17-180] Spawn failed: No error"></a>[Common 17-180] Spawn failed: No error</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1736078187552.png" srcset="/img/banner.png" lazyload alt="1736078187552.png"></p><h2 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h2><p>在 Vivado 中，报错信息 <strong>“[Common 17-180] Spawn failed: No error”</strong> 表示 Vivado 无法成功启动或创建某个进程，尽管没有明确的错误信息。这个错误通常发生在 Vivado 尝试启动外部进程或执行某些操作时，比如编译、生成比特流或启动仿真工具等。</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab生成txt文件导入到Vivado仿真</title>
    <link href="/2024/04/25/Matlab%E7%94%9F%E6%88%90txt%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E5%88%B0Vivado%E4%BB%BF%E7%9C%9F/"/>
    <url>/2024/04/25/Matlab%E7%94%9F%E6%88%90txt%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E5%88%B0Vivado%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Matlab处理数据并将其写入txt文件"><a href="#Matlab处理数据并将其写入txt文件" class="headerlink" title="Matlab处理数据并将其写入txt文件"></a>Matlab处理数据并将其写入txt文件</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% Txt Generate</span><br>pre_RS_data=dec2bin(simDataIn,<span class="hljs-number">8</span>);       <span class="hljs-comment">%将数据转化为8bit的二进制</span><br>fid=fopen(<span class="hljs-string">&quot;F:\FPGA\Xilinx_vivado\project\dvbstestbench\dbvs\matlab\pre_RS_data.txt&quot;</span>,<span class="hljs-string">&quot;wt&quot;</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:n*nMessages         <span class="hljs-comment">%数据长度</span><br>    fprintf(fid,<span class="hljs-string">&quot;%s\n&quot;</span>,pre_RS_data(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>:<span class="hljs-number">8</span>));  <span class="hljs-comment">%由于二进制数据为8位，因此是1:8</span><br><span class="hljs-keyword">end</span><br>fclose(fid);<br></code></pre></td></tr></table></figure><p>使用fopen函数获取文件id，fopen的语法如下</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1714036628457.png" srcset="/img/banner.png" lazyload alt="1714036628457.png"></p><p>其中permisson为文件访问类型，有以下几种权限</p><table><thead><tr><th><code>&#39;r&#39;</code></th><th>打开要读取的文件。</th></tr></thead><tbody><tr><td><code>&#39;w&#39;</code></td><td>打开或创建要写入的新文件。放弃现有内容（如果有）。</td></tr><tr><td><code>&#39;a&#39;</code></td><td>打开或创建要写入的新文件。追加数据到文件末尾。</td></tr><tr><td><code>&#39;r+&#39;</code></td><td>打开要读写的文件。</td></tr><tr><td><code>&#39;w+&#39;</code></td><td>打开或创建要读写的新文件。放弃现有内容（如果有）。</td></tr><tr><td><code>&#39;a+&#39;</code></td><td>打开或创建要读写的新文件。追加数据到文件末尾。</td></tr><tr><td><code>&#39;A&#39;</code></td><td>打开文件以追加（但不自动刷新）当前输出缓冲区。</td></tr><tr><td><code>&#39;W&#39;</code></td><td>打开文件以写入（但不自动刷新）当前输出缓冲区。</td></tr></tbody></table><blockquote><p>💡 要以文本模式打开的话，要附加’t’</p></blockquote><h1 id="Vivado中testbench写法"><a href="#Vivado中testbench写法" class="headerlink" title="Vivado中testbench写法"></a>Vivado中testbench写法</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns/1ps</span><br><br><span class="hljs-keyword">module</span> top_tb();<br><br><span class="hljs-keyword">reg</span> clk;<br><span class="hljs-keyword">reg</span> rst_n;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]SEQ_IN_0;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] data_mem[<span class="hljs-number">1</span>:<span class="hljs-number">1020</span>];<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i;<br><span class="hljs-keyword">wire</span> BIN_OUT;<br><span class="hljs-keyword">wire</span> ce_out;<br><span class="hljs-keyword">wire</span> locked;<br><br><span class="hljs-comment">//clk &amp; rst_n gen</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    clk=<span class="hljs-number">1&#x27;b0</span>;<br>    rst_n=<span class="hljs-number">1&#x27;b0</span>;<br>    #<span class="hljs-number">100</span><br>    rst_n=<span class="hljs-number">1&#x27;b1</span>;  <br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk=~clk;<br><br><span class="hljs-comment">//data read</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-built_in">$readmemb</span>(<span class="hljs-string">&quot;F:/FPGA/Xilinx_vivado/project/dvbstestbench/dbvs/matlab/pre_RS_data.txt&quot;</span>,data_mem);<br>  <br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">forever</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1020</span>)  <span class="hljs-keyword">begin</span><br>            i=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span> <br>            i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%s&quot;</span>,data_mem[i]);<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    SEQ_IN_0&lt;=data_mem[i];<br><span class="hljs-keyword">end</span><br><br>top_wrapper top_wrapper_u0(<br>    <span class="hljs-variable">.clk_0</span>    (clk),<br>    <span class="hljs-variable">.rst_n_0</span>  (rst_n),<br>    <span class="hljs-variable">.SEQ_IN_0</span>(SEQ_IN_0),<br>    <span class="hljs-variable">.BIN_OUT_0</span>  (BIN_OUT),<br>    <span class="hljs-variable">.ce_out_0</span>   (ce_out),<br>    <span class="hljs-variable">.locked_0</span>   (locked)<br>);<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><blockquote><p>💡 直接在文件夹内部复制的文件路径是\，但是testbench中要将所有反斜杠改为&#x2F;，否则无法读取txt文件</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DVB-S系统仿真学习</title>
    <link href="/2024/03/27/DVB-S%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/27/DVB-S%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>DVB-S系统用于卫星电视信号传输，发送端框图如下所示</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1711536126647.png" srcset="/img/banner.png" lazyload alt="1711536126647.png"></p><h1 id="扰码"><a href="#扰码" class="headerlink" title="扰码"></a>扰码</h1><p>实际数字通信中，载荷数据的码元会出现长连0或长连1的情况，不利于接收端提取时钟信号，同时会使得数据流中含有大量的低频分量，使得QPSK调制器的相位长时间不变，使得信号易受干扰。因此要对载荷数据进行随机化扰码处理</p><p>DVB-S标准中规定扰码的生成多项式为</p><p>$$<br>p(x)&#x3D;x^{15}+x^{14}+1<br>$$</p><p>同时移位寄存器的初始状态为”1001_0101_0000_000”</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1711536797434.png" srcset="/img/banner.png" lazyload alt="1711536797434.png"></p><h2 id="Matlab代码仿真"><a href="#Matlab代码仿真" class="headerlink" title="Matlab代码仿真"></a>Matlab代码仿真</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">n=<span class="hljs-number">500</span>;<br><span class="hljs-comment">% origin_data=randi([0 1],n,1);</span><br>origin_cnt_1=nnz(origin_data==<span class="hljs-number">1</span>)<br><br>scrambling = comm.Scrambler(<span class="hljs-string">&quot;CalculationBase&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;InitialConditions&quot;</span>,[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>], ...<br>    <span class="hljs-string">&quot;Polynomial&quot;</span>,[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]);<br>scrambling_data=step(scrambling,origin_data);<br>scrambling_data_cnt_1=nnz(scrambling_data==<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>运行结果如下图所示</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1711536855542.png" srcset="/img/banner.png" lazyload alt="1711536855542.png"></p><p>可以看出初始的500点长度的数据包中有403个“1”，经过扰码处理后“1”的个数接近数据总量的一半</p><h1 id="外码纠错编码（RS编码）"><a href="#外码纠错编码（RS编码）" class="headerlink" title="外码纠错编码（RS编码）"></a>外码纠错编码（RS编码）</h1><p>RS码定义：</p><p>$GF(q)上（q \neq 2, 通常q&#x3D;2^m），码长n&#x3D;q-1的本原BCH码$</p><p>能纠正 t 个错误的RS码的参数为</p><pre><code class="hljs">- 分组长度n=q-1- 校验符号数n-k=2t- 码的最小距离dmin=2t+1</code></pre><p>DVB-S系统中使用的RS(188，204)是由RS(239,255)截断而来的，可以纠正8个字节的错误</p><h2 id="Matlab仿真"><a href="#Matlab仿真" class="headerlink" title="Matlab仿真"></a>Matlab仿真</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab">m=<span class="hljs-number">8</span>; <span class="hljs-comment">%bit per symbol</span><br>n=<span class="hljs-number">204</span>;<br>k=<span class="hljs-number">188</span>;<br><br>data_test=randi([<span class="hljs-number">0</span>,n],<span class="hljs-number">1</span>,k);<br>data_gf=gf(data_test,m);<br><br>data_rs_enc=rsenc(data_gf,n,k);<br>data_enc=data_rs_enc.x;<br><br>data_rs_dec=rsdec(data_rs_enc,n,k);<br>data_dec=data_rs_dec.x;<br><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>stem(data_test);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>stem(data_enc);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>stem(data_dec);<br></code></pre></td></tr></table></figure><p>首先生成一个长度为188的序列，将其转换到伽罗华域后，使用rsenc函数进行RS编码，再进行译码，根据对比可以看出译码后的比特和译码前的完全一样</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1711538853533.png" srcset="/img/banner.png" lazyload alt="1711538853533.png"></p><h1 id="卷积交织"><a href="#卷积交织" class="headerlink" title="卷积交织"></a>卷积交织</h1><p>在实际的传输过程中，由于脉冲干扰、多径效应等因素会带来持续一定时间的突发错误，虽然RS码对突发错误有较好的纠错能力，但是当其持续时间较长时，就会超出RS码的纠错能力，因此在编码过程中引入了卷积交织，将数据的传输顺序按照一定的规律分散开，就可以使得错误的码元也被分散开</p><p>DVB-S中交织深度为12，总共17个FIFO，数据按行写入寄存器，按列读出</p><p>交织后最大可纠错长度为12*8&#x3D;96</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1711539867512.png" srcset="/img/banner.png" lazyload alt="1711539867512.png"></p><p>可以看出前一段时间读取到了很多0，说明下面的移位寄存器中的数据还没有移动到末端</p><h1 id="卷积编码"><a href="#卷积编码" class="headerlink" title="卷积编码"></a>卷积编码</h1><p>卷积码是一种有效的前向纠错码记作$(n,k,m)$，将k个信息比特编为n个比特，m为编码存储长度，N&#x3D;m+1为约束长度，即卷积码的当前码元不仅与当前输入的k的信息码元有关，还与前面m个时刻输入的信息码元有关</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clc;<br>close all;<br>n=<span class="hljs-number">500</span>;<br>tre1=[<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>]; <span class="hljs-comment">%oct 171</span><br>tre2=[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span>]; <span class="hljs-comment">%oct 133</span><br><br>trellis = poly2trellis(<span class="hljs-number">7</span>,[<span class="hljs-number">171</span> <span class="hljs-number">133</span>]);<br><br>convData=convenc(scrambling_data,trellis);<br><br>decData=vitdec(convData,trellis,<span class="hljs-number">499</span>,<span class="hljs-string">&quot;trunc&quot;</span>,<span class="hljs-string">&quot;hard&quot;</span>);<br><br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>stem(scrambling_data);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>stem(convData);<br>subplot(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>stem(decData);<br>biterr(scrambling_data,decData)<br></code></pre></td></tr></table></figure><p>使用poly2trellis将卷积编码多项式转换为网格描述</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1711541868504.png" srcset="/img/banner.png" lazyload alt="1711541868504.png"></p><p>比对后可以看到解码出的数据和原数据完全相同</p>]]></content>
    
    
    <categories>
      
      <category>数字通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QPSK simulink实现</title>
    <link href="/2024/03/24/QPSK%20simulink%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/03/24/QPSK%20simulink%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="调制部分"><a href="#调制部分" class="headerlink" title="调制部分"></a>调制部分</h1><h2 id="总体框架"><a href="#总体框架" class="headerlink" title="总体框架"></a>总体框架</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212057092.png#id=LJGlx&originHeight=501&originWidth=1636&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/banner.png" lazyload alt="image"></p><h2 id="各模块参数"><a href="#各模块参数" class="headerlink" title="各模块参数"></a>各模块参数</h2><p>升余弦滚降滤波器滚降系数为 1</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401211628053.png#height=385&id=bhKfw&originHeight=599&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=500" srcset="/img/banner.png" lazyload alt="image"></p><p>单双极性变换</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401211629886.png#height=312&id=zaVYy&originHeight=357&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=500" srcset="/img/banner.png" lazyload alt="image"></p><h2 id="各阶段波形"><a href="#各阶段波形" class="headerlink" title="各阶段波形"></a>各阶段波形</h2><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212121669.png#id=OcUth&originHeight=683&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/banner.png" lazyload alt="image"></p><h2 id="Demux"><a href="#Demux" class="headerlink" title="Demux"></a>Demux</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212121971.png#id=nYMmd&originHeight=628&originWidth=702&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/banner.png" lazyload alt="image"></p><h2 id="Raised-Cosine-Transmit"><a href="#Raised-Cosine-Transmit" class="headerlink" title="Raised Cosine Transmit"></a>Raised Cosine Transmit</h2><p>Filter</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212127899.png#id=oRiV8&originHeight=628&originWidth=702&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/banner.png" lazyload alt="image"></p><h2 id="QPSK-信号功率谱密度"><a href="#QPSK-信号功率谱密度" class="headerlink" title="QPSK 信号功率谱密度"></a>QPSK 信号功率谱密度</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212131255.png#id=zvEIe&originHeight=664&originWidth=1002&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/banner.png" lazyload alt="image"></p><h1 id="解调部分"><a href="#解调部分" class="headerlink" title="解调部分"></a>解调部分</h1><p>经过 AWGN 信道后，假设已经进行了载波同步</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212140586.png#id=mIoHF&originHeight=433&originWidth=1257&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/banner.png" lazyload alt="image"></p><h2 id="部分模块参数"><a href="#部分模块参数" class="headerlink" title="部分模块参数"></a>部分模块参数</h2><h2 id="载波模块"><a href="#载波模块" class="headerlink" title="载波模块"></a>载波模块</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212141258.png#height=630&id=fwivS&originHeight=759&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=475" srcset="/img/banner.png" lazyload alt="image"></p><h2 id="Pulse-Generator"><a href="#Pulse-Generator" class="headerlink" title="Pulse Generator"></a>Pulse Generator</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212142578.png#height=643&id=jBQqM&originHeight=736&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=500" srcset="/img/banner.png" lazyload alt="image"></p><p>由于经过了串并转换，因此数据率减半</p><h2 id="部分波形"><a href="#部分波形" class="headerlink" title="部分波形"></a>部分波形</h2><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212150099.png#id=wGg2F&originHeight=1021&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/banner.png" lazyload alt="image"></p><p>将初始信号经过一定时间的延时后，在示波器中和解调输出的信号基本对齐，可以发现基本实现<br>QPSK 调制解调</p><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/pic/202401212152756.png#id=q8Kha&originHeight=1021&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="/img/banner.png" lazyload alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>数字通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字通信</tag>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8bit数据转1bit逐位输出电路仿真</title>
    <link href="/2024/03/23/8bit%E6%95%B0%E6%8D%AE%E8%BD%AC1bit%E9%80%90%E4%BD%8D%E8%BE%93%E5%87%BA%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9F/"/>
    <url>/2024/03/23/8bit%E6%95%B0%E6%8D%AE%E8%BD%AC1bit%E9%80%90%E4%BD%8D%E8%BE%93%E5%87%BA%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>在DVB-S系统中，TS流在经过RS编码后，会变成uint8类型的数据，在后续QPSK星座映射时又需要二进制码流，因此在进行了RS编码后要将8个bit的数据转化成1个bit逐位输出</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>首先使用BitwiseOperator模块按位与操作，分别将8位二进制数据提取出来，然后使用一个计数器产生0~7的计数信号作为mux模块的使能，在8个时钟周期内分别输出提取出来的8位数据</p><h1 id="结构框图"><a href="#结构框图" class="headerlink" title="结构框图"></a>结构框图</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1713153777444.png" srcset="/img/banner.png" lazyload alt="1713153777444.png"></p><h1 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h1><p><img src="https://sawen-pic-blog.oss-cn-beijing.aliyuncs.com/utool_pic/1713153816902.png" srcset="/img/banner.png" lazyload alt="1713153816902.png"></p><p>输入的数据是133，二进制为10000101，可以看到输出的结果符合需求</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AXI-STREAM简介</title>
    <link href="/2024/03/20/AXI-STREAM%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/03/20/AXI-STREAM%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="AXI-STREAM简介"><a href="#AXI-STREAM简介" class="headerlink" title="AXI-STREAM简介"></a>AXI-STREAM简介</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AXI-Stream总线是一种高效、简单的数据传输协议，主要用于高吞吐量的数据流传输场景。相比于传统的AXI总线，AXI-Stream总线更加简单和轻量级，它通过无需地址的方式，将数据从一个模块传输到另一个模块，适用于需要高速数据传输的应用场景。</p><h2 id="部分术语"><a href="#部分术语" class="headerlink" title="部分术语"></a>部分术语</h2><ul><li>Transfer：基于<strong>TVALID</strong>和<strong>TREADY</strong>握手协议的传输</li><li>Packet：一组通过axi-stream传输的数据</li><li>Frame：最大的Byte组合，包含整数个Packet</li></ul><h2 id="接口信号"><a href="#接口信号" class="headerlink" title="接口信号"></a>接口信号</h2><table><thead><tr><th>信号</th><th>描述</th></tr></thead><tbody><tr><td>ACLK</td><td>全局时钟信号，上升沿有效</td></tr><tr><td>ARSTn</td><td>全局复位信号，低电平有效</td></tr><tr><td>TVALID</td><td>主机驱动有效数据</td></tr><tr><td>TREADY</td><td>从机可以接收数据</td></tr><tr><td>TDATA[(8n-1):0]</td><td>位宽为整数倍byte</td></tr><tr><td>TLAST</td><td>表示数据包的边界</td></tr><tr><td>TID</td><td>由主机发出，Identity标识符，在存在多个stream数据传输时起作用，用于识别不同的数据流</td></tr></tbody></table><p><img src="https://s11.ax1x.com/2023/12/22/pi7uxYV.png" srcset="/img/banner.png" lazyload alt="pi7uxYV.png"></p><p>当clk上升沿检测到TVALID和TREADY均为高电平时开始传输数据</p><p>由于AXI-STREAM不需要传输地址，仅进行简单的发送和接收，因此减小了传播时延</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
